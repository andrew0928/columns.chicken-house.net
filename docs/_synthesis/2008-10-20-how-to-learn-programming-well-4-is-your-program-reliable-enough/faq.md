---
layout: synthesis
title: "該如何學好 \"寫程式\" #4. 你的程式夠 \"可靠\" 嗎?"
synthesis_type: faq
source_post: /2008/10/20/how-to-learn-programming-well-4-is-your-program-reliable-enough/
redirect_from:
  - /2008/10/20/how-to-learn-programming-well-4-is-your-program-reliable-enough/faq/
---

# 該如何學好 "寫程式" #4. 你的程式夠 "可靠" 嗎?

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是軟體工程師？與 programmer 有何差異？
- A簡: 軟體工程師在正確程式之上，重視可靠性、結構與系統整合，用專業方法把程式「寫好」，不只「寫對」。
- A詳: Programmer 著重把功能寫對、選好演算法與資料結構。軟體工程師更進一步，需整合解法與資源（語言、工具、函式庫），設計穩健結構，並以制度預防錯誤，如斷言、追蹤、測試與組態管理。其核心任務是提升可靠性、維護性與可擴充性，並在未知情境下具備防禦與診斷能力。換言之，從「能動」到「動得對、動得久、動得安穩」，以專業流程（設計、檢核、監控、迭代）把產品品質落實。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q4, B-Q14

A-Q2: 什麼是「程式可靠性」？
- A簡: 程式在多種正常與異常情況下仍正確、穩定、可診斷、易維護，並能預防與減輕錯誤影響的能力。
- A詳: 可靠性涵蓋正確性（無邏輯錯誤）、穩定性（不輕易崩潰）、可預測性（行為一致）、可診斷性（問題能浮現並被追蹤）、易維護性（結構清晰）、與防禦性（對未知輸入與狀況有免疫力）。實務上透過斷言（Assert）揭露假設、追蹤（Trace）紀錄關鍵訊息、區分 Debug/Release 行為、單元測試與輸入驗證等方法，將問題前置化與可觀測化，降低缺陷密度並縮短修復時間。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, B-Q5, C-Q2

A-Q3: 為什麼軟體工程師需要特別重視可靠性？
- A簡: 可靠性直接影響用戶信任、維運成本與風險；提早預防與揭露錯誤遠比事後修補更經濟。
- A詳: 在商業場景，錯誤帶來金錢風險（例如金融計算）、品牌受損與維運負擔。可靠性工程將「及早偵測、明確失敗、易於定位」內建流程：以 Assert 明確化假設、用 Trace 擷取證據、以測試覆蓋邊界情況、再區分 Debug/Release 以降低生產環境負荷。這些手段可顯著降低缺陷密度與修復平均時間（MTTR），讓團隊更專注於價值開發而非救火。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q5, B-Q10

A-Q4: 專業程式與業餘程式有何差異？
- A簡: 專業程式以制度化品質保證：防呆、防禦、可觀測、可測試、可維護；業餘程式多憑直覺堆疊功能。
- A詳: 業餘程式常僅聚焦功能可動，缺少對邊界與異常的設計。專業程式則強調「寫好」：明確前後置條件、以斷言固定假設、建立追蹤與日誌、風險驅動的測試、清晰的結構與命名、與可配置的行為切換（Debug/Release）。同時注重讀性與可演化，使未來的修正、擴充與問題定位成本顯著降低。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q9, B-Q11

A-Q5: 什麼是「讓問題浮現」？
- A簡: 主動用斷言與追蹤，把隱藏錯誤在開發/測試階段即刻暴露，避免潛藏至正式環境。
- A詳: 錯誤不可避免，關鍵在於縮短發現與定位時間。以 Assert 在關鍵假設點失敗即停，提供錯誤位置與原因；以 Trace 記錄重要路徑與變數，支援重現與分析。再配合測試與異常處理，將「安靜失敗」轉為「可觀測失敗」。此策略稱為 fail-fast，能阻斷錯誤擴散，避免造成不一致狀態或錯誤結果（如錯誤加分、負分未限）。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q10, C-Q2, D-Q10

A-Q6: Debug 模式與 Release 模式差異是什麼？
- A簡: Debug 強調除錯與觀測資訊；Release 強調效能與穩定，常關閉或減少除錯檢查與輸出。
- A詳: 傳統上 Debug 內含斷言、豐富追蹤、非最佳化編譯，利於定位問題；Release 進行最佳化、減少/禁用除錯輸出以提升效能。在 .NET 中，行為可由條件編譯與設定檔共同控制：Debug/Trace 呼叫、Listener 與 Switch 皆可配置。目標是開發測試期訊息盡量多、正式環境訊息足以運維且不影響性能。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q8, C-Q4, D-Q8

A-Q7: 什麼是 Trace？何時使用？
- A簡: Trace 是執行時紀錄機制，用於輸出關鍵訊息至輸出窗或日誌，協助診斷與稽核。
- A詳: Trace 透過 API（如 System.Diagnostics.Trace）發送訊息到各類 Listener（Visual Studio Output、檔案、事件記錄）。可記錄關鍵流程、輸入摘要、決策點與錯誤線索。其可由組態與開關控制細節等級與輸出目的，使開發期訊息足、正式期精簡且可回溯。與斷言不同，Trace 不中止程式，而是保留證據。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, B-Q7, C-Q3

A-Q8: 什麼是 Assert（斷言）？核心價值為何？
- A簡: 斷言用來表達程式假設，違反即立刻報錯與中止，讓錯誤早爆早修。
- A詳: Assert 明確化不可違反的前提與不變條件，如「文件不為 null」、「分數範圍合理」、「選項數一致」。當條件為假，立刻停止流程並提供診斷資訊。相較於把所有檢查寫入主流程，斷言具可讀性高、成本低且可由模式/組態控制是否啟用，提升 fail-fast 能力與長期可維護性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q6, C-Q2, D-Q1

A-Q9: 為什麼不把所有檢查都寫進主流程？
- A簡: 檢查過多會淹沒主邏輯、拖累效能、增加維護成本；需以斷言與分層策略取捨。
- A詳: 一味堆疊 if/throw 會讓程式讀性差、重覆與難維護；且有些檢查僅在開發測試期有價值（揭錯），不需長駐於正式版。策略是：對外部輸入做必要驗證（防呆），對內部假設用斷言（fail-fast）；用 Trace 記錄證據；並以組態與模式控制檢查密度，取得可觀測性與效能平衡。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q11, C-Q9

A-Q10: 什麼是防呆與防禦性設計？
- A簡: 防呆針對使用/輸入錯誤預防；防禦性設計則全面考量未知與異常，限制損害並可診斷。
- A詳: 防呆著重輸入格式與流程限制，避免錯誤操作進入系統；防禦性設計擴及內部狀態、邊界條件、依賴失效時的隔離與降級。兩者結合：輸入驗證、斷言、不變式、邊界保護（如最低分為 0）、冗餘檢查與觀測，確保在非理想情境下仍有可預期行為與可追溯線索。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, D-Q3, D-Q4

A-Q11: 輸入驗證與斷言有何差異？
- A簡: 輸入驗證面向外部使用錯誤，要處理與回報；斷言面向內部假設，違反即失敗以便修正。
- A詳: 輸入驗證是功能的一部分，需提供友善錯誤訊息或回復策略；斷言用於開發/測試期鎖定程式不應違反的條件，失敗時應中止並修正程式。混用會造成使用者體驗不佳或隱藏缺陷。良好實務：對外做嚴謹驗證，對內用斷言，兩者各司其職。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q11, C-Q6

A-Q12: 為何要同時維護 Debug 與 Release 兩種版本？
- A簡: 兩版滿足不同目標：除錯觀測與生產效能穩定；利於早期揭錯與正式運行的平衡。
- A詳: Debug 提供豐富資訊與斷言，讓問題快速浮現與定位；Release 採最佳化與精簡紀錄，避免性能負擔。搭配設定檔與條件編譯，可在 Release 保留必要監控（如關鍵 Trace）。此雙軌策略在品質、效能、維運之間取得動態平衡。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q6, B-Q8, C-Q4

A-Q13: .NET 中 Trace/Assert 與設定檔的關係？
- A簡: 透過組態可控制 Listener、開關與輸出目的；配合條件編譯調整啟用狀態與成本。
- A詳: System.Diagnostics 支援在 app.config 設定 trace listeners（如 Default、TextWriter、EventLog）、switches 與過濾等級；同時可藉條件編譯/組態決定 Debug/Trace 呼叫是否生效與輸出位置。此機制讓不同環境的觀測密度與管道可控，達成「開發詳、上線精」的可觀測性策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, B-Q8, C-Q3

A-Q14: 單元測試與 Trace/Assert 的關係？
- A簡: 單元測試驗證行為；Assert 固定假設；Trace 提供證據。三者互補形成完整品質保證。
- A詳: 測試定義期望與邊界用例，Assert 於程式內保護不變式與快速失敗，Trace 記錄執行脈絡與資料點。測試失敗時，斷言與追蹤縮短定位時間；而斷言觸發的案例，亦可轉化為迴歸測試。三者建立「預防—揭露—回歸」循環，提升可靠性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q5, D-Q10

A-Q15: 在專業開發中如何表達與檢驗「假設」？
- A簡: 以斷言標注關鍵假設、用測試覆蓋、以 Trace 觀測，並將規則固化為程式合約與檢核表。
- A詳: 將假設具體化為前置條件、後置條件與不變式，於程式內用 Assert 表示；建立對應測試案例驗證；在關鍵路徑加 Trace 觀測資料。並以文件與檢核表讓團隊共識一致，降低隱含前提造成的缺陷。必要時以 guard clause 與錯誤處理守護外部輸入。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q6, C-Q9, D-Q1

---

### Q&A 類別 B: 技術原理類

B-Q1: 範例的計分流程如何運作？
- A簡: 讀取試卷與答案 XML，逐題計分，依規則加減，彙總並套用最低分限制。
- A詳: 技術原理說明：以 XPath 擷取 /quiz/question 節點逐一處理；每題取得 score、選項數與作答情況，正確加分、錯誤扣分。關鍵步驟或流程：載入 XmlDocument→檢查題數一致→逐題計算→累計→套用下限（如 Math.Max(0, total)）。核心組件介紹：System.Xml、選項比對、配分計算、下限規則。加入斷言與追蹤後，流程於關鍵點驗證假設並輸出診斷。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, C-Q8, D-Q1

B-Q2: 為何會出現「負分」問題？修正原理是什麼？
- A簡: 全錯或多錯時累計扣分超過加分，總分可能小於零；加下限規則即可修正。
- A詳: 技術原理說明：單題或總分的加減若未限定範圍，累退可致負分。關鍵步驟或流程：完成整體計分後，應套用合理邊界（如總分下限 0）；或於單題計分後以 Min/Max 約束。核心組件介紹：數值邏輯的邊界控制（Clamp），與斷言檢核（Assert(total>=0)）。Fail-fast 可在未套用下限時即時揭錯，避免誤發成績。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, C-Q8, D-Q1

B-Q3: 「放棄不計分」的檢測流程是什麼？
- A簡: 若該題無任何選項被勾選，視為放棄，直接回傳 0 分不加不扣。
- A詳: 技術原理說明：以 XPath 檢索 item[@checked='true'] 計數為 0 判定放棄。關鍵步驟或流程：讀題→檢查是否至少一項作答→若否回傳 0→若是再進入加扣流程。核心組件介紹：XML 節點查詢、放棄規則、早退（early return）與斷言保護（題目/答案選項數一致）。此流程可透過 Trace 記錄放棄事件利於稽核。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, C-Q2, D-Q2

B-Q4: 題目與答案選項數不一致如何檢測與處置？
- A簡: 以斷言驗證兩側選項數相同；失敗則 fail-fast，避免錯算與資料錯置。
- A詳: 技術原理說明：比較 quiz_question.SelectNodes("item").Count 與 paper_question.SelectNodes("item").Count。關鍵步驟或流程：計分前斷言數量一致→若否中止與提示→修正資料或流程再重試。核心組件介紹：斷言（Assert）與追蹤（Trace），確保資料契約。必要時對外回報資料錯誤，並建立資料驗證程序。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, C-Q7, D-Q3

B-Q5: .NET 中 Trace/Assert 背後的機制是什麼？
- A簡: 透過 System.Diagnostics 對 Listener 發訊；斷言違反時觸發對話與中止，受組態與編譯符號影響。
- A詳: 技術原理說明：Trace/Debug API 以 Conditional 屬性與組態控制輸出；Listener 決定輸出位置。Assert 失敗時拋出對話提示、寫入訊息、可中止或中斷。關鍵步驟或流程：呼叫 Trace/Assert→判斷條件→送往 Listener。核心組件介紹：Trace、Debug、TraceListener、Switch、app.config 之 system.diagnostics 區段。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, A-Q13, C-Q3

B-Q6: 如何用斷言實作前置條件與後置條件？
- A簡: 在方法進入處斷言輸入與環境、離開處斷言結果與不變式，違反即早爆。
- A詳: 技術原理說明：前置條件檢查參數非空、結構一致；後置條件檢查回傳值範圍與狀態不變。關鍵步驟或流程：方法開始 Assert(非空/格式正確)→邏輯→結尾 Assert(分數在合理區間)。核心組件介紹：Guard Clauses、Assert 與不變式。此法將隱含規則透明化並可測試，減少灰色錯誤。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, C-Q2, D-Q10

B-Q7: Trace 訊息如何從程式流向 Visual Studio Output 或檔案？
- A簡: 由 Trace 呼叫被 Listener 擷取，常見有 Default、TextWriter、EventLog 等，可由組態設定。
- A詳: 技術原理說明：Trace.WriteLine 產生訊息，Listener 決定輸出位置。關鍵步驟或流程：配置 app.config 的 system.diagnostics→新增 listener→設定 switch→在程式呼叫 Trace。核心組件介紹：TraceSource、TraceListener、Switch、Filter。此架構支援多目的地、多等級，便於分環境控管。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, A-Q13, C-Q3

B-Q8: Debug/Release 與條件編譯、設定檔如何共同影響行為？
- A簡: 編譯符號決定呼叫是否編入，設定檔決定輸出與等級；兩者協同調整可觀測性與成本。
- A詳: 技術原理說明：Conditional 屬性可使特定呼叫（如 Debug）在 Release 被省略；Trace 常保留而由設定檔控制輸出。關鍵步驟或流程：設定建置組態→定義符號→配置 system.diagnostics→測試輸出。核心組件介紹：DEBUG/TRACE 符號、Listener、Switch。此混合式控制讓開發期細、上線期精簡但可追溯。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, A-Q13, C-Q4

B-Q9: 為什麼斷言能同時提升可維護性與效能？
- A簡: 斷言將檢查從主邏輯抽離、提高可讀性；在正式環境可關閉或降低成本，保效能。
- A詳: 技術原理說明：把「內部假設」交給斷言處理，主流程專注業務邏輯，避免 if 汙染。關鍵步驟或流程：以 Assert 表達不變式→由模式/組態控制→在 Debug 足量揭錯、Release 降低負擔。核心組件介紹：Assert、條件編譯、Listener 與 Switch。此策略實現清晰結構與彈性成本控制。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q6, C-Q9

B-Q10: 如何用斷言實踐 fail-fast 策略？
- A簡: 在關鍵假設點放置斷言，違反即中止並輸出訊息，防止錯誤擴散與資料污染。
- A詳: 技術原理說明：Fail-fast 強調盡早、明確失敗。關鍵步驟或流程：辨識風險點（空參數、數量不符、範圍）→置入 Assert→附帶 Trace 訊息→在測試期觸發即修。核心組件介紹：Assert、Trace、測試框架。此法避免「錯中錯」連鎖，縮短 MTTR 並提高品質。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q14, D-Q10

B-Q11: 斷言與例外處理在職責上如何分工？
- A簡: 斷言保護內部假設、開發期失敗即停；例外處理用於可預期外部錯誤並優雅回應。
- A詳: 技術原理說明：錯誤分層—外部輸入錯誤（驗證→例外/回應）、內部不變式違反（斷言→修程式）。關鍵步驟或流程：辨識錯誤來源→決定斷言或例外→提供足夠 Trace 資訊。核心組件介紹：Assert、Exception、輸入驗證。此分工避免把程式錯誤包裝成使用者錯，或讓使用者錯誤中斷服務。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, D-Q5, D-Q6

B-Q12: 如何用資料結構與契約降低邏輯錯誤？
- A簡: 以明確 XML/結構契約限制自由度，搭配斷言與驗證，讓不合法狀態難以形成。
- A詳: 技術原理說明：資料契約（如 XSD、欄位約束）使輸入結構化、可驗證。關鍵步驟或流程：定義結構→驗證載入→計分前斷言一致性。核心組件介紹：XML/XSD、驗證器、Assert、測試。良好的資料形狀能讓程式更簡單、錯誤更早被攔截。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q7, D-Q3, D-Q5

B-Q13: 如何整合演算法、工具與資源達到最佳化？
- A簡: 選擇合適演算法與資料結構，並結合語言、函式庫、設定檔達成可靠、可維護實作。
- A詳: 技術原理說明：以業務需求驅動演算法，善用框架（System.Xml、Diagnostics）與組態（system.diagnostics）強化可觀測性。關鍵步驟或流程：需求→設計→實作→檢核→監控→迭代。核心組件介紹：演算法、資料結構、斷言/追蹤、組態。此整合體現軟體工程師的專業價值。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q1, A-Q4, C-Q1

B-Q14: 專家如何系統性地找出未知 BUG？
- A簡: 以懷疑態度設計實驗，建立反例測資，結合斷言與追蹤，使問題可重現與定位。
- A詳: 技術原理說明：從需求與假設出發，設計邊界/異常用例（滿分、全錯、空白）；以斷言鎖定假設；用 Trace 收集線索。關鍵步驟或流程：重現→縮小範圍→定位→修復→回歸測試。核心組件介紹：測試資料、Assert、Trace、回歸套件。此流程大幅提升除錯效率與品質。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q5, D-Q2, D-Q9

B-Q15: 為何「警告標示」比「派警衛」更務實？
- A簡: 以斷言/追蹤標示風險點成本低、覆蓋廣；全面檢查常致成本與複雜度爆炸。
- A詳: 技術原理說明：在每個路口派警衛（全面檢查）昂貴且難維護；張貼警示（斷言/追蹤）讓問題易見可記錄，兼顧成本與覆蓋。關鍵步驟或流程：辨識高風險點→布設斷言/追蹤→對外輸入做必要驗證。核心組件介紹：Assert、Trace、驗證器、組態。此策略達到「足夠安全」與可持續維護的平衡。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, B-Q9, C-Q9

---

### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何以 C# 實作計分核心（ComputeQuizScore/Question）？
- A簡: 逐題讀取 XML，依正誤加減，放棄回 0，最後以 Math.Max 套最低分規則。
- A詳: 具體實作步驟: 1) 載入 XmlDocument；2) 迭代 /quiz/question；3) 單題取得 score、項數與作答；4) 正確加、錯誤扣、空白回 0；5) 總分 Math.Max(0, total)。關鍵程式碼片段或設定: 
  int total=0; foreach(q){ total+=Score(q,p); } return Math.Max(0,total);
  注意事項與最佳實踐: 資料契約一致；邊界條件（全錯、空白）；以斷言與追蹤保護假設並記錄關鍵路徑。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, B-Q2, C-Q8

C-Q2: 如何用 Trace.Assert 為計分流程加防護？
- A簡: 在方法入口與關鍵計算後加入 Assert，搭配 Trace 記錄例外情形，違反即早停。
- A詳: 具體實作步驟: 1) 入口 Assert(quizDoc!=null && paperDoc!=null)；2) 斷言題數一致；3) 單題斷言選項數一致；4) 結尾斷言分數範圍。關鍵程式碼片段或設定: 
  Trace.Assert(quiz!=null); Trace.Assert(countQ==countP); Trace.WriteLine("skip");
  注意事項與最佳實踐: 僅對內部假設用斷言；訊息清楚可定位；於 Debug 開啟、Release 精簡保留必要 Trace。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q6, B-Q10

C-Q3: 如何以 App.config 啟用 Trace Listener 輸出到 VS/檔案？
- A簡: 在 system.diagnostics 設定 listener 與 switches，將 Trace 輸出導向 Output、檔案等。
- A詳: 具體實作步驟: 1) 建立 app.config；2) 設定 <system.diagnostics>、sources、listeners（Default、TextWriterTraceListener）；3) 指定檔名與等級；4) 測試輸出。關鍵程式碼片段或設定: 
  <listeners><add name="file" type="...TextWriterTraceListener" initializeData="log.txt"/></listeners>
  注意事項與最佳實踐: 分環境設定不同等級；滾動檔案；避免敏感資訊；監控檔案大小與I/O成本。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, B-Q7, B-Q8

C-Q4: 如何在 Release 保留必要 Trace 並控管成本？
- A簡: 留關鍵節點與錯誤級訊息，透過 switch 等級與 listener 過濾，避免大量 I/O。
- A詳: 具體實作步驟: 1) 定義關鍵 Trace 點（輸入摘要、得分結果、錯誤）; 2) 在 Release 啟用 Warning/Error；3) 用 Filter/Switch 控制；4) 導向異步/批次輸出。關鍵程式碼片段或設定: switches add value="Warning"; listener Filter=EventTypeFilter。注意事項與最佳實踐: 測量效能影響；避免熱路徑大量字串拼接；必要時包裝輕量記錄器。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q8, D-Q8

C-Q5: 如何撰寫單元測試覆蓋滿分、空白、全錯三種答案卷？
- A簡: 建立三組輸入 XML，斷言結果分別為滿分、0 分、下限 0，並驗證關鍵行為。
- A詳: 具體實作步驟: 1) Arrange: 準備 QUIZ、PAPER-PERFECT、PAPER-NORMAL1、PAPER-NATIVE；2) Act: 呼叫計分；3) Assert: 滿分=總分、空白=0、全錯=0（或負分前限）。關鍵程式碼片段或設定: Assert.Equal(expected, ComputeQuizScore(...)); 注意事項與最佳實踐: 再加入題數不符/格式錯誤測試；測試應獨立可重現；命名清晰表意。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q14, B-Q14, D-Q1

C-Q6: 如何檢測並處理「無答案卷/無試卷」？
- A簡: 入口斷言非空並在公開 API 做輸入驗證，必要時回傳明確錯誤或拋例外。
- A詳: 具體實作步驟: 1) Public API 檢查 null→throw ArgumentNullException；2) 內部再用 Assert 防呆；3) Trace 記錄呼叫方資訊。關鍵程式碼片段或設定: if(doc==null) throw new ArgumentNullException("paperDoc"); Trace.Assert(paperDoc!=null)。注意事項與最佳實踐: 區分外部錯誤（例外/訊息）與內部假設（斷言）；避免吞例外；提供修正指引。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, B-Q11, D-Q4

C-Q7: 如何驗證題目與答案選項數一致？
- A簡: 計分前比較兩者 item 數，若不符則中止並回報資料錯誤。
- A詳: 具體實作步驟: 1) 取 quizCount 與 paperCount；2) Public 層拋數據不一致例外；3) 內部層再用 Assert 保護；4) Trace 記錄題號與差異。關鍵程式碼片段或設定: if(paperCount!=quizCount) throw new InvalidOperationException("item mismatch"); Trace.Assert(paperCount==quizCount)。注意事項與最佳實踐: 在資料上線前做批次驗證；將此規則納入資料契約與 CI 檢核。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q12, D-Q3

C-Q8: 如何實作「最低得分為 0」規則？
- A簡: 總分計算後以 Math.Max(0, total) 鉗制下限，並以斷言確保不小於 0。
- A詳: 具體實作步驟: 1) 完成累計分數；2) total = Math.Max(0, total)；3) Trace 記錄原始分與調整後分數；4) Assert(total>=0)。關鍵程式碼片段或設定: total=Math.Max(0,total); Trace.WriteLine($"adj:{total}"); Trace.Assert(total>=0)。注意事項與最佳實踐: 說明規則來源；將規則參數化；於單元測試覆蓋全錯案例。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, C-Q5, D-Q1

C-Q9: 如何重構檢查碼以提高可讀性（Guard + Assert）？
- A簡: 以 Guard 條款處理外部輸入，再以 Assert 固定內部假設，主流程保持乾淨。
- A詳: 具體實作步驟: 1) 開頭 Guard 檢查參數→拋明確例外；2) 隨後用 Assert 標注假設；3) 主邏輯集中業務；4) 於關鍵點 Trace。關鍵程式碼片段或設定: if(arg==null) throw new ArgumentNullException(); Trace.Assert(stateOK)。注意事項與最佳實踐: 避免巢狀 if；命名傳遞意圖；把重覆檢查抽成輔助方法或屬性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q9, B-Q11

C-Q10: 如何建立 BUG 再現清單與回歸測試套件？
- A簡: 每發現一個缺陷，先寫能重現的測試，再修復並納入回歸組，避免舊問題回流。
- A詳: 具體實作步驟: 1) 最小化重現輸入（XML）與步驟；2) 撰寫單元測試重現失敗；3) 修正程式；4) 測試變綠並加入回歸；5) 加入斷言/Trace 提升可觀測。關鍵程式碼片段或設定: [Fact] public void NegativeScore_ShouldClampToZero(){...}。注意事項與最佳實踐: 測試命名含行為；資料版本化；CI 自動執行。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q14, B-Q14, D-Q9

---

### Q&A 類別 D: 問題解決類（10題）

D-Q1: 遇到總分變成負數怎麼辦？
- A簡: 症狀為全錯時出現負分；加下限鉗制並用斷言保護，增列對應回歸測試。
- A詳: 問題症狀描述: 全錯或多錯累計出現負分。可能原因分析: 未設下限規則、單題計分未鉗制。解決步驟: 1) 總分 Math.Max(0,total)；2) 於方法尾端 Assert(total>=0)；3) 加入全錯測試；4) Trace 記錄調整。預防措施: 規則參數化、邊界測試常態化、代碼審查關注數值邏輯。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, C-Q8, C-Q5

D-Q2: 空白答案仍被加分怎麼辦？
- A簡: 症狀為未作答仍得分；加入放棄判斷並早退，增列空白用例測試與 Trace 記錄。
- A詳: 問題症狀描述: 題目未選任何項目卻得到分數。可能原因分析: 未檢測 checked='true' 計數為 0。解決步驟: 1) 若為 0 直接回 0 分；2) Trace 記錄放棄；3) 單元測試覆蓋。預防措施: 在入口以斷言/驗證保護資料契約，審查清單納入「空集合/空白輸入」。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q3, C-Q5, C-Q2

D-Q3: 題目與答案選項數不同如何處理？
- A簡: 症狀為索引或邏輯錯亂；以斷言/驗證攔截，回報資料錯誤並修正源頭。
- A詳: 問題症狀描述: 比對時拋例外或錯算。可能原因分析: XML 結構不一致、資料產製流程瑕疵。解決步驟: 1) 計分前驗證一致；2) 不一致則中止並提示；3) 追溯資料管線修正；4) 加回歸測試。預防措施: 上線前批次驗證、在 CI 加入 XSD 與一致性檢查。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, C-Q7, B-Q12

D-Q4: 缺少答案卷或試卷時怎麼辦？
- A簡: 症狀為 null 參數或檔案缺失；公開 API 驗證並拋明確例外，內部用斷言保護。
- A詳: 問題症狀描述: NullReference 或自訂例外。可能原因分析: 呼叫端未提供文件、路徑錯誤。解決步驟: 1) Public 層 if(null) throw ArgumentNullException；2) 內部 Assert 非空；3) Trace 呼叫端資訊。預防措施: 介面契約文件化、呼叫樣板、在邊界加防呆與記錄。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, C-Q6, B-Q11

D-Q5: int.Parse 失敗（FormatException）如何處理？
- A簡: 症狀為分數屬性格式錯誤；先驗證數值或用 TryParse，回報資料錯誤並記錄來源。
- A詳: 問題症狀描述: 解析 score 屬性時拋 FormatException。可能原因分析: XML 中 score 非整數或缺失。解決步驟: 1) 使用 int.TryParse 安全解析；2) 無效則回報資料錯誤或使用預設策略；3) Trace 記錄原始值。預防措施: 資料契約定義型別；資料產製流程驗證；加入異常值測試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q12, C-Q7, C-Q10

D-Q6: XML 節點存取拋 NullReference 時如何診斷？
- A簡: 症狀為節點/屬性不存在；以斷言檢查存在性，加入保護性存取與清楚錯誤訊息。
- A詳: 問題症狀描述: SelectNodes/SelectSingleNode 結果為 null 仍取用。可能原因分析: XPath 錯誤、資料缺項。解決步驟: 1) 檢查 XPath 與命名空間；2) 斷言節點存在；3) 對外報資料不完整錯誤；4) Trace 詳細路徑與值。預防措施: 單元測試含缺節點案例；上線前資料驗證。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, C-Q7, B-Q11

D-Q7: 大量檢查導致效能下降怎麼辦？
- A簡: 症狀為 Debug 慢、Release 尚可；將檢查轉為斷言與可配置 Trace，精簡熱路徑。
- A詳: 問題症狀描述: 加入多重 if/日誌後效能顯著下滑。可能原因分析: 同步 I/O、重覆檢查、熱路徑字串建構。解決步驟: 1) 把內部檢查改用 Assert；2) Trace 設等級與非同步；3) 合併/消除重覆檢查；4) 度量前後性能。預防措施: 規劃觀測點；以開關控管密度；建立效能基準。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q9, C-Q4

D-Q8: 為何 Release 看不到 Trace 輸出？怎麼辦？
- A簡: 可能未配置 Listener/等級或條件符號；調整組態/符號，使關鍵訊息可輸出。
- A詳: 問題症狀描述: 正式環境無任何 Trace 記錄。可能原因分析: 未設定 system.diagnostics、過濾等級過高、未部署組態、未定義 TRACE。解決步驟: 1) 檢查 app.config 的 listeners/switches；2) 調整等級到 Warning/Error；3) 確認部署檔；4) 必要時定義符號。預防措施: 發佈前驗證輸出；以健康檢查訊息確認生效。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q7, C-Q4

D-Q9: Debug/Release 行為不一致如何診斷？
- A簡: 症狀為兩模式結果不同；比對條件編譯、最佳化與組態差異，增加 Trace/斷言鎖定。
- A詳: 問題症狀描述: Debug 正常、Release 出錯或相反。可能原因分析: 條件編譯導致邏輯差異、最佳化影響時序、組態不同。解決步驟: 1) 比對定義符號與組態；2) 在 Release 增加關鍵 Trace；3) 暫停最佳化重現；4) 最終修正邏輯。預防措施: 兩模式皆跑測試；重要檢查在 Release 保留。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q8, C-Q4, C-Q10

D-Q10: 如何預防「看不到的錯誤」長期潛伏？
- A簡: 以 fail-fast 斷言、關鍵 Trace、全面邊界測試與回歸套件，讓錯誤必定可見。
- A詳: 問題症狀描述: 錯誤偶發、難重現、長期未被發現。可能原因分析: 無觀測、缺邊界測試、錯誤被吞。解決步驟: 1) 關鍵假設用 Assert；2) 加 Trace 記錄脈絡；3) 建立邊界與對立測試（滿分/全錯/空白）；4) 納入回歸。預防措施: 規劃觀測策略；代碼審查關注可觀測性；CI 中必跑測試。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q5, B-Q10, C-Q10

---

### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是軟體工程師？與 programmer 有何差異？
    - A-Q2: 什麼是「程式可靠性」？
    - A-Q3: 為什麼軟體工程師需要特別重視可靠性？
    - A-Q4: 專業程式與業餘程式有何差異？
    - A-Q5: 什麼是「讓問題浮現」？
    - A-Q6: Debug 模式與 Release 模式差異是什麼？
    - A-Q7: 什麼是 Trace？何時使用？
    - A-Q8: 什麼是 Assert（斷言）？核心價值為何？
    - B-Q1: 範例的計分流程如何運作？
    - B-Q2: 為何會出現「負分」問題？修正原理是什麼？
    - B-Q3: 「放棄不計分」的檢測流程是什麼？
    - C-Q1: 如何以 C# 實作計分核心（ComputeQuizScore/Question）？
    - C-Q2: 如何用 Trace.Assert 為計分流程加防護？
    - C-Q8: 如何實作「最低得分為 0」規則？
    - D-Q1: 遇到總分變成負數怎麼辦？

- 中級者：建議學習哪 20 題
    - A-Q9: 為什麼不把所有檢查都寫進主流程？
    - A-Q10: 什麼是防呆與防禦性設計？
    - A-Q11: 輸入驗證與斷言有何差異？
    - A-Q12: 為何要同時維護 Debug 與 Release 兩種版本？
    - A-Q13: .NET 中 Trace/Assert 與設定檔的關係？
    - A-Q14: 單元測試與 Trace/Assert 的關係？
    - B-Q4: 題目與答案選項數不一致如何檢測與處置？
    - B-Q5: .NET 中 Trace/Assert 背後的機制是什麼？
    - B-Q6: 如何用斷言實作前置條件與後置條件？
    - B-Q7: Trace 訊息如何從程式流向 Visual Studio Output 或檔案？
    - B-Q8: Debug/Release 與條件編譯、設定檔如何共同影響行為？
    - B-Q9: 為什麼斷言能同時提升可維護性與效能？
    - B-Q10: 如何用斷言實踐 fail-fast 策略？
    - B-Q11: 斷言與例外處理在職責上如何分工？
    - C-Q3: 如何以 App.config 啟用 Trace Listener 輸出到 VS/檔案？
    - C-Q4: 如何在 Release 保留必要 Trace 並控管成本？
    - C-Q5: 如何撰寫單元測試覆蓋三種答案卷（滿分/空白/全錯）？
    - C-Q6: 如何檢測並處理「無答案卷/無試卷」？
    - C-Q7: 如何驗證題目與答案選項數一致？
    - D-Q2: 空白答案仍被加分怎麼辦？

- 高級者：建議關注哪 15 題
    - A-Q15: 在專業開發中如何表達與檢驗「假設」？
    - B-Q12: 如何用資料結構與契約降低邏輯錯誤？
    - B-Q13: 如何整合演算法、工具與資源達到最佳化？
    - B-Q14: 專家如何系統性地找出未知 BUG？
    - B-Q15: 為何「警告標示」比「派警衛」更務實？
    - C-Q9: 如何重構檢查碼以提高可讀性（Guard + Assert）？
    - C-Q10: 如何建立 BUG 再現清單與回歸測試套件？
    - D-Q3: 題目與答案選項數不同如何處理？
    - D-Q4: 缺少答案卷或試卷時怎麼辦？
    - D-Q5: int.Parse 失敗（FormatException）如何處理？
    - D-Q6: XML 節點存取拋 NullReference 時如何診斷？
    - D-Q7: 大量檢查導致效能下降怎麼辦？
    - D-Q8: 為何 Release 看不到 Trace 輸出？怎麼辦？
    - D-Q9: Debug/Release 行為不一致如何診斷？
    - D-Q10: 如何預防「看不到的錯誤」長期潛伏？