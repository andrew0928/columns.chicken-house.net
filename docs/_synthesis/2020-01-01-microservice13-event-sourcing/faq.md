---
layout: synthesis
title: "微服務架構設計 - Event Sourcing"
synthesis_type: faq
source_post: /2020/01/01/microservice13-event-sourcing/
redirect_from:
  - /2020/01/01/microservice13-event-sourcing/faq/
---

# 微服務架構設計 - Event Sourcing

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

Q1: 什麼是 Event Sourcing？
- A簡: 以事件為唯一真實資料來源，保存每次變更，並可重播還原任一時點狀態。
- A詳: Event Sourcing 是一種資料持久化模式，不儲存最終狀態，而是持續追加記錄造成狀態改變的事件。每個事件具時間序與不可變性，可被重播以重建聚合的當前或歷史狀態。此法天生具審計追溯力，適合交易、合規與需要重建計算的場景，常與 CQRS、消息佇列與投影視圖搭配使用。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q8, B-Q1

Q2: Event Sourcing 的核心理念是什麼？
- A簡: 儲存改變而非結果；事件追加不可變，完整時間序即可重建任何狀態。
- A詳: 核心理念是把「狀態如何成為現在」的過程視為一級公民：每次狀態變更都序列化為事件並按時間順序追加寫入。因為事件不可更改且完整保留，你可在任意時間點重播事件以得到目標聚合的狀態，或並行生成不同的讀取視圖。這將 CRUD 簡化為以追加為主的 CR，刪除僅做封存。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q3

Q3: Event Sourcing 與傳統 CRUD 的差異？
- A簡: CRUD更新最終狀態；Event Sourcing只追加事件，讀側以投影得狀態。
- A詳: 傳統 CRUD 模式以資料表存放當前狀態，透過 UPDATE/DELETE 改動。Event Sourcing 則只追加事件，不修改已寫入的歷史。寫側以命令產生事件，讀側以投影將事件轉為適合查詢的素材化視圖。這改變一致性與伸縮特性：寫入順序化、查詢快取化，並以最終一致性取代強鎖。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, B-Q4

Q4: Event Sourcing 與一般 Log 的差異？
- A簡: 事件是系統真相來源可重播；Log多為旁路紀錄，無語義與重播保證。
- A詳: 事件記錄承擔系統的來源資料角色，具明確領域語義、不可變與可重播性，可直接用於重建狀態。一般系統 Log 則偏向診斷與稽核用途，內容常非結構化、可能缺欄或無順序與一致性保證，難以作為演算依據。Event Sourcing 要求事件設計、版本控管與持久化保證，與單純寫 Log 本質不同。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q5, B-Q2

Q5: 為什麼需要 Event Sourcing？
- A簡: 為審計追溯、重建計算、解耦讀寫、提升伸縮與雲原生處理。
- A詳: 採用 Event Sourcing 的動機包含：完整審計與合規（保存每次變更）、允許錯誤修正後重算（追加補差）、支援多種讀取模型（CQRS 投影）、提升寫入吞吐（順序追加）與擴展性（事件驅動解耦）。在雲原生場景，配合消息佇列與流式處理，可就地計算並預先生成各種視圖，縮減查詢時的 Join 成本。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q6, A-Q16, B-Q8

Q6: Event Sourcing 的核心價值是什麼？
- A簡: 以時間為維度的真相保存、可重播可校正、支援多視圖與最終一致。
- A詳: 核心價值在於：一、時間序真相可被驗證與追溯，天然具審核力；二、重播能力讓你在發現規則錯誤時可修正並重建結果（例如補差事件）；三、藉事件驅動的投影，能為不同需求產生多種讀模型而不互相牽制；四、配合雲原生基礎設施，取得高吞吐與線性擴展，接受最終一致以換取彈性。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q2, B-Q8

Q7: Event Sourcing 的缺點或成本是什麼？
- A簡: 存儲與計算成本高、設計複雜度大、開發維運門檻與治理要求高。
- A詳: 缺點包括：事件無限追加需大量儲存與生命週期管理；投影與重播耗費計算；一致性轉為最終一致，需處理延遲與用戶預期；事件模式演進與相容性管理複雜；開發需理解 DDD、CQRS、消息中介等，團隊門檻高。若僅追求最終結果、無審計與重播需求，傳統 CRUD 或快取化也許更務實。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q11

Q8: Event Sourcing 與 CQRS 的關係是什麼？
- A簡: ES關注如何寫；CQRS分離寫讀。兩者常結合：事件驅動投影形成讀側。
- A詳: Event Sourcing 定義寫側的持久化策略：以事件做唯一真相。CQRS 將命令（寫入）與查詢（讀取）分離，允許讀側依需求建不同結構。兩者結合時，命令產生事件寫入事件庫，讀側訂閱事件，透過流式處理建立素材化視圖以供查詢。這樣的架構能同時兼顧寫入順序與讀取效率。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q1, A-Q9, B-Q4

Q9: 什麼是 CQRS（命令與查詢責任分離）？
- A簡: 命令與查詢責任分離，使寫入與讀取各自最佳化並獨立擴展。
- A詳: CQRS（Command and Query Responsibility Segregation）將系統拆分為命令模型與查詢模型。命令模型處理變更請求與規則驗證；查詢模型專注於高效讀取，可針對使用場景設計資料表或索引。兩側透過事件、消息或同步機制保持最終一致，能夠在雲原生架構中分別擴展、調整儲存與效能策略。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, B-Q4

Q10: 為何在 Event Sourcing 中常用 CQRS？
- A簡: 事件不利即時聚合，需投影成讀視圖；CQRS提供獨立讀側最佳化。
- A詳: 事件流是追加式紀錄，直接查詢最新聚合往往需重播，代價高。CQRS 讓讀側獨立，透過投影器即時消費事件並更新素材化視圖，如餘額表、排行榜、報表快取。如此查詢變為 O(1) 的鍵值讀取，避免昂貴 Join 或重播，同時不影響寫側的順序與一致性處理。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q8

Q11: 什麼是流式資料處理（Streaming）？
- A簡: 持續消費事件流，邊到邊算，生成即時投影或觸發後續行為。
- A詳: 流式處理指對無限事件序列進行連續計算。消費者從消息佇列或事件庫讀取事件，依序執行轉換、聚合、濾波等，然後寫入讀模型或觸發下游。相較批次，流式處理延遲更低、可按事件時間處理校正，並可水平擴展以處理高吞吐。它與 Event Sourcing、CQRS 天然契合。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q7, C-Q3

Q12: 什麼是 Cloud Native（雲原生）？
- A簡: 以雲為假設的軟體哲學：容錯、自動化、彈性伸縮與服務化設計。
- A詳: Cloud Native 認為硬體故障是常態，可靠性需由軟體吸收。透過容器、編排、健康檢查、服務發現、不可變部署等，使系統可自癒並水平擴張。資料處理強調把運算移向資料端、以消息驅動解耦，接受最終一致換取吞吐與可擴性。微服務與事件溯源正是其中常見的設計模式。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q13, A-Q14

Q13: Cloud Native 與微服務的關係是什麼？
- A簡: 同一哲學的兩面：雲原生基礎，微服務聚焦服務邊界與切割。
- A詳: 兩者並非孰先孰後。雲原生提供容器化、編排與彈性基座；微服務則關注按領域切割服務與邊界，讓每個服務獨立部署與擴展。在大規模場景中，事件驅動、消息佇列、CQRS 等雲原生實踐支撐微服務間協作，微服務又讓事件流的責任邊界更清晰。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q12

Q14: Cloud Native 與傳統企業式架構有何差異？
- A簡: 傳統靠昂貴硬體與強一致；雲原生靠軟體容錯、水平擴展與最終一致。
- A詳: 傳統三層式常以大型資料庫與高可用硬體提供穩定性，開發者假設平台可靠。雲原生假設大量節點下故障必然發生，轉而在軟體設計上容錯，透過多副本、重試、消息化與冪等保障可靠。資料處理策略由「把資料搬到運算」轉為「把運算送到資料」，提升可擴性與成本效益。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q9, B-Q10

Q15: 強一致性與最終一致性有何差異？
- A簡: 強一致即刻一致且需鎖；最終一致允許延遲，透過重試與冪等收斂。
- A詳: 強一致性要求所有副本在操作完成時觀測到相同狀態，常用鎖與分散式共識，代價是延遲與擴展性。最終一致性允許在短期內觀察到不同狀態，但保證透過重試、順序與冪等，最終收斂到一致結果。Event Sourcing/CQRS 多採最終一致，以提升吞吐與隔離寫讀負載。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q11, D-Q2

Q16: Event Sourcing 適合的場景？
- A簡: 高審計需求、可重算、複雜領域規則、多視圖查詢與事件驅動協作。
- A詳: 典型場景包括金融交易、訂單與帳務、合規與稽核、需要追蹤歷程與回放的系統、需要對同一資料集建立多種讀模型（即時儀表板、報表、搜尋）、跨服務以事件協作（SAGA）。當更正規則或回溯計算成為常態時，Event Sourcing 可顯著簡化重建邏輯。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, C-Q8

Q17: Event Sourcing 不適合的場景？
- A簡: 單純CRUD、小規模無審計、固定單一查詢、不願維運事件管線。
- A詳: 若業務只需最終值、資料量小、無追溯或重算需求，或團隊缺乏事件管線維運能力，採 ES 會過度設計。大量需要即席聚合且不願維護投影，或嚴格要求跨寫讀強一致的同步事務，亦不適合。此時可用傳統 CRUD 加上快取、資料倉儲或批次 ETL 更為務實。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q7

Q18: 什麼是事件時間與到達時間？為何重要？
- A簡: 事件時間指發生時刻；到達時間指收錄時刻。處理須區分以支援校正。
- A詳: 事件時間（event time）是業務真實發生點，如消費時刻；到達時間（ingestion/processing time）是系統接收或處理的時間。兩者分離能在流式處理中對延遲資料進行回填與重算，支撐「校正回歸」。配合窗口與最大延遲策略（關帳），可同時提供即時視圖與準確歷史統計。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q8, C-Q9, D-Q8

### Q&A 類別 B: 技術原理類

Q1: Event Store（事件庫）如何運作？
- A簡: 以追加為主的事件流存儲，按聚合分流，提供順序讀寫與重播。
- A詳: Event Store 是追加式存儲，常以聚合ID分成獨立流。寫入流程：命令驗證→產生事件→追加至事件流（含版本號）→發布到消息佇列。讀取流程：按聚合順序讀事件以重建狀態或供投影消費。核心組件含：事件流、快照、版本控制與併發檢測、事件發布器、持久化後端（KV/Log/DB）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q1, A-Q3

Q2: 事件重播（Replay）的機制與流程是什麼？
- A簡: 從事件庫按序讀取，重放至投影或聚合，生成目標狀態或視圖。
- A詳: 重播原理是利用事件不可變與全序。流程：選定範圍（全量或特定聚合/時間窗）→按序讀事件→將事件套用到聚合或投影處理器→持久化新狀態/視圖→更新偏移量。關鍵步驟含去重與冪等、事件版本升級（upcasting）、節流控制。核心組件有重播器、偏移量存儲、快照加速。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, C-Q6

Q3: 聚合根與事件溯源如何設計（DDD）？
- A簡: 以DDD界定聚合邊界，聚合產生命令驗證與事件應用方法。
- A詳: DDD 中聚合根負責一致性邊界。設計時先建模不變式，命令在聚合內驗證後產生領域事件；重建聚合時透過 apply 方法按序套用事件恢復狀態。關鍵步驟：選對聚合粒度避免跨聚合事務、為事件命名承載語義、加入版本與來源、建立快照以加速重建。核心組件：聚合、命令處理器、事件型別。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q9

Q4: CQRS 的資料流與技術架構如何設計？
- A簡: 寫側命令→事件庫；讀側訂閱事件→投影→素材化視圖供查詢。
- A詳: 寫側由 API/命令處理器驗證後產生事件，追加至事件庫並發布到 MQ。讀側一或多個投影器訂閱事件，執行轉換與聚合，更新讀庫（如KV、搜尋引擎、列式庫）。關鍵步驟：維護偏移量、確保投影冪等、處理事件時間與窗口。核心組件：命令模型、事件庫、消息佇列、投影器、讀庫。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q9, C-Q3

Q5: 寫讀同步的機制與一致性如何保障？
- A簡: 以消息佇列串聯，讀側最終一致；靠偏移量、重試、冪等收斂。
- A詳: 寫入完成即產生事件並提交；讀側非同步消費事件更新視圖，期間存在暫時不一致。為保證收斂：一、消息至少一次投遞；二、投影冪等與去重；三、維護每投影偏移量；四、提供讀寫分離的 API 合約與用戶預期管理。可用快照/版本號避免覆寫新值，或提供讀模型延遲指標。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q11

Q6: 使用消息佇列序列化事件的原理是什麼？
- A簡: 利用分區與鍵保持同聚合順序，持久化與重試確保至少一次投遞。
- A詳: 佇列如 Kafka/Azure Service Bus 透過分區確保相同鍵（聚合ID）在同一分區以單序寫入。事件寫入後持久化到 log 並複製，消費者以偏移量拉取，發生錯誤可重試。為避免亂序與重複，需選擇合適鍵、限制跨聚合順序假設，並在消費端實作去重與冪等處理。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q5, D-Q1

Q7: 流式處理（Streaming）的執行流程為何？
- A簡: 來源→解析→轉換/聚合→窗口/校正→寫入投影→提交偏移量。
- A詳: 流式處理流程：1) 連接來源（事件庫/MQ）；2) 解析事件並做模式升級；3) 執行轉換/累加/分組；4) 以事件時間定義窗口與允許延遲，實現校正回歸；5) 將結果寫入讀庫；6) 提交偏移量保證至少一次處理。核心組件：Source、Processor、StateStore、Sink、Offset Store。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, C-Q3

Q8: 建立 Aggregation View（投影）的原理是什麼？
- A簡: 將事件轉為素材化視圖，預計算常用查詢，以O(1)鍵值存取。
- A詳: 聚合視圖把昂貴的 Join 或重播前移到寫時。投影器消費事件，更新計數器、餘額、排行榜等，結果存於快取或 NoSQL，以鍵值快速查詢。關鍵步驟：確定鍵設計、維持冪等更新、處理延遲回填與撤銷事件。核心組件：投影器、讀庫、索引。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, C-Q3

Q9: 雲原生下的可靠性設計包含哪些要素？
- A簡: 軟體容錯：多副本、自動化恢復、健康檢查、重試與冪等。
- A詳: 在大規模下硬體故障常態，設計需：1) 多副本存儲與跨節點複製；2) 健康檢查與自動重啟/遷移；3) 不可變部署與滾動升級；4) 消息化解耦並允許重送；5) 端到端冪等與順序策略；6) 度量與追蹤。核心組件：容器/編排、服務發現、消息系統、狀態存儲與觀測性。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q12, A-Q14

Q10: MapReduce 與「將運算送到資料」有何差異意義？
- A簡: 傳統把資料搬到CPU；MapReduce把計算下沉至資料節點以減少I/O。
- A詳: 傳統資料庫在少數伺服器聚合集中運算，I/O 往返成瓶頸。MapReduce 與雲原生思維將小段計算送至分布資料節點，就地掃描並匯總，減少跨網傳輸與提升平行度。對應到 ES/CQRS，即在事件到達時就計算投影，把查詢成本從 O(log n) 降為 O(1)，換取寫時成本與最終一致。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, A-Q14

Q11: 最終一致性在 ES/CQRS 下如何被保證？
- A簡: 至少一次投遞+冪等處理+順序鍵+重試與補償=可收斂的一致。
- A詳: 關鍵機制：消息至少一次遞送，配合消費端冪等（如事件ID去重）；對同一聚合用鍵保順序；失敗時以重試/死信隊列處理；必要時以補償事件（或 SAGA）撤銷影響；維護偏移量檢查點避免遺失。這些構件讓系統在無全局鎖/共識下，最終收斂到一致狀態。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q15, D-Q9

Q12: Event Sourcing 與 SAGA 如何協作處理分散式交易？
- A簡: 跨服務以事件編排本地事務與補償；ES提供可靠事件與重播。
- A詳: SAGA 將跨服務交易拆成一系列本地事務與對應補償，透過事件編排（編排者或編舞）推進流程。Event Sourcing 提供可靠的事件持久化、順序與回放能力，遇錯可發布補償事件回滾影響。關鍵步驟：定義狀態機、設計不可變事件、處理冪等與去重、追蹤關聯ID。核心組件：事件庫、MQ、SAGA協調器。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q5, D-Q5

### Q&A 類別 C: 實作應用類

Q1: 如何在 .NET 建立簡易事件存儲（Event Store）？
- A簡: 以聚合ID分流鍵值存儲，順序追加事件並以版本號檢查併發。
- A詳: 具體步驟：1) 定義 IEvent{Id,AggregateId,Version,EventTime,Payload}；2) 以 AggregateId 為鍵，Version 單調遞增；3) Append 前比對 expectedVersion；4) 成功後發佈至 MQ。程式碼：AppendAsync(aggregateId, expectedVersion, events)。注意：事件不可變、批次寫入、使用 AppendOnly/WAL 寫盤，維護索引以加速聚合回放。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q1, B-Q3

Q2: 如何實作 CQRS 命令處理與事件發布（.NET/MediatR）？
- A簡: 命令驗證→載入聚合→執行→產生事件→保存→發佈（Outbox保一致）。
- A詳: 步驟：1) 定義 Command 與 Handler；2) 從事件庫重建聚合；3) 聚合.Handle(cmd) 產生事件；4) EventStore.Append + Outbox 記錄；5) 背景服務發布至 MQ。碼片段：var evts=agg.Handle(cmd); store.Append(id,ver,evts); outbox.Save(evts)。注意：命令幂等（去重鍵）、Outbox 防止「寫庫成功但未發布」的不一致。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q4

Q3: 如何建立投影器（Projection）同步讀模型？
- A簡: 背景服務訂閱事件，冪等更新讀庫，維護偏移量以確保至少一次。
- A詳: 步驟：1) 訂閱 MQ/事件庫；2) Upcast→轉換；3) Upsert 讀庫；4) 提交偏移量。碼片段：Upsert(key, s=>s.Balance+=evt.Amount); offsets.Save(partition, pos)。注意：冪等更新（事件ID去重）、偏移量原子提交、處理撤銷/補償事件與事件時間窗口，避免舊事件覆寫新值。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q8

Q4: 如何設計事件模式（Schema）與版本演進？
- A簡: 事件含版本欄位；以新增欄位為主，舊事件用Upcaster轉新版本。
- A詳: 步驟：1) 事件命名用過去式，包含 Id/Version/EventTime/Source；2) 演進優先向後相容（加欄位、預設值）；3) 建 Upcaster：BankAccountCreditedV1→V2{Currency}；4) 在投影與聚合重建階段統一新版本。碼片段：Upcast(v1)=>new V2{...Currency="TWD"}。注意：避免破壞性變更，保留模式歷史與測試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q4, B-Q2

Q5: 如何設定消息佇列（以 Kafka 為例）以保障順序與可靠？
- A簡: 以聚合ID為鍵分區；啟用ACK=all與Idempotent Producer，配置保留策略。
- A詳: 步驟：1) 建立主題 account-events；2) 分區數量依吞吐；3) Producer 設置 acks=all、enable.idempotence=true；4) Consumer 群組維護偏移量。命令：kafka-topics --create --partitions 12 --replication-factor 3。注意：確保相同聚合鍵路由一致、設定保留/壓縮策略、監控滯後與死信。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q7

Q6: 如何實作事件重播與重建聚合視圖？
- A簡: 提供按時間窗/聚合的重播工具，隔離新表重建後切換別名上線。
- A詳: 步驟：1) 指定範圍（from/to 或 aggregateId）；2) 暫停投影寫入或改寫到新表；3) 將偏移量設為起點，逐事件套用；4) 完成後原子切換讀表別名。程式：SetOffset(projection, t0); Rebuild().注意：重播期間讀一致性、冪等處理、速率限制與回滾策略，避免影響線上查詢。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q2, D-Q3

Q7: 如何設計幂等（Idempotency）與去重機制？
- A簡: 事件攜帶唯一EventId，投影端維護Processed表，更新採Upsert語義。
- A詳: 步驟：1) 事件含 EventId；2) 投影器處理前查 Seen(EventId)；3) 更新與標記同交易完成；4) 跨服務傳遞去重鍵。碼片段：if(!Seen(evt.Id)){Apply(); MarkSeen(evt.Id);} 注意：避免以時間戳為鍵、用 UPSERT/SET 類操作、對外API重放要安全、配合Outbox/Inbox模式。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q11, D-Q3

Q8: 如何設計「校正回歸」的回填流程？
- A簡: 使用事件時間與允許延遲窗口，對受影響窗口重算並發佈修正通知。
- A詳: 步驟：1) 事件含 EventTime；2) 設定允許延遲如 P3D；3) 遇舊事件則重算該日/窗聚合；4) 記錄修正版次與來源；5) 發送修正事件/通知。碼片段：if(now-evt.EventTime<window){recompute(day)}。注意：API 回傳 lag 與 revision、審計留痕、避免過窗直接改舊期（轉為調整事件）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, D-Q8

Q9: 如何定義最大延遲與關帳（Closing）流程？
- A簡: 設關帳窗口，過窗事件不改舊期而以當期調整，保證財務一致。
- A詳: 步驟：1) 設 CloseAfter=P5D；2) 投影器對過窗事件產生 AdjustEvent 追加至當期；3) 關帳時鎖定舊期不可再改；4) 例外走人工工作流。碼片段：if(evt.EventTime<closeDate){emit AdjustEvent}。注意：關帳策略可配置、記錄關帳戳記、對報表與接口標示是否已關帳。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, D-Q8

Q10: 如何設計查詢 API 以同時服務即時與歷史視圖？
- A簡: 提供/rt與/history端點，讀不同投影，回傳延遲與版本欄位。
- A詳: 步驟：1) /rt 讀即時投影表，/history 讀分區化/列式庫；2) 查詢參數支持 store/date 等；3) 回應含 lastUpdated、lagMs、revision。範例：GET /sales/rt?store=001；GET /sales/history?date=2021-05-20。注意：文件說明最終一致、提供訂閱修正通知或ETag以便客戶端更新。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q10, D-Q2

### Q&A 類別 D: 問題解決類

Q1: 遇到事件亂序導致餘額錯誤怎麼辦？
- A簡: 症狀為讀值跳動或負值；調整分區鍵、消費端排序與冪等去重解決。
- A詳: 問題症狀：同一帳戶餘額短暫錯誤、負值或回退。可能原因：路由鍵不穩致跨分區無序、消費者併發處理打亂序、重送未去重。解決步驟：以聚合ID為鍵保序；單分區內單執行緒處理；投影端按版本檢查、丟棄過時事件。預防：啟用Idempotent Producer、限制跨聚合順序假設、建立去重表。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q6, C-Q5

Q2: 查詢到的即時視圖不一致，如何處理與告知用戶？
- A簡: 症狀為寫後讀不到；提供延遲指標、讀寫分離合約與重試策略。
- A詳: 症狀：剛下單查詢未反映。原因：讀側最終一致尚未消費事件。解法：回應含 lastUpdated/lag；提供「寫後讀一致」選項（等待偏移量達成或讀補充快取）；對重要操作提供指引重試。預防：優化投影吞吐、監控滯後、針對關鍵場景以查詢合併寫側快取。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q5

Q3: 事件重播造成重複處理與數據加倍，如何解決？
- A簡: 症狀為統計翻倍；以事件ID去重、投影冪等與偏移量控制修復。
- A詳: 症狀：重播後計數翻倍。原因：投影非冪等、缺乏去重。解法：引入 ProcessedEvents（EventId 索引）判斷是否處理過；更新採 Upsert/Set；重播前清空讀表或改寫至新表後切換。預防：Outbox/Inbox 模式、對每投影維護偏移量、回歸測試驗證重播路徑。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q2, C-Q7

Q4: 事件存儲暴增、成本攀升，怎麼辦？
- A簡: 症狀為磁碟壓力；採壓縮/封存、快照、層級儲存與保留策略。
- A詳: 症狀：磁碟使用率長期高、查詢變慢。原因：事件無限追加、冷資料大量堆積。解法：啟用壓縮/壓實（compaction）；定期快照與截斷舊事件；冷熱分層存儲（S3/歸檔）；設定保留期限。預防：事件顆粒度合理化、定期容量規劃、建立封存與回復演練。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q7, C-Q1

Q5: 跨服務交易一致性差，該如何處理？
- A簡: 症狀為部分成功；以SAGA拆本地事務與補償，事件驅動協調。
- A詳: 症狀：多服務參與時部分步驟成功導致不一致。原因：缺乏分散式事務。解法：採 SAGA 設計狀態機，定義每步本地事務與補償；用事件推進流程；失敗則發補償事件。預防：冪等處理、關聯ID追蹤、時序圖測試、超時與死信策略，避免 2PC 帶來的耦合與延遲。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q12, A-Q15

Q6: 事件模式演進導致相容性問題，怎麼辦？
- A簡: 症狀為解析錯誤；用版本欄位+Upcaster，避免破壞性變更。
- A詳: 症狀：新投影無法讀舊事件、欄位缺失。原因：破壞性變更。解法：加入 schemaVersion；為舊事件提供 Upcaster 昇版；投影與聚合優先支援新版本。預防：只做向後相容變更、事件不可重命名、灰度發布與雙讀雙寫驗證、引入合約測試。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: C-Q4, B-Q2

Q7: 熱點聚合（單帳戶高頻）成為瓶頸，如何緩解？
- A簡: 症狀為單鍵流量過高；以分片、限流、快照與批次聚合緩解。
- A詳: 症狀：單聚合延遲升高、分區背壓。原因：鍵分佈不均。解法：熱鍵分片（aggregateId+shard）、局部序列化後合併、對讀側用快照/快取；寫側適度批次化事件。預防：鍵設計前期壓力測試、限流與排隊、對熱帳戶採專用資源或單獨分區。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q8

Q8: 即時報表與延遲資料衝突（校正回歸），怎麼處理？
- A簡: 症狀為日後數字更動；區分事件/到達時間，窗口回填與關帳策略。
- A詳: 症狀：隔日或數日後報表被修正。原因：資料延遲上報。解法：投影採事件時間窗口，允許延遲內回填；過窗則發調整事件到當期；對外揭露修正版與lag。預防：定義最大延遲與關帳、流程化修正通知、即時/歷史視圖拆分，讓用戶理解語義差異。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, C-Q8, C-Q9

Q9: 消息丟失或重送導致資料不一致，如何診斷與修復？
- A簡: 症狀為漏單/重複計算；至少一次+冪等、死信重處理與重播修復。
- A詳: 症狀：某些事件未反映或被加倍。原因：網路抖動、佇列重送、消費者崩潰。解法：保證至少一次傳遞，投影冪等與去重；死信隊列人工/自動重處理；定期對讀側做校核與重播。預防：監控滯後與重送率、Outbox/Inbox 模式、健康檢查與自動重啟。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q11, C-Q5

Q10: 如何診斷整體事件流的健康狀況？
- A簡: 建立端到端觀測：延遲、滯後、吞吐、錯誤率與追蹤關聯ID。
- A詳: 症狀：用戶體感慢、數據不準。診斷：觀測投影滯後（lag）、處理延遲、佇列堆積、錯誤率；集中式追蹤以關聯ID貫穿命令→事件→投影；建立SLA與告警閾值。解決：擴容分區/消費者、調整批次與背壓、定位瓶頸。預防：容量規劃、壓測、紅綠藍部署與回滾策略。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q9, B-Q7

### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是 Event Sourcing？
    - A-Q2: Event Sourcing 的核心理念是什麼？
    - A-Q3: Event Sourcing 與傳統 CRUD 的差異？
    - A-Q4: Event Sourcing 與一般 Log 的差異？
    - A-Q5: 為什麼需要 Event Sourcing？
    - A-Q6: Event Sourcing 的核心價值是什麼？
    - A-Q9: 什麼是 CQRS（命令與查詢責任分離）？
    - A-Q10: 為何在 Event Sourcing 中常用 CQRS？
    - A-Q11: 什麼是流式資料處理（Streaming）？
    - A-Q12: 什麼是 Cloud Native（雲原生）？
    - A-Q13: Cloud Native 與微服務的關係是什麼？
    - A-Q14: Cloud Native 與傳統企業式架構有何差異？
    - A-Q15: 強一致性與最終一致性有何差異？
    - B-Q1: Event Store（事件庫）如何運作？
    - B-Q4: CQRS 的資料流與技術架構如何設計？

- 中級者：建議學習哪 20 題
    - A-Q7: Event Sourcing 的缺點或成本是什麼？
    - A-Q16: Event Sourcing 適合的場景？
    - A-Q17: Event Sourcing 不適合的場景？
    - A-Q18: 什麼是事件時間與到達時間？為何重要？
    - B-Q2: 事件重播（Replay）的機制與流程是什麼？
    - B-Q3: 聚合根與事件溯源如何設計（DDD）？
    - B-Q5: 寫讀同步的機制與一致性如何保障？
    - B-Q6: 使用消息佇列序列化事件的原理是什麼？
    - B-Q7: 流式處理（Streaming）的執行流程為何？
    - B-Q8: 建立 Aggregation View（投影）的原理是什麼？
    - B-Q11: 最終一致性在 ES/CQRS 下如何被保證？
    - C-Q1: 如何在 .NET 建立簡易事件存儲（Event Store）？
    - C-Q2: 如何實作 CQRS 命令處理與事件發布（.NET/MediatR）？
    - C-Q3: 如何建立投影器（Projection）同步讀模型？
    - C-Q4: 如何設計事件模式（Schema）與版本演進？
    - C-Q5: 如何設定消息佇列（以 Kafka 為例）以保障順序與可靠？
    - C-Q7: 如何設計幂等（Idempotency）與去重機制？
    - D-Q1: 遇到事件亂序導致餘額錯誤怎麼辦？
    - D-Q2: 查詢到的即時視圖不一致，如何處理與告知用戶？
    - D-Q3: 事件重播造成重複處理與數據加倍，如何解決？

- 高級者：建議關注哪 15 題
    - B-Q9: 雲原生下的可靠性設計包含哪些要素？
    - B-Q10: MapReduce 與「將運算送到資料」有何差異意義？
    - B-Q12: Event Sourcing 與 SAGA 如何協作處理分散式交易？
    - C-Q6: 如何實作事件重播與重建聚合視圖？
    - C-Q8: 如何設計「校正回歸」的回填流程？
    - C-Q9: 如何定義最大延遲與關帳（Closing）流程？
    - C-Q10: 如何設計查詢 API 以同時服務即時與歷史視圖？
    - D-Q4: 事件存儲暴增、成本攀升，怎麼辦？
    - D-Q5: 跨服務交易一致性差，該如何處理？
    - D-Q6: 事件模式演進導致相容性問題，怎麼辦？
    - D-Q7: 熱點聚合（單帳戶高頻）成為瓶頸，如何緩解？
    - D-Q8: 即時報表與延遲資料衝突（校正回歸），怎麼處理？
    - D-Q9: 消息丟失或重送導致資料不一致，如何診斷與修復？
    - D-Q10: 如何診斷整體事件流的健康狀況？
    - A-Q14: Cloud Native 與傳統企業式架構有何差異？