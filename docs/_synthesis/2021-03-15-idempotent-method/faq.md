---
layout: synthesis
title: "[分散式系統 #1] Idempotency Key 的原理與實作 - 能安全 Retry 的 API 設計"
synthesis_type: faq
source_post: /2021/03/15/idempotent-method/
redirect_from:
  - /2021/03/15/idempotent-method/faq/
postid: 2021-03-15-idempotent-method
---

# [分散式系統 #1] Idempotency Key 的原理與實作 - 能安全 Retry 的 API 設計

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 為什麼在分散式系統中要考慮網路不可靠性？
- A簡: 網路不可避免地丟包、重傳、超時，導致請求與回應不一致，需設計能安全重試的 API。
- A詳: 分散式系統中，網路具有不可預測性，包含延遲、封包丟失、連線中斷與重排。這使得「請求是否被執行」與「回應是否送達」可能分離，產生重複執行或未知狀態。為確保一致性與使用者體驗，API 需具備安全重試能力，能在重試時避免副作用重複，並提供可驗證的結果準確性。冪等性與 Idempotency Key 即是解法核心。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q3, A-Q4

A-Q2: 什麼是安全重試（Safe Retry）？
- A簡: 安全重試指在失敗或未知結果時，重送請求仍不造成重複副作用。
- A詳: 安全重試是將重試策略與 API 設計結合，使請求在網路不可靠或暫時性錯誤時可以重送，且伺服端能識別重複請求並返回同一結果，不重複產生副作用。它依賴冪等性、決定性回應、唯一性約束與可觀測性。常與退避抖動策略搭配，避免雪崩與放大故障，同時維持使用者操作語義的正確性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q5, B-Q10

A-Q3: 什麼是冪等（Idempotent）？
- A簡: 冪等是同一操作執行一次與多次，系統狀態與結果一致。
- A詳: 在 API 語境，冪等性指對同一語義的操作重複執行，最終狀態不變且回應一致。典型如 PUT/DELETE 為冪等，GET 為無副作用，POST 常非冪等。為使 POST 也安全重試，需引入 Idempotency Key 與結果重放。冪等降低重試風險，提升可靠性與一致性，是分散式設計的重要基石。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, A-Q9, B-Q2

A-Q4: 為什麼需要設計冪等 API？
- A簡: 為對抗網路不確定性，避免重試造成重複扣款等副作用。
- A詳: 當請求成功但回應遺失時，客戶端多半會重試。若 API 非冪等，重試等同重複執行，導致資金或狀態重覆變更。設計冪等 API 可讓伺服端識別重複請求並回傳同一結果，避免重複副作用，支援自動重試、提高容錯與用戶體驗。它亦簡化客戶端錯誤處理並減少人工對帳成本。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q5, D-Q1

A-Q5: 什麼是 Idempotency Key？
- A簡: 一個客戶端提供的唯一鍵，用於伺服端去重並重放相同回應。
- A詳: Idempotency Key 是客戶端為一次「語義操作」生成的唯一識別，通常放在 HTTP Header（如 Idempotency-Key）。伺服端以此鍵為索引，原子性地記錄第一次請求的結果，對後續相同鍵的請求直接返回相同回應，防止副作用重複。它需包含作用範圍與過期策略，並與端點與身分綁定以防濫用。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, A-Q10, A-Q11

A-Q6: Idempotency Key 與 Correlation ID/TraceID 有何差異？
- A簡: 前者防重與重放結果；後者用於追蹤與觀測，不具去重語義。
- A詳: Correlation ID/TraceID 主要用於分散式追蹤與日誌串接，幫助觀測與診斷，並不承諾操作語義。Idempotency Key 則承諾請求語義的「唯一執行」，是伺服端去重與重放決定性回應的依據。兩者可同時存在：TraceID 連結一次請求路徑，Idempotency Key 管控重試的語義一致性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, B-Q4, C-Q6

A-Q7: HTTP 方法與冪等性的差異是什麼？
- A簡: GET/PUT/DELETE 為冪等，POST 多為非冪等，需額外機制保護。
- A詳: HTTP 規範定義方法語義：GET 為安全且無副作用，PUT/DELETE 冪等，PATCH/POST 可能非冪等。實務中多數創建操作使用 POST，若需安全重試，須以 Idempotency Key、唯一性約束與結果重放來「提升」其冪等性，確保重試不會多次執行副作用。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q2, C-Q4

A-Q8: At-most-once、At-least-once、Exactly-once 的差異？
- A簡: 至多一次易丟失；至少一次會重複；精確一次近乎不可能。
- A詳: At-most-once 不重試，避免重複但可能遺失；At-least-once 會重試，確保至少一次但可能重複；Exactly-once 在分散式實務中難以保證。通常以「至少一次 + 冪等處理」達到等價的業務語義，兼顧可靠與正確性，是工程上務實選擇。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q2, A-Q3, A-Q20

A-Q9: 冪等性的核心價值是什麼？
- A簡: 以決定性結果抵抗重試與重放，保障一致性與用戶信任。
- A詳: 核心價值在於把不可靠通訊包裝為可靠語義：同一操作多次嘗試，不改變最終狀態，並返回相同結果。它降低對強一致交易的依賴，提升系統可用性與故障自癒能力，減輕人工對帳、客服成本，並使自動化重試成為可能。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, B-Q2, D-Q1

A-Q10: Idempotency Key 的作用範圍（Scope）是什麼？
- A簡: 通常綁定端點、操作者與請求語義，避免跨情境衝突。
- A詳: 一個健全的 Scope 常包含 API 路徑或動作、租戶/用戶身分、關鍵參數摘要（Hash）與時間窗。如此可避免不同操作共用同鍵造成誤用，也能抵禦重放與撞鍵。伺服端應以這些維度組合形成唯一鍵空間，並保存首個回應以重放。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, C-Q6, D-Q2

A-Q11: 為何 Idempotency Key 需要有效期（TTL）？
- A簡: 限制儲存成本與重放窗，降低重放攻擊與狀態污染。
- A詳: TTL 使伺服端只在合理時間窗內承諾重放結果，超時則需重新請求或取得操作狀態。這平衡儲存成本與安全性，避免資料無限堆積與被長期重放攻擊濫用。TTL 應依業務風險與客訴成本調整，並提供查詢狀態接口。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, D-Q7, C-Q2

A-Q12: 冪等與資料庫交易（Transaction）有何不同？
- A簡: 交易保護單次執行原子一致；冪等保護多次嘗試語義一致。
- A詳: 交易解決一次執行內的原子性與隔離性問題；冪等針對跨次嘗試與網路不可靠下的重試去重。兩者互補：先用交易確保單次操作一致，再用冪等抵抗重複執行。過度依賴分散式交易會犧牲可用性，冪等提供更務實的工程平衡。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, A-Q8, C-Q8

A-Q13: 冪等與樂觀併發控制（ETag/版本號）有何差異？
- A簡: 樂觀鎖防止同時更新衝突；冪等防止重試重複副作用。
- A詳: 樂觀鎖透過版本一致性避免併發覆蓋，失敗需重讀重試；冪等確保同一語義重試不重複執行。二者可結合：先用 ETag 檢測衝突，再用 Idempotency Key 去重與重放結果，保障操作正確與重試安全。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q5, C-Q3, D-Q3

A-Q14: 冪等與重試策略（退避/抖動）的關係？
- A簡: 冪等提供安全性；退避抖動提供穩定性與減峰。
- A詳: 冪等解決「重試不會害人」；退避與抖動解決「怎麼重試才不壓垮系統」。兩者需共同設計：重試僅發生於可恢復錯誤，使用指數退避＋隨機抖動降低同步洪峰，並限制最大嘗試與總時長，以維持整體服務健壯性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q5, D-Q5

A-Q15: 去重（Deduplication）在冪等中扮演什麼角色？
- A簡: 以唯一鍵識別重複請求，重放首次結果而非重做。
- A詳: 去重是冪等的基礎機制。伺服端在接收請求時，基於 Idempotency Key 進行原子性查存：若不存在則執行並記錄結果；若已存在則直接回傳記錄的回應。關鍵在唯一性約束、原子寫入與結果持久化，以確保多實例與併發情境下仍正確。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q2, B-Q3, B-Q6

A-Q16: 有副作用的支付/扣款如何做到冪等？
- A簡: 以業務識別綁定一次請款，唯一約束與結果重放。
- A詳: 為支付類操作設計「業務單號 + Idempotency Key」唯一性，資料層建立唯一索引，首次執行完成後持久化狀態與回應。後續重試用同鍵直接回放。與下游（收單、銀行）協議同樣的冪等鍵或使用對賬狀態機，避免重複扣款。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q8, B-Q9, D-Q1

A-Q17: 客戶端生成與伺服端生成 Idempotency Key 差異？
- A簡: 客端生成利於語義綁定；伺服端生成簡化客戶端但需回傳。
- A詳: 客端生成能跨重試與跨進程維持同一鍵，最常見也最推薦。伺服端生成需先取 Token 再提交，增加一次往返但可集中策略。實務多採「客端生成，伺服端校驗＋補充範圍」的混合模式，兼顧易用與安全。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q6, B-Q7, B-Q2

A-Q18: 重試命中已有結果時應回傳什麼狀態碼？
- A簡: 200/201 與原回應一致；或 409/422 於語義衝突時提示。
- A詳: 若重試與首次語義一致，應返回與首個請求相同的狀態碼與內容，維持決定性。若同鍵但 Payload 不一致，建議回 409 Conflict 或 422 Unprocessable Entity，明確說明鍵已綁定不同語義，避免誤導客戶端。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: D-Q2, C-Q4, B-Q4

A-Q19: 冪等對觀測性與審計有何幫助？
- A簡: 以鍵串接所有嘗試與結果，簡化追蹤、對帳與客訴處理。
- A詳: Idempotency Key 成為一次業務操作的穩定錨點。配合 TraceID，可快速定位所有重試、併發與最終結果，方便審計、報表與對帳。重放快取也使「已成功但回應遺失」的案例能被一致重建，降低客訴成本。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, C-Q5, D-Q5

A-Q20: 為何「Exactly-once」常被視為錯覺？實務怎做？
- A簡: 分散式中難以保證；以至少一次＋冪等實現等價語義。
- A詳: 網路與節點故障下無法同時保證可用與精確一次執行。追求真正的 Exactly-once 成本高昂。工程實務採用「At-least-once 傳遞＋伺服端冪等去重」達成對業務而言的「有效一次」，以更低成本取得相同語義保障。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q9, D-Q10

### Q&A 類別 B: 技術原理類

B-Q1: 安全重試的整體運作流程是什麼？
- A簡: 客戶端產生鍵與重試策略，伺服端去重執行並重放決定性回應。
- A詳: 流程包含：客戶端生成 Idempotency Key，附於請求；伺服端以鍵與 Scope 原子查存，首次執行動作並持久化結果（狀態碼、Body、Headers、完成時間、TTL）；遭遇重試，伺服端直接重放；客戶端遇暫時性錯誤用退避抖動重送，超過上限則放棄並可查詢狀態。核心在原子性、唯一性與決定性回應。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q2, B-Q10, A-Q5

B-Q2: Idempotency Key 在伺服端如何實現去重？
- A簡: 以唯一鍵原子寫入記錄首次結果，後續同鍵直接回放。
- A詳: 伺服端建立去重表，鍵由端點＋身分＋請求摘要組成。首次請求用 SETNX 或唯一索引保證只有一個執行路徑，執行完成後將回應持久化。若併發命中同鍵，未獲鎖者輪詢或等待直至結果可用，並重放相同回應，確保決定性與冪等。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q6, A-Q15

B-Q3: 去重資料模型與唯一性約束如何設計？
- A簡: 主鍵為 ScopeKey，欄位存狀態碼、Body、Headers、TTL、完成時間。
- A詳: 模型包含：ScopeKey（端點＋操作者＋PayloadHash）、Status、ResponseBody、ResponseHeadersHash、CreatedAt、CompletedAt、TTL、ProcessingFlag。以唯一索引鎖定 ScopeKey，原子建立中間狀態，完成後更新結果。避免大物件可採外部儲存引用，並提供過期清理機制。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q3, C-Q4, B-Q8

B-Q4: 何謂決定性回應（Deterministic Response）？
- A簡: 同一鍵請求必得相同狀態碼與內容，與首次一致。
- A詳: 決定性回應確保重試與首次回應一致，避免客戶端狀態分叉。伺服端需將首次回應完整持久化（含必要 Headers），並屏蔽非決定性元素（如時間、隨機值）或改為由伺服端生成並存儲。這是冪等重放的必要條件，亦便於審計與除錯。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, C-Q4, D-Q5

B-Q5: 如何處理相同鍵的高併發請求？
- A簡: 用唯一鍵原子入列＋短鎖；未持鎖者等待結果或返回進行中。
- A詳: 先以唯一鍵原子占位（ProcessingFlag），僅允許一條執行路徑。其餘請求可短輪詢等待結果、訂閱通知或立即返回 202/409 表示進行中。需避免全域鎖，選擇細粒度鍵鎖，並設置超時與恢復機制，防止執行卡住造成死鎖或資源耗盡。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: D-Q3, B-Q6, C-Q2

B-Q6: Redis SETNX 與資料庫唯一索引的取捨？
- A簡: Redis 提供高效原子鎖與 TTL；DB 唯一索引更強一致與事務性。
- A詳: Redis 適合高併發、低延遲去重，SETNX/GET/PEXPIRE 實作鎖與過期；但需處理持久化與重啟。資料庫唯一索引整合交易，簡化一致性，延遲較高且易成為瓶頸。常見混合方案：Redis 做熱窗去重＋DB 做落盤準確性與審計。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q2, C-Q3, B-Q8

B-Q7: Scope 設計與請求摘要（Hash）如何計算？
- A簡: 用端點、操作者、語義欄位排序後做穩定雜湊。
- A詳: ScopeKey = Hash(Method+PathTemplate+ActorId+SemanticFields)。僅納入決定語義的欄位（如金額、幣別、外部單號），排序與標準序列化（如 Canonical JSON）防止同義不同形。可加版本號避免演進衝突，並與租戶/環境一起作為鍵前綴。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: C-Q6, D-Q2, B-Q3

B-Q8: TTL 與清理策略的技術考量是什麼？
- A簡: 設定合理 TTL、分層過期與批次清理，權衡成本與風險。
- A詳: 熱資料用短 TTL（數小時/天），高風險交易可延長（數天/週）。採分層儲存：熱窗在 Redis，長期在 DB。定期批次掃描過期記錄，或以時間分區表與過期索引加速清理。注意避免在尖峰時段清檔造成毛刺。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q2, C-Q3, D-Q7

B-Q9: 跨服務冪等如何實作（Saga/Outbox）？
- A簡: 以本地交易＋Outbox 可靠發佈，消費端冪等處理串接。
- A詳: 端到端冪等常用「本地交易+Outbox」確保事件可靠送出；下游以業務鍵與去重表冪等消費。跨步驟用 Saga/狀態機管理補償。對外第三方操作以合作方的 Idempotency 機制或自建對帳避免重複執行，達成全鏈路穩定語義。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: C-Q9, A-Q12, D-Q10

B-Q10: 客戶端應如何分類錯誤並重試？
- A簡: 區分可恢復錯誤（超時、5xx）與不可恢復（4xx），採退避抖動。
- A詳: 對超時、連線重置、暫時性 5xx 可重試；對語義錯誤 4xx 不重試（除 409 可換鍵重提）。採指數退避＋抖動，限制最大嘗試與總時間，並記錄 Idempotency Key 與最終結果，便於診斷。避免對非冪等端點自動重試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q5, D-Q5, A-Q14

### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何在 ASP.NET Core 接收與驗證 Idempotency-Key？
- A簡: 以中介層讀取標頭，組 ScopeKey，原子查存與重放回應。
- A詳: 實作步驟：1) 在中介層讀取 Idempotency-Key。2) 取得 ActorId、Path 模板與語義欄位做 Canonical JSON 與 Hash。3) 以 ScopeKey 查去重表。4) 未命中則原子占位並執行後續管線，完成後存回應；命中則重放。示例: C# 使用 IDistributedCache/Redis 或 DbContext 進行查存。注意處理併發與超時回收。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q2, C-Q2, C-Q4

C-Q2: 如何用 Redis 實作去重與原子性？
- A簡: 使用 SETNX 佔位、EXPIRE 設 TTL、完成後存結果並釋放。
- A詳: 步驟：1) SET key value NX PX=lockTTL 佔位。2) 若成功，執行業務，將結果以 HSET 存入 key:data 並設 TTL。3) 失敗則 DEL 佔位。4) 併發命中可輪詢 key:data 或返回 202。關鍵 Lua 腳本保證 SETNX+EXPIRE 原子。最佳實踐：鍵前綴、合理 TTL、死鎖恢復與監控鍵數量。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, B-Q8, D-Q3

C-Q3: 如何用 SQL 資料庫實作唯一約束去重？
- A簡: 建表含 ScopeKey 唯一索引，首次 INSERT；重試 SELECT 重放。
- A詳: 步驟：1) 建表(Id, ScopeKey UNIQUE, Status, Body, HeadersHash, CompletedAt, TTL)。2) 首次請求以交易 INSERT 佔位（Status=Processing）。3) 完成後 UPDATE 記錄結果。4) 重試以 SELECT 取得結果重放。注意：防止大 Body，建外部儲存引用；清理用分區表或定時批次。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q8, C-Q4

C-Q4: 如何儲存並重放決定性回應？
- A簡: 持久化狀態碼、必要標頭與回應體，命中同鍵即原樣送回。
- A詳: 步驟：1) 定義可序列化回應模型：StatusCode、Headers(白名單)、Body。2) 首次請求完成後持久化。3) 重試命中時直接寫出保存內容。4) 避免非決定性標頭（日期、追蹤）或重算。最佳實踐：壓縮大型 Body、Header 白名單、版本號與簽名校驗。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, C-Q3, D-Q8

C-Q5: 如何實作客戶端的安全重試（退避與抖動）？
- A簡: 對可恢復錯誤重試，採指數退避＋抖動，維持同一鍵。
- A詳: 步驟：1) 生成全程固定的 Idempotency Key。2) 分類錯誤：超時/5xx 重試；4xx 不重試。3) 指數退避（如 100ms, 200ms, 400ms）＋抖動。4) 設最大嘗試與總時長。5) 記錄最終結果與鍵。程式碼：HttpClient Handler 注入重試策略，Header 添 Idempotency-Key。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q10, A-Q14, D-Q5

C-Q6: 如何制定 Idempotency Key 的命名與範圍策略？
- A簡: 使用 UUIDv4/ULID 並與端點、用戶、語義欄位共同構鍵。
- A詳: 策略：客端生成隨機鍵（UUIDv4/ULID），伺服端以 Method+PathTemplate+ActorId+SemanticHash 組 ScopeKey。避免使用可猜測值，支持跨進程重用同鍵。對外暴露鍵僅作參考，實際查找用 ScopeKey。提供衝突回應策略（409/422）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, A-Q10, D-Q2

C-Q7: 如何漸進式為既有 API 加入冪等保護？
- A簡: 先新增鍵支援與結果快取，灰度放量，最後強制校驗。
- A詳: 步驟：1) 增加可選 Header 支援與伺服端結果持久化。2) 觀測命中率與效能。3) 部分路由強制鍵與唯一性約束。4) 推動客戶端升級，最終全量強制。注意：相容舊客戶端、風險路徑優先、提供狀態查詢與良好錯誤訊息。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: D-Q4, B-Q8, C-Q4

C-Q8: 如何為支付/扣款設計冪等流程？
- A簡: 業務單號唯一，首次鎖定並請款，存結果，重試重放。
- A詳: 步驟：1) 定義商戶單號＋Idempotency Key，建立唯一索引。2) 首次下單鎖定資源，請款成功則持久化結果與對賬憑證。3) 重試直接重放，若下游超時，用狀態查詢消歧。4) 定期對賬與補償。注意：與收單方協議冪等或使用外層狀態機隔離重複。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q9, D-Q1, D-Q10

C-Q9: 如何在訊息消費端實作冪等（Kafka/Bus）？
- A簡: 以業務鍵去重表，處理前查存，完成後記錄偏移與結果。
- A詳: 步驟：1) 取業務唯一鍵（如外部單號）作去重鍵。2) 消費前查表，不存在則占位並處理。3) 成功後持久化結果與消費位移。4) 重複消息直接跳過或重放結果。最佳實踐：Exactly-once 幻覺避免，使用至少一次＋冪等消費。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q9, A-Q20, D-Q10

C-Q10: 如何測試與驗證冪等實作的健壯性？
- A簡: 混沌測試網路故障、併發同鍵、下游超時與重放一致性。
- A詳: 測試面：1) 網路斷線/超時/重排。2) 併發同鍵洪峰。3) 首次成功回應丟失。4) 下游成功但回報超時。驗證：最終狀態唯一、回應決定性、無重複副作用。工具：整合測試、故障注入、壓測、對賬核驗。建立可觀測性指標與告警。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: D-Q5, B-Q5, B-Q8

### Q&A 類別 D: 問題解決類（10題）

D-Q1: 網路中斷不確定是否扣款成功，怎麼辦？
- A簡: 不要盲目重做；用相同鍵重試或查狀態，應回放同一結果。
- A詳: 症狀：客戶端超時，未知是否已扣款。原因：回應丟失但伺服端已執行。解法：使用相同 Idempotency Key 重試，伺服端應重放相同結果；或提供查詢接口對同鍵取狀態。預防：所有有副作用操作強制鍵與冪等實作，並建立對賬流程。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, C-Q8, B-Q4

D-Q2: 同一 Key 但 Payload 不同該如何處理？
- A簡: 視為語義衝突，回 409/422，提示鍵已綁定舊語義。
- A詳: 症狀：客戶端誤用重複鍵卻更改金額等欄位。原因：鍵重用但語義不同。解法：伺服端驗證 PayloadHash，若不一致回 409/422，提供已綁定內容。預防：嚴格定義 Scope 與校驗策略，客戶端建議每次新操作生成新鍵。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q7, C-Q6

D-Q3: 高併發下仍出現重複寫入，如何排查？
- A簡: 檢查唯一約束、原子占位與鎖超時；加固 SETNX/唯一索引。
- A詳: 症狀：同鍵兩筆落庫。原因：缺少唯一約束、占位非原子或鎖過期。解法：資料層加唯一索引；Redis 用 Lua 保證 SETNX+EXPIRE 原子；增加處理超時與恢復機制。預防：壓測併發、加告警、冪等表與業務表雙重約束。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q5, B-Q6, C-Q2

D-Q4: 去重儲存層故障時如何降級？
- A簡: 降級為只允許冪等鍵查詢，暫停創建新操作或降流。
- A詳: 症狀：Redis/DB 故障。原因：基礎設施不可用。解法：切換只讀模式，擋下無鍵請求；允許相同鍵重放；必要時返回 503 並啟動降流；提供查詢狀態服務。預防：雙活多區、快取與落盤雙層、健康檢查與自動切換。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q8, C-Q7

D-Q5: 伺服端已成功但回應丟失，如何消歧與善後？
- A簡: 用相同鍵重試重放結果；或提供狀態查詢與對賬核驗。
- A詳: 症狀：客戶端 5xx/超時，但實際已成功。原因：回應在途中丟失。解法：同鍵重試、伺服端重放決定性回應；必要時提供狀態查詢端點。預防：決定性回應持久化、觀測度量（成功但無回傳）、合適 TTL 與自動對賬。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, C-Q4, A-Q19

D-Q6: 如何防止 Idempotency Key 被重放攻擊？
- A簡: 綁定身分與端點、短 TTL、HTTPS、速率限制與簽名。
- A詳: 症狀：攻擊者竊取鍵重放請求。原因：鍵可被重用且無範圍綁定。解法：Scope 綁定 ActorId/端點，短 TTL；只允許同一憑證與同一語義；採用 HTTPS、時間戳與請求簽名；加上速率限制與異常告警。預防：最小權限與密鑰輪替。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q10, A-Q11, C-Q6

D-Q7: 長任務導致鍵過期，重試回 404/409，怎處理？
- A簡: 提供查狀態接口與更長 TTL；或切換為查詢模式。
- A詳: 症狀：長時間處理超過 TTL，後續重試無法重放。原因：TTL 過短。解法：為長任務設更長 TTL 或分段狀態；提供以業務單號查狀態接口。預防：按路由分級 TTL，動態調整；在回應中回報建議重試窗與查詢 URL。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q8, A-Q11

D-Q8: 回應體很大導致去重存儲壓力，怎優化？
- A簡: 只存必要欄位或外部儲存引用，壓縮與過期清檔。
- A詳: 症狀：冪等表暴增、I/O 壓力。原因：直接存整個 Body。解法：Body 白名單提取必要資料，或存外部儲存的物件鍵；啟用壓縮；縮短 TTL；用時間分區表與批次清理。預防：設計回應即為決定性且精簡。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q8, C-Q4

D-Q9: 多區部署下跨區重試導致鍵不一致怎麼辦？
- A簡: 鍵資料全域一致：同步去重表或用全域路由黏著。
- A詳: 症狀：不同區域各自執行同鍵操作。原因：鍵空間不共享。解法：1) 全域一致儲存（多主/主從）或 2) 流量黏著到首次處理區域（路由表）。預防：鍵前綴包含區域但用全域聚合；環境演練跨區容災與一致性。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q8, C-Q2, C-Q3

D-Q10: 下游第三方非冪等，如何端到端防護？
- A簡: 在我方加冪等外殼，對下游用對賬/狀態查詢與補償。
- A詳: 症狀：重試觸發第三方重複執行。解法：我方以 Idempotency Key 包裝，首次結果落盤；對下游用查狀態接口消歧，或將外部單號作為冪等鍵；必要時採用 Outbox+Saga 與對賬補償。預防：與第三方簽訂冪等協議或隔離再試機制。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q9, C-Q8, A-Q20

### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 為什麼在分散式系統中要考慮網路不可靠性？
    - A-Q2: 什麼是安全重試（Safe Retry）？
    - A-Q3: 什麼是冪等（Idempotent）？
    - A-Q4: 為什麼需要設計冪等 API？
    - A-Q5: 什麼是 Idempotency Key？
    - A-Q6: Idempotency Key 與 Correlation ID/TraceID 有何差異？
    - A-Q7: HTTP 方法與冪等性的差異是什麼？
    - A-Q9: 冪等性的核心價值是什麼？
    - A-Q18: 重試命中已有結果時應回傳什麼狀態碼？
    - A-Q19: 冪等對觀測性與審計有何幫助？
    - B-Q1: 安全重試的整體運作流程是什麼？
    - B-Q2: Idempotency Key 在伺服端如何實現去重？
    - C-Q5: 如何實作客戶端的安全重試（退避與抖動）？
    - D-Q1: 網路中斷不確定是否扣款成功，怎麼辦？
    - D-Q5: 伺服端已成功但回應丟失，如何消歧與善後？
- 中級者：建議學習哪 20 題
    - A-Q8: At-most-once、At-least-once、Exactly-once 的差異？
    - A-Q10: Idempotency Key 的作用範圍（Scope）是什麼？
    - A-Q11: 為何 Idempotency Key 需要有效期（TTL）？
    - A-Q12: 冪等與資料庫交易（Transaction）有何不同？
    - A-Q13: 冪等與樂觀併發控制（ETag/版本號）有何差異？
    - A-Q14: 冪等與重試策略（退避/抖動）的關係？
    - A-Q15: 去重（Deduplication）在冪等中扮演什麼角色？
    - A-Q16: 有副作用的支付/扣款如何做到冪等？
    - A-Q17: 客戶端生成與伺服端生成 Idempotency Key 差異？
    - A-Q20: 為何「Exactly-once」常被視為錯覺？實務怎做？
    - B-Q3: 去重資料模型與唯一性約束如何設計？
    - B-Q4: 何謂決定性回應（Deterministic Response）？
    - B-Q5: 如何處理相同鍵的高併發請求？
    - B-Q6: Redis SETNX 與資料庫唯一索引的取捨？
    - B-Q8: TTL 與清理策略的技術考量是什麼？
    - B-Q10: 客戶端應如何分類錯誤並重試？
    - C-Q1: 如何在 ASP.NET Core 接收與驗證 Idempotency-Key？
    - C-Q2: 如何用 Redis 實作去重與原子性？
    - C-Q3: 如何用 SQL 資料庫實作唯一約束去重？
    - C-Q4: 如何儲存並重放決定性回應？
- 高級者：建議關注哪 15 題
    - B-Q7: Scope 設計與請求摘要（Hash）如何計算？
    - B-Q9: 跨服務冪等如何實作（Saga/Outbox）？
    - C-Q7: 如何漸進式為既有 API 加入冪等保護？
    - C-Q8: 如何為支付/扣款設計冪等流程？
    - C-Q9: 如何在訊息消費端實作冪等（Kafka/Bus）？
    - C-Q10: 如何測試與驗證冪等實作的健壯性？
    - D-Q2: 同一 Key 但 Payload 不同該如何處理？
    - D-Q3: 高併發下仍出現重複寫入，如何排查？
    - D-Q4: 去重儲存層故障時如何降級？
    - D-Q6: 如何防止 Idempotency Key 被重放攻擊？
    - D-Q7: 長任務導致鍵過期，重試回 404/409，怎處理？
    - D-Q8: 回應體很大導致去重存儲壓力，怎優化？
    - D-Q9: 多區部署下跨區重試導致鍵不一致怎麼辦？
    - D-Q10: 下游第三方非冪等，如何端到端防護？
    - A-Q20: 為何「Exactly-once」常被視為錯覺？實務怎做？
