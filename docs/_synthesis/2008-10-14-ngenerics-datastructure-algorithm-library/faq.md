---
layout: synthesis
title: "NGenerics - DataStructure / Algorithm Library"
synthesis_type: faq
source_post: /2008/10/14/ngenerics-datastructure-algorithm-library/
redirect_from:
  - /2008/10/14/ngenerics-datastructure-algorithm-library/faq/
postid: 2008-10-14-ngenerics-datastructure-algorithm-library
---

# NGenerics - DataStructure / Algorithm Library

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是 NGenerics？
- A簡: NGenerics 是 .NET 的資料結構與演算法開源函式庫，提供 Graph、Heap、排序法與圖演算法等實作。
- A詳: NGenerics 是一套面向 .NET/C# 的開源函式庫，涵蓋常見資料結構（如 Heap、BinaryTree、CircularQueue、PriorityQueue）與演算法（含 Dijkstra、Kruskal、Prim 等）。它採用泛型與標準介面（ICollection、IEnumerable）設計，易於整合既有 .NET 專案。適合學習資料結構、快速完成原型與解決實務圖論問題，如路網最短路徑、最小生成樹等。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q4, B-Q1

A-Q2: 為什麼選擇 NGenerics 而非自行實作資料結構？
- A簡: 現成函式庫更可靠、 API 介面一致，節省時間且易維護；自行實作易缺少介面與測試。
- A詳: 自行實作資料結構不僅耗時，還可能忽略 .NET 常用介面（ICollection、IEnumerable）與泛型化設計，導致與其他元件整合困難。NGenerics 提供經驗證的實作與標準 API，一致的行為與文件案例可降低學習與維護成本。對教育與實務皆有助益：快速驗證想法、對比多種演算法、直接閱讀原始碼理解設計取捨。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q12, B-Q11, C-Q10

A-Q3: NGenerics 支援哪些資料結構？
- A簡: 含 Heap、BinaryTree、CircularQueue、PriorityQueue、Graph 等，覆蓋常見結構需求。
- A詳: NGenerics 提供豐富資料結構：線性結構（List、Queue、CircularQueue）、樹與堆（BinaryTree、BinaryHeap）、優先佇列（PriorityQueue）、以及圖（Graph<T>）。這些結構以泛型與標準介面設計，能直接整合到 .NET 程式。對演算法學習者亦可搭配內建排序、圖演算法，觀察不同資料結構的效能與適配性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, B-Q1, B-Q15

A-Q4: NGenerics 包含哪些演算法類別？
- A簡: 圖演算法（Dijkstra、Kruskal、Prim）、排序等；透過 GraphAlgorithms 等類別提供。
- A詳: 在圖論方面，NGenerics 的 Algorithms 命名空間含 GraphAlgorithms，提供 Dijkstra（單源最短路徑）、Kruskal 與 Prim（最小生成樹）。此外亦涵蓋排序等常見算法。這些演算法可直接作用於對應資料結構（如 Graph<T>），利於快速建模與驗證解法，亦可透過原始碼深入學習其設計與效率。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, A-Q8, A-Q9, B-Q3

A-Q5: 什麼是 Graph<T>？適合哪些應用？
- A簡: Graph<T> 是泛型圖資料結構，支援節點、邊與權重，可建模路網、依賴關係等。
- A詳: Graph<T> 表示由頂點（Vertex）與邊（Edge）構成的圖，支援有向或無向、邊權重設定。適合建模道路網、通訊網、相依關係、任務排程等。NGenerics 的 Graph<T> 搭配 GraphAlgorithms 可直接運作多種圖演算法，如最短路徑與最小生成樹，縮短從建模到求解的距離。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, B-Q2, C-Q1

A-Q6: 什麼是 GraphAlgorithms？
- A簡: GraphAlgorithms 是 NGenerics 中圖算法集合，提供 Dijkstra、Kruskal、Prim 等實作。
- A詳: GraphAlgorithms 是位於 NGenerics.Algorithms 命名空間中的類別群，提供對 Graph<T> 的即用型演算法。其方法通常接收 Graph 與起點（或其他條件），回傳結果圖或計算值。好處是可快速套用經典解題方案；缺點是抽象層較高，某些中間資訊（如完整路徑）不一定預設保留，必要時需閱讀原碼或擴充。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, B-Q3, D-Q1

A-Q7: Dijkstra 演算法是什麼？用於何處？
- A簡: 單源最短路徑演算法，針對非負權重圖，求起點到各點最短距離。
- A詳: Dijkstra 用於從單一起點計算到所有其他節點的最短距離，要求邊權重非負。由起點開始擴張，透過鬆弛（relaxation）更新距離，常以優先佇列加速。適用於路網導航、網路路由、成本最低決策等。NGenerics 提供現成實作，能快速取得最短成本值。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q4, C-Q2

A-Q8: Kruskal 演算法是什麼？適用場景？
- A簡: 最小生成樹演算法，以邊權排序逐步合併集合，適用稀疏圖。
- A詳: Kruskal 用於在連通加權無向圖中找出總權重最小的生成樹。流程是依權重排序所有邊，從小到大選邊，若不構成環則收錄，常配合並查集（Union-Find）檢測環。適合稀疏圖與需全域最小連通成本的場景，如電網、骨幹網規劃。與 Prim 相比，更偏向邊導向的選擇策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, A-Q10, B-Q5

A-Q9: Prim 演算法是什麼？適用場景？
- A簡: 最小生成樹演算法，自某頂點出發逐步擴張樹邊，常配合優先佇列。
- A詳: Prim 從任意起點出發，每次選取連接生成樹與外部節點的最小權重邊，逐步擴張生成樹。以優先佇列維護前緣邊可提升效率。適合稠密圖或鄰接矩陣表示。與 Kruskal 差異在策略：Prim 是節點擴張，Kruskal 是邊排序挑選；兩者皆求最小生成樹。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q10, B-Q6

A-Q10: 最短路徑與最小生成樹有何差異？
- A簡: 最短路徑最小化兩點間成本；最小生成樹最小化全域連通成本，非針對任意兩點最短。
- A詳: 最短路徑以點對點（或單源到多點）最小化行經成本，典型用 Dijkstra。最小生成樹則在不形成環的前提下，選擇連通所有節點的邊集合，使總成本最小，典型用 Kruskal 或 Prim。MST 不保證任意兩點路徑即最短；反之，最短路徑樹也非全域最小生成樹。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, A-Q8, A-Q9

A-Q11: 為什麼 SortedList 的 Key 不能重複？
- A簡: SortedList 以鍵唯一對應值，內部基於排序鍵查找，重複鍵會破壞映射。
- A詳: .NET 的 SortedList<TKey,TValue> 是基於鍵的排序與索引查找，要求鍵唯一以維持映射一致性與二元搜尋的正確性。重複鍵會導致插入衝突與查找歧義，故 API 設計上禁止。若需多值對應同鍵，可改用 Lookup、IGrouping、或 SortedDictionary 配合 List。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q12, D-Q4

A-Q12: 為何 ICollection/IEnumerable 等介面重要？
- A簡: 標準介面帶來可迭代、可計數與相容性，便於與 .NET 生態整合與測試。
- A詳: 支援 ICollection、IEnumerable 使資料結構能被 foreach、LINQ、LinqPad、單元測試等工具輕鬆運用，也利於多型替換與抽換實作。這些介面提供一致的存取語意，降低耦合，提高可測性與可維護性。NGenerics 重視這些介面，讓結構在實務上更易用。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q2, B-Q11, C-Q10

A-Q13: NGenerics 文件有哪些限制？如何彌補？
- A簡: 未明確標示時間複雜度，需讀原始碼或以測試估算，或參考標準算法知識。
- A詳: 官方文件較少提供嚴謹的時間與空間複雜度標註，學習者需透過原始碼、單元測試與性能分析工具推估。對經典演算法可依既知複雜度作基準；對實作細節（如資料結構選用）則需閱讀程式碼。這亦是學習機會，理解實作如何影響效率與 API 設計。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q13, D-Q8, C-Q9

A-Q14: 有向圖與無向圖差異為何？
- A簡: 有向圖邊具方向，路徑遵循箭頭；無向圖邊雙向通行，常用於雙向道路。
- A詳: 有向圖（Directed Graph）中邊自 u 指向 v，表示單向關係或不同方向成本；無向圖（Undirected Graph）邊不分方向，代表對稱關係。在路網中，若南北向收費或距離不同，需用有向圖建模；若完全對稱則可用無向圖簡化。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q7, C-Q4, D-Q9

A-Q15: 邊權重與點權重差異是什麼？
- A簡: 邊權重描述路段成本；點權重描述節點成本。NGenerics Graph 主要使用邊權重。
- A詳: 多數圖演算法以邊權重（距離、時間、費用）建模成本。若有節點成本（如收費站），常轉換為邊權重處理，例如將通過節點的費用加到進入或離開該節點的有向邊上。NGenerics 的 Graph 模型以邊為主，需透過此轉換納入點成本。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q3, C-Q4, B-Q8

A-Q16: 高速公路路網如何對應圖的元素？
- A簡: 路口/交流道為頂點，路段為邊；邊權重代表里程、時間或油錢等成本。
- A詳: 實務建模中，將交流道、匝道節點視為 Vertex，兩節點間可通行的道路為 Edge。邊的權重可依需求設定為距離、時間、油費或綜合成本。若有收費站，則轉為有向邊並把費用併入權重。此建模利於使用 Dijkstra 等演算法求最短成本路徑。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q15, C-Q1, C-Q3

A-Q17: 為什麼要把收費站費用併入邊權重？
- A簡: 因 Graph 模型預設點無權重，將節點成本分攤至進出邊以利最短路徑計算。
- A詳: 多數最短路徑實作只處理邊權重。若收費站屬節點成本，直接套用會遺漏。解法是將收費站費用加到通過該站的有向邊（進站或出站）上，使演算法能在邊鬆弛時考慮完整成本。這也能分別處理南北向不同費率或單向收費。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, C-Q3, C-Q4

A-Q18: 使用 Dijkstra 的核心價值是什麼？
- A簡: 以非負權重快速求單源最短成本，決策可解釋、結果穩定且易比較。
- A詳: Dijkstra 在非負權重圖下提供可證明正確的最短路徑，時間效率佳，易整合優先佇列優化。對路網、排程、成本控制等場景，能直觀地量化與比較不同路徑。配合清楚的建模（權重涵蓋真實成本），可直接支援業務決策與使用者體驗。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q4, C-Q2

A-Q19: 使用開源函式庫學習資料結構有何價值？
- A簡: 可讀原碼、跑測試、實作比較；加深概念理解並加速實戰應用。
- A詳: 開源庫提供可運行的參考實作，利於閱讀源碼理解抽象介面、效能取捨與測試方法。可快速搭建實驗，比較不同演算法/結構的表現，連結理論與實務。也能在原有基礎上擴充，如加入路徑追蹤、訪問者模式，建立自訂解決方案。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q13, B-Q23, C-Q5

A-Q20: Graph<T> 的泛型參數代表什麼？
- A簡: T 表示頂點承載的資料型別，如字串名稱或自訂節點類型。
- A詳: Graph<T> 的 T 用於頂點的資料，如節點 ID、地名、或含屬性的自訂類型。以字串命名便於快速建立雛形；以自訂類型則能攜帶更多資訊（經緯度、類別、限制）。選擇 T 的合適設計，會影響識別、比較與擴充性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, C-Q7, C-Q1

---

### Q&A 類別 B: 技術原理類

B-Q1: NGenerics 的 Graph<T> 如何表示節點與邊？
- A簡: 以 Vertex/Edge 物件建模，支援有向/無向與邊權重，頂點保存資料與狀態。
- A詳: Graph<T> 內部含 Vertex<T> 集合與 Edge 結構。每個頂點持有 T 型資料與額外狀態（如 Weight），邊連接兩頂點並可附帶權重。可在建構時指定是否為有向圖。核心組件：Graph、Vertex、Edge。關鍵流程：建立頂點、建立邊、設定權重與方向，供演算法存取。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q2, C-Q1

B-Q2: AddVertex 與 AddEdge 在 Graph<T> 中如何運作？
- A簡: AddVertex 建立頂點節點；AddEdge 連結兩頂點並設權重，依圖向性建立連結。
- A詳: AddVertex 先檢查是否已存在，再創建 Vertex<T> 並加入圖集。AddEdge 需取得兩端 Vertex，建立 Edge，設定權重，並依有向/無向圖決定單向或雙向連結。步驟：驗證頂點存在→建立邊→設權重→更新鄰接關係。核心組件：Graph、Vertex、Edge 列表或鄰接結構。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q1, C-Q1, C-Q4

B-Q3: GraphAlgorithms.DijkstrasAlgorithm 如何運作？
- A簡: 以鬆弛法迭代更新距離，常用優先佇列提取最小距離頂點，生成結果圖。
- A詳: 實作會初始化起點距離為 0，其餘為無限，使用優先佇列（或等效結構）反覆取出當前最小距離頂點，對其鄰接邊進行鬆弛更新。直到佇列空或全更新完成，回傳含頂點最短距離的結果圖。關鍵步驟：初始化→取最小→鬆弛→更新佇列。核心組件：Graph、PriorityQueue、距離表。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q4, C-Q2

B-Q4: Dijkstra 為何要求非負邊權重？
- A簡: 負權會破壞最短性貪婪選擇，已確定之最短距離可能被之後負邊改寫。
- A詳: Dijkstra 依賴「貪婪」性質：每次選出當前最小距離頂點即為最短。一旦存在負權邊，後續路徑可能降低已確定距離，導致錯誤。解決需改用 Bellman-Ford 或 Johnson。關鍵觀念：鬆弛不會因負環再降；核心組件：距離陣列、優先佇列、鬆弛規則。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, D-Q2, B-Q19

B-Q5: Kruskal 演算法的機制與流程是什麼？
- A簡: 先排序所有邊，使用並查集合併不成環的邊，直到生成樹完成。
- A詳: Kruskal 以邊權排序（O(E log E)），逐條檢查最小邊，若兩端頂點屬不同集合則合併並收錄邊。透過 Union-Find 快速判定是否形成環，直到收錄 V-1 條邊。核心組件：邊排序、Union-Find。步驟：排序→遍歷→查環→合併→完成。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q10, B-Q6

B-Q6: Prim 演算法的機制與流程是什麼？
- A簡: 從起點出發，使用優先佇列選取最小連接邊，擴張生成樹直到涵蓋所有頂點。
- A詳: 初始化任一頂點，將其鄰接邊放入優先佇列。重複取出最小邊，若邊指向未收錄頂點，則加入生成樹並把該頂點鄰邊加入佇列。直到所有頂點收錄。核心組件：優先佇列、訪問標記。步驟：初始化→取最小邊→擴張→重複→完成。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, A-Q10, B-Q15

B-Q7: 在 NGenerics 中如何表示有向邊？
- A簡: 建構 Graph<T>(true) 或使用能指示方向的 API，邊自 u 指向 v 不對稱。
- A詳: 建立 Graph<T> 時傳入 isDirected=true 即可啟用有向圖模式，AddEdge(u,v,w) 將僅建立由 u 指向 v 的連結（反向需另外建立）。此設計適合建模單行道路、不同方向成本與收費差異。核心組件：Graph 建構參數、邊集合。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q14, C-Q4, A-Q17

B-Q8: 如何把節點通行費用納入權重計算的機制？
- A簡: 將過站費轉換為經過該站之有向邊額外成本，合併入邊權重。
- A詳: 因點權重未直接支援，將節點費轉移到入站或出站邊：對每條通過該節點的邊，加上對應費用。若方向不同費率，可在有向圖中分別設定。核心步驟：識別費用節點→列舉相鄰邊→調整權重→驗證最短路徑結果合理性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, C-Q3, D-Q5

B-Q9: GraphAlgorithms 回傳「結果圖」的設計考量是什麼？
- A簡: 將計算結果存回圖結構，便於查詢頂點距離，但未必保留完整路徑序列。
- A詳: 透過回傳帶有更新權重（如 Vertex.Weight）的結果圖，可直接以頂點屬性查詢最短距離。但為簡化 API 或分離關注點，可能未保存 predecessor 路徑資訊。這要求使用者若需路徑，需擴充或自取中間資料。核心組件：結果圖、頂點屬性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: D-Q1, C-Q5, B-Q10

B-Q10: 以 Visitor/Delegate 擴充取得走訪資訊的原理？
- A簡: 在演算法走訪過程注入回呼，收集鬆弛與前驅資料以重建路徑。
- A詳: 透過 Visitor 或委派在每次取出頂點、鬆弛邊時攔截事件，紀錄每個頂點的前驅與距離。演算法完成後，從目標頂點回溯前驅即可得到路徑。核心步驟：定義回呼→掛載於關鍵步驟→紀錄 predecessor→回溯重建。核心組件：IVisitor、回呼資料表。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: C-Q5, D-Q1, B-Q3

B-Q11: NGenerics 支援標準集合介面的技術價值？
- A簡: 標準介面讓資料結構能被 foreach/LINQ 使用，增強互操作與測試性。
- A詳: 實作 ICollection/IEnumerable/IList 等，使結構能融入 .NET 生態：LINQ 查詢、序列化、單元測試、依賴注入等。也利於抽換為介面型別，提高可測性與鬆耦合。核心組件：.NET BCL 介面、擴充方法、LINQ Provider。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q12, C-Q10, A-Q2

B-Q12: 為何 SortedList 要求 Key 唯一？內部如何實現？
- A簡: 基於排序鍵與索引查找的映射，重鍵破壞二元搜尋與定位，故需唯一。
- A詳: SortedList 以陣列維護排序後的鍵值對，透過二元搜尋定位鍵索引，再以索引存取值。鍵唯一保證搜尋與更新一對一映射。重複鍵將導致插入定位衝突與查找不確定性。核心組件：鍵陣列、值陣列、BinarySearch。步驟：插入→維持排序→搜尋定位。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, D-Q4

B-Q13: NGenerics 的 Dijkstra 複雜度與影響因素？
- A簡: 理想以優先佇列為 O((V+E)log V)，實際依實作與圖密度而異。
- A詳: 若使用二元堆的優先佇列，Dijkstra 平均 O((V+E) log V)。若以簡單陣列，則 O(V^2+E)。NGenerics 實際複雜度取決於內部資料結構選擇與 API 使用方式。評估可透過讀源碼與基準測試。核心組件：PriorityQueue、鄰接表/矩陣。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q13, B-Q15, D-Q6

B-Q14: 如何在 NGenerics 中使用自定義 Comparer？
- A簡: 透過實作 IComparer<T> 或提供 Comparer 委派，控制節點/鍵排序行為。
- A詳: 對於需非預設排序或比對（如大小寫不敏感、複合鍵），可實作 IComparer<T> 並於資料結構或演算法初始化時注入。影響頂點識別、鍵排序與演算法決策。核心組件：IComparer<T>、相等性比較器、建構參數。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: C-Q7, A-Q20

B-Q15: BinaryHeap/PriorityQueue 在圖演算法扮演何角色？
- A簡: 作為取出最小距離或最小邊的結構，提升 Dijkstra/Prim 效率。
- A詳: 優先佇列維護「當前最優候選」。Dijkstra 用於取出最小距離頂點；Prim 用於取出最小連接邊。BinaryHeap 實現插入與取出 O(log n) 提升效率。核心組件：Push/Pop/DecreaseKey（若有），與距離/權重同步更新。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q6, D-Q6

B-Q16: 如何由結果圖回推出最短距離值？
- A簡: 於結果圖查詢目標頂點的 Weight（或對應屬性），即為最短距離。
- A詳: NGenerics Dijkstra 可能將最終距離儲存在 Vertex.Weight。執行後，透過 result.GetVertex(target).Weight 可取得成本值。若屬性命名不同，需參考源碼或文件。核心步驟：執行演算法→取得結果圖→查詢目標頂點屬性。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q2, B-Q9, D-Q1

B-Q17: Graph 中 Weight 欄位的意義是什麼？
- A簡: 常用作演算法狀態（如距離）暫存欄位，非固定語義，依算法而定。
- A詳: 頂點或邊的 Weight 欄位可被演算法用於暫存距離、優先值或成本。具體語義依演算法實作決定。使用時應閱讀源碼或 API 說明，避免誤用。核心組件：Vertex/Edge 屬性、演算法上下文。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, C-Q2, D-Q5

B-Q18: 如何將無權圖轉換為有權圖以進行成本計算？
- A簡: 為每條邊指定統一或計算的權重，或以函式動態映射成本。
- A詳: 無權圖可賦予邊固定權重（如 1）代表步數，或依資料（距離、時間、費）計算權重。若資料外存，可於加邊時帶入計算結果。核心步驟：定義成本模型→對邊賦值→驗證結果合理性。核心組件：Edge 權重、成本函式。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q16, C-Q1, C-Q3

B-Q19: Dijkstra 與 BFS 的差異與適用時機？
- A簡: BFS 處理等權（或無權）最短邊數；Dijkstra 處理加權非負最短成本。
- A詳: BFS 以層序擴張，適合所有邊等權或以邊數為距離的情境；Dijkstra 處理非負權重下的成本最短。若存在邊權差異，BFS 不適用。選擇依據：成本模型與權重性質。核心組件：佇列 vs 優先佇列、鬆弛規則。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q4, A-Q18

B-Q20: 最短路徑樹與最小生成樹有何技術差異？
- A簡: SPT 由單源最短距離導出；MST 由全域最小總權重導出，目標與方法不同。
- A詳: 最短路徑樹（SPT）是以單源最短距離構成的樹，可能包含與 MST 不同的邊集合。MST 尋求全域連通最省總權重。技術上 SPT 用 Dijkstra/Bellman-Ford；MST 用 Kruskal/Prim。核心組件：距離表 vs 邊集合排序或前緣集合。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q5, B-Q6

---

### Q&A 類別 C: 實作應用類

C-Q1: 如何用 NGenerics 建立高速公路無向圖？
- A簡: 使用 Graph<string>(false) 建無向圖，AddVertex 加交流道，AddEdge 設路段與權重。
- A詳: 步驟：1) 引入 NGenerics；2) 建立無向圖 Graph<string>(false)；3) 以地名 AddVertex；4) 以 AddEdge(u,v,費用) 建邊。程式碼:
  using NGenerics.DataStructures.General;
  var g = new Graph<string>(false);
  g.AddVertex("基金"); g.AddVertex("汐止系統");
  g.AddEdge(g.GetVertex("基金"), g.GetVertex("汐止系統"), 6.0);
  注意：權重可為距離或油費，資料一致性與節點命名需統一。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, B-Q2, C-Q2

C-Q2: 如何查詢兩點之間的最短路徑成本？
- A簡: 執行 GraphAlgorithms.DijkstrasAlgorithm，於結果圖查詢目標頂點 Weight。
- A詳: 步驟：1) 建立圖與權重；2) 執行 Dijkstra：
  using NGenerics.Algorithms;
  var res = GraphAlgorithms.DijkstrasAlgorithm<string>(g, g.GetVertex("機場端"));
  var cost = res.GetVertex("基金").Weight;
  注意：確保邊權非負；Weight 意義依實作為距離/成本；若需路徑需擴充。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q16, D-Q1

C-Q3: 如何把收費站費用加入邊權重？
- A簡: 於建立邊時，將通過收費站的費用加在相應有向邊的權重上。
- A詳: 步驟：1) 改用有向圖 Graph<string>(true)；2) 將收費站費轉換為進站或出站邊的附加成本；3) 對南北向分別設置：
  g.AddEdge(g.GetVertex("A"), g.GetVertex("B"), 距離費+過站費);
  g.AddEdge(g.GetVertex("B"), g.GetVertex("A"), 距離費+回程費);
  注意：確保不重複計費；以單元測試驗證方向費率。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, B-Q8, C-Q4

C-Q4: 如何將無向圖改為有向圖處理不同方向收費？
- A簡: 改用 Graph<string>(true)，為每對節點建立兩條邊，分別設定方向性費率。
- A詳: 步驟：1) 新建 Graph<string>(true)；2) 逐一讀取無向資料，為每對相鄰點建立 A→B 與 B→A；3) 將方向性里程與費用分別帶入；4) 執行 Dijkstra。程式碼略同 C-Q3。注意：避免遺漏反向邊；資料來源需含方向差異。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q14, B-Q7, D-Q9

C-Q5: 如何擴充 Dijkstra 以輸出完整路徑？
- A簡: 以 Visitor/回呼紀錄前驅節點，演算法後自目標回溯重建路徑。
- A詳: 步驟：1) 定義 Dictionary<string,string> predecessor；2) 在鬆弛時若改善距離則更新 predecessor[v]=u；3) 完成後從目標回溯到起點；4) 輸出路徑。若原實作未提供回呼，則複製原始碼加入 Hook。注意：同步更新與避免多執行緒競態。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q10, D-Q1, B-Q9

C-Q6: 如何使用 IVisitor 記錄走訪順序與事件？
- A簡: 實作 IVisitor，在選點與鬆弛時記錄資訊，用於分析或重建路徑與除錯。
- A詳: 步驟：1) 定義 IVisitor 的 Visit/OnRelax 等方法；2) 在演算法每次處理節點/邊呼叫 visitor；3) 將訪問序列、距離變化記錄；4) 完成後分析或重建路徑。注意：訪客需輕量以免拖慢；關鍵事件時機需與實作匹配。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q10, C-Q5, D-Q6

C-Q7: 如何用自定義 Comparer 定義頂點識別規則？
- A簡: 提供 IComparer<T> 給資料結構或查找，實現大小寫無關或複合鍵比對。
- A詳: 步驟：1) 實作 IComparer<string>（如 ToLowerInvariant 比對）；2) 在建立結構或查找 API 注入；3) 確保 GetVertex/ContainsVertex 等一致；4) 加入測試覆蓋。程式碼：
  class CiComparer : IComparer<string> { public int Compare(string a,b)=>string.Compare(a,b,true); }
  注意：與相等性比較器一致避免邏輯分裂。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q14, A-Q20, C-Q1

C-Q8: 如何用 PriorityQueue 優化 Dijkstra？
- A簡: 以優先佇列維護最小距離頂點，降低取最小操作成本，提高整體效率。
- A詳: 步驟：1) 確認 NGenerics 提供 PriorityQueue；2) 將未處理頂點與距離推入隊列；3) Pop 取最小更新鄰邊；4) 支援 DecreaseKey 或以重新插入策略替代。注意：避免重複處理可用訪問標記；測試效能提升幅度。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q15, B-Q13, D-Q6

C-Q9: 如何為圖資料輸入撰寫單元測試？
- A簡: 準備小型已知解圖，測距離與路徑；測方向性與費用是否正確套用。
- A詳: 步驟：1) 建立微型圖（3-6 點）手算最短路徑；2) 寫測試建圖與執行 Dijkstra；3) 斷言距離與（若有）路徑；4) 針對方向費與收費站納入案例。注意：使用固定資料夾具；測試邊界如孤立點、無路徑。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q13, D-Q5, D-Q3

C-Q10: 如何從原始碼編譯與引用 NGenerics？
- A簡: 取得原始碼（如存檔或鏡像），用 Visual Studio 編譯，專案引用組件或以 NuGet 替代。
- A詳: 步驟：1) 從原始來源或鏡像倉庫取得程式碼；2) 打開解決方案並還原相依；3) 建置得到 DLL；4) 在你的專案中 Add Reference；5) using NGenerics.*；6) 撰寫程式。注意：CodePlex 已封存，建議找維護中的分支或替代套件；加測試確保相容。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q13, D-Q10

---

### Q&A 類別 D: 問題解決類

D-Q1: Dijkstra 只回傳距離，如何取得完整路徑？
- A簡: 以 Visitor/回呼記錄前驅，或修改原始碼在鬆弛時保存 predecessor 後回溯。
- A詳: 症狀：只能讀到 Weight，缺路徑序列。原因：實作僅輸出結果圖未保存前驅。解法：1) 擴充演算法，鬆弛成功時記錄 predecessor[v]=u；2) 或使用 IVisitor/委派收集事件；3) 計算後由目標回溯。預防：封裝成工具方法，統一產出距離與路徑。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q9, B-Q10, C-Q5

D-Q2: 存在負權重導致結果錯誤怎麼辦？
- A簡: Dijkstra 不適用負權，改用 Bellman-Ford/重新建模，移除或轉換負權。
- A詳: 症狀：計算結果與手算不符。原因：負權破壞貪婪正確性。解法：1) 檢查資料來源，避免負權；2) 若不可避免，改用 Bellman-Ford；3) 若有負環需特別處理。預防：資料驗證與單元測試；在建模層禁止負權輸入。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q19, C-Q9

D-Q3: 路徑不存在（無法到達）如何診斷？
- A簡: 檢查圖連通性、是否遺漏邊、方向設置錯誤或資料輸入不完整。
- A詳: 症狀：目標 Weight 為無限或查無路徑。原因：孤立節點、缺邊、有向邊方向錯、名稱不匹配。解法：1) 列印圖統計與鄰接；2) 驗證有向邊是否雙向必要；3) 加入缺邊；4) 修正命名。預防：在測試中加入連通性檢查與資料校驗。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q1, C-Q4, D-Q7

D-Q4: SortedList Key 重複拋例外怎麼辦？
- A簡: 保證鍵唯一；改用字典對應 List 或使用 Lookup 結構以支援一鍵多值。
- A詳: 症狀：插入時 ArgumentException。原因：鍵不可重複。解法：1) 插入前 ContainsKey 檢查；2) 需求為多值時，改用 Dictionary<TKey,List<T>>；3) 或使用 Lookup/IGrouping。預防：設計鍵值規則，撰寫插入包裝方法。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, B-Q12

D-Q5: 納入通行費後結果不合理如何排查？
- A簡: 檢查費用加邊方向、是否重複計費、單位一致與資料邊遺漏。
- A詳: 症狀：成本顯著偏高/偏低。原因：費用疊加錯誤、方向費用套錯、單位換算錯、遺漏邊。解法：1) 列印每條邊權重；2) 以測試圖驗證；3) 檢查方向性費率表；4) 確認無重複加費。預防：統一定義成本模型，加入資料驗證。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q3, C-Q9

D-Q6: 計算效率不佳時如何優化？
- A簡: 使用優先佇列、降低圖規模、快取重算、避免頻繁記錄過重訪問。
- A詳: 症狀：運行時間長。原因：未用優先佇列、資料結構低效、過多日誌/訪客操作。解法：1) 以 PriorityQueue 優化；2) 精簡訪客邏輯；3) 預先裁剪圖；4) 結果快取。預防：基準測試與剖析，選擇合適資料結構。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q13, B-Q15, C-Q8

D-Q7: 名稱對應錯誤導致 GetVertex 為 null？
- A簡: 統一命名規則與比較器，檢查資料來源大小寫與空白差異。
- A詳: 症狀：GetVertex 拋例外或回傳 null。原因：名稱大小寫、全形半形、前後空白、編碼差異。解法：1) 正規化名稱；2) 使用自定 Comparer；3) 建立字典索引；4) 加入輸入驗證。預防：資料進入點規範化。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q7, C-Q1, D-Q3

D-Q8: 文件缺乏複雜度資訊如何評估效能？
- A簡: 讀原始碼辨識結構、撰寫基準測試、以理論複雜度作對照。
- A詳: 症狀：無法判定效能瓶頸。原因：文件未標註複雜度。解法：1) 閱讀演算法內部用到的資料結構；2) 撰寫 micro-benchmark；3) 比對理論值與實測；4) 用 profiler 找熱點。預防：建立效能驗收標準與測試管線。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q13, B-Q13, C-Q9

D-Q9: 方向建模錯誤導致南北向混淆怎麼辦？
- A簡: 明確使用有向圖，為雙向分別建邊並附方向性費用與約束。
- A詳: 症狀：最短路徑錯走或費用錯。原因：使用無向邊或未分別設定兩方向權重。解法：1) 改 Graph(true)；2) 為 A→B 與 B→A 分別設權重；3) 測試單向封閉與費率差。預防：資料模型包含方向欄位與驗證。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q14, C-Q4, C-Q3

D-Q10: CodePlex 已封存或版本相容性問題如何處理？
- A簡: 尋找維護中鏡像/分支或替代套件，鎖定版本，加測試確保相容。
- A詳: 症狀：來源無法取得或與新 .NET 不相容。解法：1) 尋 GitHub 鏡像或社群分支；2) 嘗試升級編譯；3) 若阻礙過大，採替代庫；4) 建立回歸測試保護功能。預防：鎖定套件版本，維護私有鏡像。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: C-Q10, A-Q13

---

### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是 NGenerics？
    - A-Q2: 為什麼選擇 NGenerics 而非自行實作資料結構？
    - A-Q3: NGenerics 支援哪些資料結構？
    - A-Q4: NGenerics 包含哪些演算法類別？
    - A-Q5: 什麼是 Graph<T>？適合哪些應用？
    - A-Q7: Dijkstra 演算法是什麼？用於何處？
    - A-Q10: 最短路徑與最小生成樹有何差異？
    - A-Q11: 為什麼 SortedList 的 Key 不能重複？
    - A-Q12: 為何 ICollection/IEnumerable 等介面重要？
    - A-Q14: 有向圖與無向圖差異為何？
    - A-Q16: 高速公路路網如何對應圖的元素？
    - C-Q1: 如何用 NGenerics 建立高速公路無向圖？
    - C-Q2: 如何查詢兩點之間的最短路徑成本？
    - D-Q3: 路徑不存在（無法到達）如何診斷？
    - D-Q4: SortedList Key 重複拋例外怎麼辦？

- 中級者：建議學習哪 20 題
    - B-Q1: NGenerics 的 Graph<T> 如何表示節點與邊？
    - B-Q2: AddVertex 與 AddEdge 在 Graph<T> 中如何運作？
    - B-Q3: GraphAlgorithms.DijkstrasAlgorithm 如何運作？
    - B-Q4: Dijkstra 為何要求非負邊權重？
    - B-Q5: Kruskal 演算法的機制與流程是什麼？
    - B-Q6: Prim 演算法的機制與流程是什麼？
    - B-Q7: 在 NGenerics 中如何表示有向邊？
    - B-Q8: 如何把節點通行費用納入權重計算的機制？
    - B-Q9: GraphAlgorithms 回傳「結果圖」的設計考量是什麼？
    - B-Q15: BinaryHeap/PriorityQueue 在圖演算法扮演何角色？
    - B-Q16: 如何由結果圖回推出最短距離值？
    - B-Q19: Dijkstra 與 BFS 的差異與適用時機？
    - C-Q3: 如何把收費站費用加入邊權重？
    - C-Q4: 如何將無向圖改為有向圖處理不同方向收費？
    - C-Q8: 如何用 PriorityQueue 優化 Dijkstra？
    - C-Q9: 如何為圖資料輸入撰寫單元測試？
    - D-Q1: Dijkstra 只回傳距離，如何取得完整路徑？
    - D-Q5: 納入通行費後結果不合理如何排查？
    - D-Q6: 計算效率不佳時如何優化？
    - D-Q9: 方向建模錯誤導致南北向混淆怎麼辦？

- 高級者：建議關注哪 15 題
    - A-Q13: NGenerics 文件有哪些限制？如何彌補？
    - A-Q17: 為什麼要把收費站費用併入邊權重？
    - A-Q18: 使用 Dijkstra 的核心價值是什麼？
    - A-Q19: 使用開源函式庫學習資料結構有何價值？
    - B-Q10: 以 Visitor/Delegate 擴充取得走訪資訊的原理？
    - B-Q13: NGenerics 的 Dijkstra 複雜度與影響因素？
    - B-Q14: 如何在 NGenerics 中使用自定義 Comparer？
    - B-Q17: Graph 中 Weight 欄位的意義是什麼？
    - B-Q20: 最短路徑樹與最小生成樹有何技術差異？
    - C-Q5: 如何擴充 Dijkstra 以輸出完整路徑？
    - C-Q6: 如何使用 IVisitor 記錄走訪順序與事件？
    - C-Q7: 如何用自定義 Comparer 定義頂點識別規則？
    - C-Q10: 如何從原始碼編譯與引用 NGenerics？
    - D-Q2: 存在負權重導致結果錯誤怎麼辦？
    - D-Q10: CodePlex 已封存或版本相容性問題如何處理？