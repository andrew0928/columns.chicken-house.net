---
layout: synthesis
title: "令人火大的 SQL 字元編碼..."
synthesis_type: faq
source_post: /2008/09/27/frustrating-sql-character-encoding/
redirect_from:
  - /2008/09/27/frustrating-sql-character-encoding/faq/
---

# 令人火大的 SQL 字元編碼...

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是字元編碼（Character Encoding）？
- A簡: 字元編碼將文字映射為位元與碼點，供儲存、顯示與跨系統傳輸使用。
- A詳: 字元編碼是把人類可讀的文字對應到電腦可處理的位元序列與碼點的規則，如 UTF-8、UTF-16、Big5 等。當資料跨系統、跨資料庫傳輸時，來源與目的若使用不同編碼，就可能造成亂碼、問號或資料被替換。正確選擇與一致化編碼，是跨平台資料交換的基礎工作。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q6, B-Q7

A-Q2: 什麼是 Unicode？為何重要？
- A簡: Unicode以統一碼點涵蓋多語言，消除跨系統編碼不一致問題。
- A詳: Unicode是一套全球通用的文字編碼標準，以碼點統一描述各語言字元，常見儲存型式為 UTF-16（SQL Server nvarchar）與 UTF-8（部分平台）。在多語言、跨系統資料交換時，採用 Unicode 可避免 Big5、GBK 等區域編碼互轉所致的遺失或替換，對中文正確性尤為關鍵。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q20, B-Q13

A-Q3: Unicode 與非 Unicode（碼頁）資料型別有何差異？
- A簡: Unicode（nchar/nvarchar）固定兩位元組，非 Unicode（char/varchar）依碼頁儲存。
- A詳: 在 SQL Server，nchar/nvarchar 使用 UCS-2/UTF-16 儲存，跨語系安全；char/varchar 依資料庫或連線碼頁儲存，對中文依賴正確碼頁（如 Big5）。跨系統或連結伺服器搬運資料時，非 Unicode 欄位極易因碼頁不符產生亂碼或問號，建議優先使用 Unicode 型別。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, B-Q13, C-Q4

A-Q4: SQL Server 的 nchar/nvarchar/ntext 是什麼？
- A簡: 皆為 Unicode 儲存；ntext 已淘汰，建議用 nvarchar(max) 取代。
- A詳: nchar/nvarchar 是 Unicode 字串型別，適合跨語系。ntext 曾用於大量 Unicode 文字，但已被標示為淘汰，官方建議使用 nvarchar(max) 取代，具更佳相容與功能。選用正確型別能降低跨系統轉碼風險，並避免舊型別在某些提供者或驅動上的邊際相容問題。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q19, C-Q2, D-Q6

A-Q5: 什麼是定序（Collation）？
- A簡: 定序決定字串排序、比較與區分方式，含語系、大小寫等規則。
- A詳: Collation 是資料庫字串比較與排序的規則集合，包含語系、音序/筆畫、大小寫、重音敏感等。它不等於編碼，但會影響比較與 JOIN 行為。跨資料庫或連結伺服器時，如定序不一致，可能造成比較錯誤或需顯式 COLLATE 轉換，亦影響型別推導。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q12, D-Q7

A-Q6: 編碼與定序有何差異與關聯？
- A簡: 編碼管儲存位元表示，定序管比較排序規則，兩者不同層次。
- A詳: 編碼解決字如何變成位元；定序決定字如何比較與排序。兩者常被混淆：編碼不符會亂碼或?；定序不符多半是排序/比較不預期或需 COLLATE。跨系統資料搬運須先統一編碼，再處理定序一致，才能避免雙重問題。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q2, C-Q7

A-Q7: 什麼是 Linked Server（連結伺服器）？
- A簡: 讓 SQL Server 透過提供者存取遠端資料來源，進行跨庫查詢。
- A詳: Linked Server 是 SQL Server 透過 OLE DB/ODBC 提供者，存取外部 SQL Server 或其他資料源（Oracle、Excel）的機制。它允許四部份名稱或 OPENQUERY 做跨源查詢，牽涉提供者轉碼、定序與型別對應，錯誤配置易導致中文亂碼或相容性問題。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q1, C-Q6

A-Q8: 什麼是 SELECT INTO？與一般 SELECT 差在哪？
- A簡: SELECT INTO 依查詢推導欄位型別，新建表並插入資料。
- A詳: SELECT INTO 會依查詢結果的型別推導建立新表架構，省去事先建表。但推導規則受來源型別、表達式、提供者影響，跨 Linked Server 時若轉碼或長度推導不當，可能造成截斷、亂碼或邊緣缺陷。謹慎使用或改為預建表更安全。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q2, D-Q2

A-Q9: 什麼是中繼資料庫（Staging/暫存區）？
- A簡: 於來源與目的間的緩衝層，統一清洗、轉型與校驗資料。
- A詳: 中繼資料庫位於資料交換流程的中間層，用來從來源擷取資料後，進行清洗、標準化、轉型與稽核，再匯入目標系統。它可隔離來源差異（編碼、定序、欄位型別）並提供可追溯與回滾能力，降低跨系統整合風險。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q2, D-Q10, B-Q11

A-Q10: 什麼是緩衝區溢位（Buffer Overflow）的資料症狀？
- A簡: 緩衝未清或越界，可能讓上一筆殘留字串混入輸出結果。
- A詳: 在字串處理中若終止符或長度管理失當，會出現越界讀寫或重用舊記憶體，導致「上一筆資料殘影」等錯亂。文章案例推測 SELECT INTO 經由提供者路徑出現此類症狀，而直接 SELECT 正常，顯示可能是特定執行路徑缺陷而非純編碼不符。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, D-Q2, B-Q24

A-Q11: 什麼是 SQL Native Client？
- A簡: 微軟提供的 SQL Server 存取驅動，負責通訊與型別轉換。
- A詳: SQL Native Client 是 SQL Server 的原生 OLE DB/ODBC 驅動，負責網路傳輸、型別對應與字元轉碼。其版本與修補程式會影響跨伺服器查詢、Unicode/碼頁轉換的穩定性。某些罕見錯誤可能來自驅動而非伺服器本身。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, D-Q9, A-Q7

A-Q12: 為何編碼不符會出現亂碼或問號？
- A簡: 像碼頁對不上會映射錯誤，無對應字元常變成問號替代。
- A詳: 當來源與目的使用不同碼頁，位元序列被誤解讀為錯誤碼點，呈現亂碼；若轉換時找不到對應字元，常以問號或替代字元顯示。這屬於轉碼問題，與出現「上一筆殘影」的溢位症狀不同，診斷時需切分兩者。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q6, D-Q1, D-Q3

A-Q13: 為什麼有時不升級而採取繞道解法？
- A簡: 環境限制或維運政策不允許更新，只能工程化避開風險。
- A詳: 現場常受委外、變更凍結或合規限制，難以立即升級驅動或套用修補。此時以顯式轉型、預建表、游標序列化搬運等方法繞過缺陷，能快速恢復正確性。日後再規劃升級與驗證，兼顧穩定與進度。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: D-Q10, C-Q3, B-Q26

A-Q14: 資料破壞與顯示亂碼有何差別？
- A簡: 顯示亂碼多為呈現層錯誤；資料破壞是儲存即錯且難復原。
- A詳: 顯示亂碼通常在傳輸或呈現層誤解編碼，原始儲存值仍可還原；資料破壞則是錯誤值已寫入資料表，如「上一筆殘影」或被截斷，難以自動修復。處理策略不同：前者調整轉碼即可，後者需回溯來源重灌或比對修補。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: D-Q3, D-Q2, C-Q5

A-Q15: 為何轉成 ntext/nvarchar 能暫解中文亂碼？
- A簡: 強制使用 Unicode 儲存，避免碼頁誤解導致亂碼或問號。
- A詳: 以 CAST/CONVERT 將來源文字強制轉為 nvarchar/ntext，可在提供者層就採用 Unicode 管道，避開碼頁轉換；這常能消除?或亂碼。惟 ntext 已淘汰，建議使用 nvarchar(max)。此外，此法無法處理驅動溢位等缺陷，需另行繞道。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q13, C-Q1, C-Q4

A-Q16: 為何選擇游標（Cursor）作為繞道？
- A簡: 游標序列化搬運與顯式變數接值，迴避批次推導與驅動缺陷。
- A詳: 在案例中，直接 SELECT INTO 會出現疑似緩衝問題；改用游標 FETCH 到 nvarchar 變數，再 INSERT/UPDATE 回目標，可避開問題路徑。雖犧牲效能，但易於控制型別與長度，快速恢復正確性，適合權宜處置。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q3, D-Q5, B-Q9

A-Q17: 什麼是批次（Batch）與暫存表？
- A簡: 批次為一次送出的 SQL 區塊；暫存表存在 tempdb 供中途存放。
- A詳: 批次是同時提交的 SQL 陳述集合，具作用域。暫存表（#table）在 tempdb 建立，生命週期限於連線或批次，用於中間計算或搬運。SELECT INTO 若在不同批次或 tempdb 上，有型別推導與定序細節需留意。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, B-Q16, C-Q2

A-Q18: 什麼是字串結尾 0x00（NUL）與其影響？
- A簡: NUL 作為終止符，管理字串界線；處理失當會越界或殘留。
- A詳: 多數底層 API 以 NUL 作字串終止，或以長度欄位界定。若終止處理或長度計算出錯，就可能讀到前一筆殘留、越界或截斷。疑似溢位案例常見於提供者或驅動的 C 風格處理邏輯錯誤。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, B-Q15, D-Q2

A-Q19: 什麼是 Service Pack/Hotfix 在 SQL 的角色？
- A簡: 修補已知缺陷與相容性問題，含伺服器與用戶端驅動更新。
- A詳: Service Pack、Cumulative Update 與 Hotfix 提供功能修正、效能改良與錯誤修補，涵蓋 SQL Server 與其客戶端驅動。對於罕見的提供者缺陷或轉碼問題，更新往往是根本解，但需遵循變更控管與回滾規畫。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q20, D-Q9, D-Q10

A-Q20: 為何跨系統中文資料建議全面採 Unicode？
- A簡: 可移除碼頁依賴，穩定跨平台傳輸與儲存正確性。
- A詳: Unicode 在儲存與通訊層一致化字元表示，能避免 Big5、GBK 等轉碼陷阱，特別是在 Linked Server、ETL 與資料湖情境。全鏈路用 nvarchar/UTF-8 可顯著降低亂碼、替代字元與截斷風險，提升長期維運效率。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, C-Q2, B-Q11

A-Q21: SELECT 與 SELECT INTO 的風險差異？
- A簡: SELECT INTO 伴隨型別推導與隱含轉換風險；直接 SELECT 較安全。
- A詳: 直接 SELECT 僅讀取並呈現資料；SELECT INTO 會新建表，型別與長度由查詢結果推導，受提供者、表達式與定序影響。跨來源情境若推導不當，可能造成錯誤儲存。預建表並顯式 CAST/CONVERT 通常更穩定。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, D-Q2, C-Q2

A-Q22: 什麼是 OLE DB/ODBC 提供者在 Linked Server 的角色？
- A簡: 負責連線、型別對應與轉碼，影響跨源查詢的正確性。
- A詳: Linked Server 倚賴提供者將遠端資料型別與字元編碼映射到本地 SQL Server。不同提供者對文字型別（text/ntext vs nvarchar(max)）與碼頁處理差異大，版本修補亦重要。選擇與設定提供者是跨庫正確性的關鍵。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, B-Q7, C-Q6

A-Q23: 為何「不升級」時需工程化降低風險？
- A簡: 以顯式轉型、預建表與序列化流程，縮減不確定性。
- A詳: 當更新受限，必須將不確定的推導與隱式轉換移除：預先定義欄位型別、強制使用 Unicode、在 SELECT 明確 CAST/CONVERT、必要時採游標序列化。並建立驗證與回滾程序，確保品質可控。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, C-Q3, D-Q10

A-Q24: NVARCHAR(MAX) 與 TEXT/NTEXT 的取代關係？
- A簡: nvarchar(max) 取代 text/ntext，功能更完整且相容性較佳。
- A詳: TEXT/NTEXT 已被標示淘汰；nvarchar(max) 提供等量能且更好函式支援、ANSI 相容與儲存彈性。跨提供者相容性也更佳，能減少文字大型欄位在連結伺服器上的邊際問題，建議全面汰換。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q19, C-Q2, D-Q6

A-Q25: 為什麼要建立最小可重現（Minimal Repro）？
- A簡: 快速鎖定責任與原因，便於回報、比對與修補驗證。
- A詳: 由多到少地刪減腳本，保留能穩定重現問題的最小步驟與資料，可清楚隔離責任邊界（伺服器、提供者或腳本），加速支援單位判斷。也便於嘗試替代路徑（CAST、預建表、游標）驗證有效性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q18, D-Q9, C-Q8

A-Q26: 外包分工下如何界定責任與證據？
- A簡: 以重現腳本、版本資訊與比較結果，建立可驗證證據鏈。
- A詳: 蒐集來源與目的版本、提供者/驅動版本、定序與連線設定；建立可重現腳本與對照結果（含截圖或雜湊比對），並證明繞道可解。據此明確提出疑似缺陷位置，降低踢皮球情況，促成有效修補或變通。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q25, D-Q9, C-Q8

---

### Q&A 類別 B: 技術原理類

B-Q1: 連結伺服器跨庫查詢的資料流如何運作？
- A簡: 本地透過提供者取遠端資料，進行型別映射與轉碼再回傳。
- A詳: 本地 SQL Server 解析查詢，將涉及遠端的部分委派給 Linked Server 提供者（OLE DB/ODBC）。提供者在遠端執行或擷取資料，進行型別映射與字元轉碼（碼頁或 Unicode），再回傳給本地執行計畫整合。任何映射、長度與終止處理的瑕疵，都可能在此階段出錯。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, A-Q22, B-Q10

B-Q2: 不同定序間的比較與轉換機制是什麼？
- A簡: 以 COLLATE 指定規則或隱含轉換至共同定序再比較排序。
- A詳: SQL Server 比較不同定序的字串時，可能發生衝突。可用 COLLATE 明確宣告欄位或運算式的定序，或讓系統隱含轉換至資料庫預設定序再比較。定序影響排序行為、不影響底層編碼，但在型別推導與索引使用上可能產生成本。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q6, C-Q7

B-Q3: SELECT INTO 的目標欄位型別如何推導？
- A簡: 依來源型別、表達式與提供者回報，決定長度與Unicode與否。
- A詳: 推導邏輯綜合欄位型別、函式結果、常值、CASE 分支與提供者的元資料回報。跨 Linked Server 若提供者將文字回報為非 Unicode 或長度不足，SELECT INTO 會建錯型別/長度，埋下截斷或亂碼風險。預建表可避免此不確定性。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q8, A-Q21, C-Q2

B-Q4: 隱含轉型與截斷錯誤的機制？
- A簡: 引擎在比較/插入時自動轉型，長度不足則截斷或錯誤。
- A詳: 當將來源字串插入較短或不同型別欄位時，SQL 會執行隱含轉型；若無法容納，可能截斷（有時靜默）或拋錯。跨碼頁轉換也可能因無對應字元改為?。顯式 CAST/CONVERT 與預建足夠長度欄位可降低風險。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q1, C-Q2, D-Q8

B-Q5: 為何用 NVARCHAR 變數接值可矯正搬運？
- A簡: 變數以 Unicode 保持正確碼點，再寫回目標欄位。
- A詳: 游標 FETCH 將提供者輸出先放入 nvarchar 變數，等於在 T-SQL 邊界採用 Unicode 接口，避免中途碼頁與終止處理的不確定性。再由變數 INSERT/UPDATE 至 Unicode 欄位，縮短經過風險路徑，故能改善異常。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, C-Q3, D-Q2

B-Q6: 緩衝區重用與終止錯置如何導致上一筆殘影？
- A簡: 違反長度/終止協議，導致讀取超出界線，殘留混入下一筆。
- A詳: 若提供者或驅動未清緩衝或終止符放置錯誤，接收端按長度讀取時會越界，前一筆較長字串的尾端可能殘留到新資料。此症狀與亂碼不同，常出現在特定執行路徑（如 SELECT INTO）且間歇發生，屬實作缺陷特徵。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q10, A-Q18, D-Q2

B-Q7: SQL Native Client 的轉碼流程與碼頁處理？
- A簡: 依連線屬性與欄位型別決定 Unicode/碼頁轉換與長度。
- A詳: 驅動會根據來源欄位型別、伺服器定序與連線環境，決定以 UCS-2/UTF-16 或特定碼頁傳輸。也負責長度上限與緩衝管理。版本不同對 text/ntext、varchar 與 nvarchar(max) 的處理差異顯著，影響正確性與效能。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q11, A-Q24, B-Q10

B-Q8: 無專業工具時如何定位編碼問題？
- A簡: 比較直接 SELECT 與 SELECT INTO；加上顯式 CAST 與預建表。
- A詳: 先對照原始 SELECT 與 SELECT INTO 結果；加入 CAST/CONVERT 為 nvarchar；改用預建表；再嘗試游標序列化。藉由改變路徑觀察變化，可判斷是轉碼、推導、或驅動層次缺陷。最終收斂為最小重現以利回報。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q25, C-Q8, D-Q9

B-Q9: 游標 FETCH 的內部流程與界線控制？
- A簡: 以行為單位搬運資料，欄位值裝載至變數緩衝後寫出。
- A詳: 游標逐行從結果集抓取，使用類型化緩衝存放各欄位，T-SQL 變數提供明確長度與型別界線。此模式可避開批次推導與大緩衝共用的問題，但代價是 CPU 與 I/O 次數增加，需控制批量與索引。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, C-Q3, D-Q5

B-Q10: 提供者在 Linked Server 的轉碼角色為何？
- A簡: 決定文字型別映射與傳輸格式，影響 Unicode 正確性。
- A詳: OLE DB/ODBC 提供者負責將遠端型別轉為本地理解的型別，並決定以 Unicode 或碼頁傳。對 text/ntext 與大型物件的支援度、長度上限與終止處理各異。選擇合適提供者與版本，是跨源中文正確的關鍵。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q22, B-Q7, D-Q9

B-Q11: 如何設計中繼表以避免轉碼風險？
- A簡: 全面使用 nvarchar(max)，指定目標 COLLATE，避免推導。
- A詳: 預建中繼表，文字欄位改用 nvarchar(n)/nvarchar(max)，並統一 COLLATE（多用 DATABASE_DEFAULT 或目標語系）。以 INSERT...SELECT 並在 SELECT 顯式 CAST，避免 SELECT INTO 推導失誤，降低截斷與亂碼。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q2, C-Q1, A-Q20

B-Q12: COLLATE 子句覆寫定序的原理？
- A簡: 在運算式/欄位層級臨時套用指定定序進行比較或投影。
- A詳: COLLATE 可在查詢中對個別欄位/字面值指定定序，用於 JOIN/ORDER BY/SELECT 投影，以解決跨定序比較與排序問題。它不改變實際儲存編碼，但會影響索引可用性與估計選擇性，需審慎使用。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, C-Q7, D-Q7

B-Q13: CAST/CONVERT 強制 Unicode 的機制？
- A簡: 以 nvarchar 目標型別投影輸出，建立 Unicode 傳輸路徑。
- A詳: 在 SELECT 中 CAST/CONVERT 欄位為 nvarchar(n)/nvarchar(max)，強制提供者輸出 Unicode，避免碼頁轉換。此舉也影響 SELECT INTO 的型別推導，利於建立正確的 Unicode 目標欄位。仍需確保長度足夠。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q1, C-Q4, A-Q15

B-Q14: SELECT、INSERT...SELECT 與 SELECT INTO 的差異？
- A簡: 前兩者不改目標架構；SELECT INTO 會新建表且靠推導。
- A詳: 直接 SELECT 僅讀；INSERT...SELECT 將資料寫入已存在表，型別由目標表決定；SELECT INTO 同時新建與插入，風險在型別/長度推導。跨來源時，偏好 INSERT...SELECT 配合顯式 CAST 可降低不確定性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q21, C-Q2

B-Q15: 0x00 終止對定長/變長與 Unicode 的影響？
- A簡: 變長字串多依長度；Unicode 雙位元；終止失當仍致越界。
- A詳: 多數 API 對變長字串以長度為準，但也會保留終止。Unicode 使用寬字元，終止符需正確對齊；若處理錯，可能跨界讀到前一筆殘留。定長型別（char/nchar）填充空白也影響終止處理與比對。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q18, B-Q6, D-Q2

B-Q16: tempdb 與暫存表架構產生流程？
- A簡: SELECT INTO 在 tempdb 建表，依元資料推導欄位屬性。
- A詳: 當執行 SELECT INTO #t，SQL 在 tempdb 依查詢結果元資料建表。跨 Linked Server 時，元資料由提供者回報，若有差錯會建出錯誤型別或長度。這解釋直接 SELECT 正常、SELECT INTO 出錯的可能性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, B-Q3, D-Q2

B-Q17: 如何以觀察法判定疑似驅動缺陷？
- A簡: 比較不同路徑：SELECT 正常、INTO 出錯、游標恢復。
- A詳: 若同一來源資料：直接 SELECT 正確；SELECT INTO 出現殘影；改游標+變數後恢復，即顯示問題集中在某條執行路徑與提供者互動。再以最小重現與版本比對，強化缺陷假設。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q25, D-Q9, C-Q9

B-Q18: 建立最小重現的迭代策略？
- A簡: 逐步刪減語句與資料量，只留能穩定重現的關鍵步驟。
- A詳: 從原批次中去除非必要語句、改小資料集、固定字串長度、將 SELECT INTO 單獨抽出；以二分法定位有無 CAST/COLLATE 差異的關鍵條件。最終產生十數行可重現腳本，利於提交支援與內部溝通。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q25, C-Q8, D-Q9

B-Q19: TEXT/NTEXT 儲存與 TEXT IN ROW？
- A簡: 預設離頁儲存，TEXT IN ROW 可內嵌；相容性與函式受限。
- A詳: TEXT/NTEXT 多數離頁儲存，指標存在資料列；TEXT IN ROW 可將小於門檻的內容內嵌，減少 I/O。但這些型別函式支援少、相容性差，跨提供者更易踩邊緣問題。建議改用 varchar(max)/nvarchar(max)。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q24, D-Q6, C-Q2

B-Q20: 更新與修補如何修正提供者/伺服器錯誤？
- A簡: 新版修正已知缺陷，改善轉碼、長度與終止處理。
- A詳: 微軟會在 CU/SP 修正文字處理、提供者相容性與崩潰問題。升級 SQL Server 與 Native Client 能移除已知缺陷。但需驗證回歸風險、擬定回滾並在預備環境先行壓測。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q19, D-Q9, D-Q10

B-Q21: 中英混合與全形半形在定序的處理？
- A簡: 定序決定比較/排序規則，可能影響相等性與索引使用。
- A詳: 某些定序對全形/半形、重音敏感度不同，導致比較結果差異，進而影響 JOIN 命中與索引選擇。雖不直接造成亂碼，但在跨系統比對時需統一，避免資料落差或非預期排序。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q12, C-Q7

B-Q22: 雜湊/校驗如何驗證搬運完整性？
- A簡: 以 HASH/Checksum 比對來源與目的字串是否一致。
- A詳: 使用 HASHBYTES、CHECKSUM 或自訂 CRC 對來源與目的產生摘要，比對可快速檢知差異。對文字欄位建對照表，能量化錯誤比例，用於驗收與回滾判斷。注意不同定序/大小寫敏感可能影響結果。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q5, C-Q9, D-Q10

B-Q23: 集批與流式傳輸差異？
- A簡: 集批快但風險集中；流式安全但較慢，適用繞道場合。
- A詳: 集批（批量 INSERT/SELECT INTO）效率高，但依賴推導與提供者穩定；流式（游標/分批）以較小單位處理，便於驗證與回滾，降低單次錯誤影響。實務上可先流式驗證，再以集批接棒。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, C-Q3, D-Q5

B-Q24: 「上一筆資訊殘留」的診斷意義？
- A簡: 指向緩衝/終止處理缺陷，而非單純編碼或定序問題。
- A詳: 若錯誤呈現與上一筆資料高度關聯，尤其字串尾段重複，代表可能是緩衝清理或終止位錯。這與碼頁不符引起的亂碼樣態不同，對應的解法也不同（繞道/升級而非調碼頁）。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q10, B-Q6, D-Q2

B-Q25: 驗證碼頁與定序組合的影響？
- A簡: 替換不同碼頁/定序測試輸出，觀察是否僅影響呈現。
- A詳: 藉由更換連線碼頁、COLLATE 與 CAST 到 nvarchar 的組合測試，若錯誤型態改變為?或正常，則偏向轉碼問題；若仍殘影，則指向緩衝缺陷。此 A/B 測試有助快速縮小問題域。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q9, D-Q1

B-Q26: 何時應優先升級而非繞道？
- A簡: 當錯誤可重現且影響面廣、難以用繞道保障效能時。
- A詳: 若錯誤遍及多表、資料量大、游標繞道過慢或需長期維運，且已有公共修補，應評估升級。繞道可暫解，但無法長期承擔風險與成本；升級前需備份、回滾方案與完整測試。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q13, A-Q19, D-Q10

---

### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何透過 Linked Server 正確 SELECT 到中繼表，保留中文？
- A簡: 在 SELECT 明確 CAST 成 nvarchar，並 INSERT 到預建 Unicode 表。
- A詳: 
  - 實作步驟: 先建立目標表欄位為 nvarchar(n/max)；SELECT 時對文字欄位 CAST/CONVERT 成 nvarchar；INSERT...SELECT 寫入。
  - 程式碼片段: 
    CREATE TABLE dbo.StgT(col1 NVARCHAR(200), col2 NVARCHAR(MAX));
    INSERT dbo.StgT(col1,col2)
    SELECT CAST(col1 AS NVARCHAR(200)), CAST(col2 AS NVARCHAR(MAX))
    FROM OPENQUERY(LS, 'SELECT col1,col2 FROM dbo.Src');
  - 注意: 確認長度足夠、避免 SELECT INTO 推導；驗證定序與效能。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q13, B-Q11, A-Q20

C-Q2: 如何預先建立中繼表避免 SELECT INTO 推導錯誤？
- A簡: 明確定義 nvarchar 與 COLLATE，使用 INSERT...SELECT 搬運。
- A詳: 
  - 步驟: 設計欄位長度；使用 NVARCHAR(MAX) 取代 NTEXT；指定 COLLATE DATABASE_DEFAULT。
  - 程式碼:
    CREATE TABLE dbo.Stg(colA NVARCHAR(100) COLLATE DATABASE_DEFAULT, colB NVARCHAR(MAX));
    INSERT dbo.Stg SELECT CAST(colA AS NVARCHAR(100)), CAST(colB AS NVARCHAR(MAX)) FROM ...
  - 注意: 用雜湊比對完整性；建立索引以維持效能。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q3, A-Q24, B-Q14

C-Q3: 如何用游標逐筆搬運以避開驅動缺陷？
- A簡: FETCH 至 nvarchar 變數後 INSERT/UPDATE，序列化管道確保正確。
- A詳: 
  - 步驟: 宣告游標；定義 NVARCHAR 變數；FETCH 每列；寫入目標。
  - 程式碼:
    DECLARE c CURSOR FOR SELECT CAST(col AS NVARCHAR(200)) FROM OPENQUERY(LS,'...');
    OPEN c; FETCH NEXT FROM c INTO @v; WHILE @@FETCH_STATUS=0 BEGIN INSERT dbo.Stg(col) VALUES(@v); FETCH NEXT FROM c INTO @v; END; CLOSE c; DEALLOCATE c;
  - 注意: 控制批量、加索引、監控效能；錯誤處理與重試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q9, D-Q5

C-Q4: 如何將舊 VARCHAR 欄位安全轉為 NVARCHAR？
- A簡: 新增新欄位或離峰 ALTER，並以顯式 CONVERT 搬遷資料。
- A詳:
  - 步驟: 先新增 NVARCHAR 欄位；UPDATE 以 CONVERT(NVARCHAR(n), oldCol)；驗證；再移除舊欄位或 ALTER COLUMN。
  - 程式碼:
    ALTER TABLE dbo.T ADD NewCol NVARCHAR(200);
    UPDATE dbo.T SET NewCol = CONVERT(NVARCHAR(200), OldCol);
    -- 驗證後 ALTER TABLE DROP COLUMN OldCol;
  - 注意: 長度規劃、索引/約束調整、維運時段。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q3, B-Q13, D-Q8

C-Q5: 如何偵測與修補已亂碼或被替換的資料？
- A簡: 以模式與雜湊比對找可疑列，回源重灌或手動修補。
- A詳:
  - 步驟: 以 LIKE '%?%' 或不可見字元檢出；與來源以 HASHBYTES 比對；列出差異。
  - 程式碼:
    SELECT * FROM dbo.T WHERE col LIKE N'%?%' OR col COLLATE Latin1_General_BIN LIKE '%�%';
  - 注意: 問號不等同亂碼全貌；最佳作法是回源重灌；建立修補日誌。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q22, A-Q14, D-Q3

C-Q6: 如何設定 Linked Server 與提供者選項降低風險？
- A簡: 選擇正確提供者，設定 Collation Compatible 與相關選項。
- A詳:
  - 步驟: sp_addlinkedserver 建立；sp_serveroption 設定 'collation compatible', 'data access'。
  - 程式碼:
    EXEC sp_serveroption 'LS','collation compatible','false';
  - 注意: 'collation compatible' 不當可能影響委派；評估提供者版本；先測再上線。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, B-Q10, D-Q7

C-Q7: 如何用 COLLATE 在查詢中強制定序？
- A簡: 對運算式/欄位附 COLLATE DATABASE_DEFAULT 或特定定序。
- A詳:
  - 步驟: 在 SELECT/JOIN/ORDER BY 對個別欄位指定 COLLATE。
  - 程式碼:
    SELECT a.col COLLATE DATABASE_DEFAULT FROM ...
    JOIN b ON a.col COLLATE Chinese_Taiwan_Stroke_90_CI_AS = b.col
  - 注意: 可能使索引失效；適度建立計算欄位或同化定序。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q12, A-Q5, D-Q7

C-Q8: 如何撰寫最小重現腳本供回報？
- A簡: 縮減至可重現的最少步驟與資料，附版本與設定資訊。
- A詳:
  - 步驟: 產生小型測試表與幾筆關鍵資料；單獨跑 SELECT、SELECT INTO；記錄版本、提供者、定序。
  - 程式碼: 提供 CREATE TABLE/INSERT/SELECT 範例。
  - 注意: 移除機敏資料；附執行結果截圖/比對，便於支援單位複製。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q25, B-Q18, D-Q9

C-Q9: 如何區分是編碼問題還是緩衝缺陷？
- A簡: 進行 A/B 測試：顯式 CAST、換路徑、觀察問號與殘影樣態。
- A詳:
  - 步驟: 比較直接 SELECT、SELECT INTO、游標；加 CAST 為 nvarchar；換提供者或連線。
  - 判準: 出現?多半是轉碼；出現上筆殘影傾向緩衝。
  - 注意: 混合問題需分階段處理；記錄每步輸出。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q25, B-Q24, D-Q2

C-Q10: 客戶拒絕升級時如何設計權宜方案與回滾？
- A簡: 採 Unicode 預建表、游標搬運、差異比對與可重跑流程。
- A詳:
  - 步驟: 預建 Unicode 架構；游標或分批 INSERT；以 HASH 比對；異常列隔離重跑。
  - 程式碼: 分批處理控制，例如 TOP(N)/OFFSET。
  - 注意: 紀錄/審計、重跑腳本、效能監控；中期仍規劃升級。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q23, B-Q23, D-Q10

---

### Q&A 類別 D: 問題解決類（10題）

D-Q1: 跨庫中文變成「???」怎麼辦？
- A簡: 問號多為碼頁不符，改用 Unicode 與顯式 CAST/CONVERT。
- A詳:
  - 症狀: 中文顯示為???或方塊，英文正常。
  - 可能原因: 碼頁對不上、非 Unicode 欄位、提供者轉碼。
  - 解決步驟: 將欄位 CAST 為 nvarchar；預建 Unicode 目標表；檢查連線碼頁。
  - 預防: 全鏈路採 Unicode；建立搬運前檢查。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q12, B-Q13, C-Q1

D-Q2: SELECT 正常但 SELECT INTO 後變成「上一筆殘影」？
- A簡: 疑似緩衝/提供者缺陷；改預建表或游標序列化搬運。
- A詳:
  - 症狀: 單筆資料混入前一筆字串片段。
  - 原因: 提供者元資料或終止處理錯誤、型別推導不當。
  - 解法: 改 INSERT...SELECT 至預建 Unicode 表；或游標 FETCH 至 nvarchar 變數後寫入。
  - 預防: 避免 SELECT INTO；升級驅動/套用修補。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q16, C-Q3

D-Q3: 透過 Linked Server 後中文亂碼但英數正常？
- A簡: 提供者碼頁轉換導致；強制 Unicode 與檢查定序。
- A詳:
  - 症狀: 中文亂碼、英數正確。
  - 原因: 碼頁不符、隱含轉型、定序混用。
  - 解法: SELECT 時 CAST 成 nvarchar；必要時 COLLATE 指定；預建表。
  - 預防: 統一 Unicode；制定跨庫標準。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q10, C-Q7

D-Q4: CAST 成 NVARCHAR 後仍少數列錯亂？
- A簡: 非純轉碼問題，可能緩衝缺陷；改游標或換提供者。
- A詳:
  - 症狀: 多數正確，少數出現殘影或凌亂字。
  - 原因: 提供者緩衝或終止處理瑕疵。
  - 解法: 游標 FETCH 到變數；換 SELECT 路徑（OPENQUERY/四部份名互測）；嘗試驅動更新。
  - 預防: 避用舊 TEXT/NTEXT；全程 nvarchar(max)。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q7, C-Q3

D-Q5: 游標搬運正確但太慢，如何優化？
- A簡: 批量處理、關鍵欄位索引與非同步分段，平衡正確與效能。
- A詳:
  - 症狀: 正確性好但耗時長。
  - 原因: 行為單位開銷高。
  - 解法: 每批固定 N 筆；僅欄位需搬運者；加索引減少掃描；非同步執行。
  - 預防: 仍以預建 Unicode 表優先；游標僅作暫解。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q23, C-Q3, C-Q10

D-Q6: 使用 NTEXT/TEXT 時發生相容性問題？
- A簡: 改用 NVARCHAR(MAX)/VARCHAR(MAX)，提升函式與提供者支援。
- A詳:
  - 症狀: 函式限制、提供者傳輸異常或截斷。
  - 原因: 舊型別支援差、行外儲存複雜。
  - 解法: 方案將欄位改為 nvarchar(max)；重新測試 Linked Server。
  - 預防: 新開發避免舊型別；制定淘汰計畫。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q24, B-Q19, C-Q2

D-Q7: 出現「Collation conflict」錯誤怎麼辦？
- A簡: 用 COLLATE 對齊比較欄位定序，或統一資料庫預設。
- A詳:
  - 症狀: JOIN/比較拋定序衝突錯誤。
  - 原因: 兩方定序不同。
  - 解法: 在 JOIN 條件或 SELECT 投影加 COLLATE；必要時調整資料庫/欄位定序。
  - 預防: 設計時統一定序；中繼表以 DATABASE_DEFAULT。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, B-Q12, C-Q7

D-Q8: 欄位長度不合造成截斷，如何處理？
- A簡: 擴充分配長度、明確 CAST 並加上資料驗證與日誌。
- A詳:
  - 症狀: 字串被截短或錯誤 2628/字符串截斷。
  - 原因: 推導長度不足；來源比目標長。
  - 解法: 擴大目標欄位長度；顯式 CAST 為足夠長度；預先檢查 LEN/STRING_AGG 回報異常。
  - 預防: 資料字典維護；ETL 前長度審核。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q4, C-Q2, C-Q1

D-Q9: 如何判斷是 SQL Server 還是驅動的問題？
- A簡: 比較不同驅動/版本與路徑結果，一致性指向責任層級。
- A詳:
  - 症狀: 只在特定路徑或版本出現錯誤。
  - 原因: 提供者/驅動或伺服器缺陷。
  - 解法: 測試不同 Native Client/ODBC/OLE DB；改用 OPENQUERY/四部份名稱；比較直接連線與 Linked Server；建立最小重現。
  - 預防: 錄製環境矩陣；版本控管與測試。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q11, B-Q17, C-Q8

D-Q10: 如何建立預防機制避免再踩雷？
- A簡: 制定 Unicode 標準、預建表、差異比對與升級策略。
- A詳:
  - 症狀: 重複出現字串問題。
  - 原因: 缺乏標準與檢核。
  - 解法: 標準化 Unicode；預建中繼表；搬運後做 HASH 比對；保留重跑機制；定期升級與回歸測試。
  - 預防: 需求到上線皆納入編碼/定序檢查表。
- 難度: 初級
- 學習階段: 進階
- 關聯概念: A-Q23, B-Q22, B-Q26

---

### 學習路徑索引

- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是字元編碼（Character Encoding）？
    - A-Q2: 什麼是 Unicode？為何重要？
    - A-Q3: Unicode 與非 Unicode（碼頁）資料型別有何差異？
    - A-Q4: SQL Server 的 nchar/nvarchar/ntext 是什麼？
    - A-Q5: 什麼是定序（Collation）？
    - A-Q6: 編碼與定序有何差異與關聯？
    - A-Q9: 什麼是中繼資料庫（Staging/暫存區）？
    - A-Q12: 為何編碼不符會出現亂碼或問號？
    - A-Q15: 為何轉成 ntext/nvarchar 能暫解中文亂碼？
    - A-Q20: 為何跨系統中文資料建議全面採 Unicode？
    - A-Q21: SELECT 與 SELECT INTO 的風險差異？
    - B-Q11: 如何設計中繼表以避免轉碼風險？
    - B-Q13: CAST/CONVERT 強制 Unicode 的機制？
    - C-Q1: 如何透過 Linked Server 正確 SELECT 到中繼表，保留中文？
    - D-Q1: 跨庫中文變成「???」怎麼辦？

- 中級者：建議學習哪 20 題
    - A-Q7: 什麼是 Linked Server（連結伺服器）？
    - A-Q8: 什麼是 SELECT INTO？與一般 SELECT 差在哪？
    - A-Q11: 什麼是 SQL Native Client？
    - A-Q14: 資料破壞與顯示亂碼有何差別？
    - A-Q16: 為何選擇游標（Cursor）作為繞道？
    - A-Q17: 什麼是批次（Batch）與暫存表？
    - B-Q1: 連結伺服器跨庫查詢的資料流如何運作？
    - B-Q2: 不同定序間的比較與轉換機制是什麼？
    - B-Q3: SELECT INTO 的目標欄位型別如何推導？
    - B-Q4: 隱含轉型與截斷錯誤的機制？
    - B-Q14: SELECT、INSERT...SELECT 與 SELECT INTO 的差異？
    - B-Q16: tempdb 與暫存表架構產生流程？
    - C-Q2: 如何預先建立中繼表避免 SELECT INTO 推導錯誤？
    - C-Q3: 如何用游標逐筆搬運以避開驅動缺陷？
    - C-Q4: 如何將舊 VARCHAR 欄位安全轉為 NVARCHAR？
    - C-Q7: 如何用 COLLATE 在查詢中強制定序？
    - C-Q9: 如何區分是編碼問題還是緩衝缺陷？
    - D-Q2: SELECT 正常但 SELECT INTO 後變成「上一筆殘影」？
    - D-Q3: 透過 Linked Server 後中文亂碼但英數正常？
    - D-Q8: 欄位長度不合造成截斷，如何處理？

- 高級者：建議關注哪 15 題
    - A-Q10: 什麼是緩衝區溢位（Buffer Overflow）的資料症狀？
    - A-Q18: 什麼是字串結尾 0x00（NUL）與其影響？
    - B-Q5: 為何用 NVARCHAR 變數接值可矯正搬運？
    - B-Q6: 緩衝區重用與終止錯置如何導致上一筆殘影？
    - B-Q7: SQL Native Client 的轉碼流程與碼頁處理？
    - B-Q10: 提供者在 Linked Server 的轉碼角色為何？
    - B-Q15: 0x00 終止對定長/變長與 Unicode 的影響？
    - B-Q17: 如何以觀察法判定疑似驅動缺陷？
    - B-Q19: TEXT/NTEXT 儲存與 TEXT IN ROW？
    - B-Q20: 更新與修補如何修正提供者/伺服器錯誤？
    - B-Q23: 集批與流式傳輸差異？
    - B-Q24: 「上一筆資訊殘留」的診斷意義？
    - C-Q5: 如何偵測與修補已亂碼或被替換的資料？
    - D-Q4: CAST 成 NVARCHAR 後仍少數列錯亂？
    - D-Q9: 如何判斷是 SQL Server 還是驅動的問題？