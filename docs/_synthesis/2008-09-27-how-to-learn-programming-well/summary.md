---
layout: synthesis
title: "該如何學好 \"寫程式\" ??"
synthesis_type: summary
source_post: /2008/09/27/how-to-learn-programming-well/
redirect_from:
  - /2008/09/27/how-to-learn-programming-well/summary/
postid: 2008-09-27-how-to-learn-programming-well
---

# 該如何學好 "寫程式" ??

## 摘要提示
- 基本功: 學好程式沒有捷徑，核心在於紮實的基礎理論與邏輯能力。
- 速成迷思: 工具進步降低入門門檻，但所需知識深度與廣度反而更高。
- 內功與招式: 沒有基礎內功，只靠框架與範例的「招式」終究難以應對變化。
- 跨層理解: 具備硬體到系統的概念，有助快速判斷技術邊界與選型。
- 學習三階段: 從計概與資料結構，進入作業系統與系統程式，再到 OOP、設計模式與工程方法。
- 資料結構關鍵: 排序、樹、表、雜湊、堆疊等是邏輯與效能的基石。
- 練習導向: 手寫排序與資料結構，避免依賴語言內建函式與黑箱框架。
- 效能意識: 了解不同集合與搜尋方式的時間複雜度與取捨。
- 問題建模: 將實務需求（如導航路徑）轉為適當資料結構與演算法。
- 自我檢核: 以三個練習題檢視是否達到合格的程式基本功。

## 全文重點
作者回應同事提出的「如何提升程式人員素質」問題，指出業界常見的誤區是期待速成。儘管工具與框架讓開發更容易，想成為專業仍需扎根於基本功：計算機概論與資料結構、作業系統與系統程式、以及更進一步的 OOP、設計模式與軟體工程方法。作者以自身學習歷程說明，當具備硬體到系統的底子後，面對新技術只需瀏覽概要便能掌握其能與所不能，查文檔即可上手，與其不斷「追技術」不如「以基礎理解技術」。

他點出當代開發者常有「內功不足」的現象，能迅速做出漂亮成果，卻在遇到非典型問題時無所適從。為補強，作者主張從資料結構著手：理解排序、樹、表、雜湊、堆疊等結構與時間複雜度，知道何時用何種資料結構與演算法。具體練習包括手寫泡沫排序與快速排序（不可用現成函式）、理解 .NET 中 List 與 LinkedList 的差異與效能、以及將實務情境如導航路徑轉為圖與搜尋問題。透過這些訓練，開發者能培養正確的邏輯與效能敏感度，奠定從「會寫程式」邁向「能設計解法」的能力。

最後，作者提供三項自我檢核作業：排序一組撲克牌；在記憶體中處理百萬通訊錄並高效搜尋；以台灣高速公路為圖模型求最短或建議路徑。這些題目不依賴特定語言或熱門技術，而是純粹考驗問題建模與邏輯解決能力。作者計畫以系列文章持續深入，期望讀者先打好底子，再學習各種熱門技術，如此才能持續升級而非困於追新。

## 段落重點
### 緣起：提升程式人員素質的困境
作者因同事詢問「如何拉高團隊程式品質」而展開思考，指出這是台灣軟體產業的普遍痛點。多數人期待快速變強，卻忽視「基本功」才是持久之道。作者打算在公司部落格開啟系列文章，先分享心得，後續再整理。在這個起點，他明確把討論範圍聚焦在「如何把程式碼寫好」的可訓練部分，暫不涉及特定領域的 domain know-how。此段奠定了文章基調：拒絕速成、強調長期與結構化學習，並以團隊培訓的實務出發。

### 速成不可行與技術進步的悖論
作者指出若真有速成法，高手早已滿街。技術與工具的進步，確實簡化了開發與操作細節，但背後所需理解的知識與理論非但不減，反而增加。當入門門檻降低，專精門檻卻升高，這是現代軟體開發的矛盾。許多人能憑書本與框架迅速產出應用，但對系統本質、效能取捨與運作原理沒有扎實認識，因而在非典型問題、最佳化與除錯時受限。這段重申學習方向：以核心知識對抗表層變化。

### 基礎扎實帶來的跨技術理解力
作者分享自身背景：電機系打硬體底子，研究所跨資工，長期積累讓他面對新技術只需看總覽便能掌握邊界與適用性，查閱文件即可上手。這種能力來自對計算機運作從硬體到系統的連貫理解。相對地，許多新手能快速做出網站，卻很難回答「CPU 如何執行指令」到「瀏覽器如何載入網頁」的完整鏈條。缺少這層理解，就像只有「招式」沒有「內功」，遇到變化或未知情境容易失手。

### 年輕開發者的內功缺口
作者批評現況：市場充斥快速上線的學習資源，導致基礎訓練被忽略。於是出現「畫面好看、招式華麗，卻後繼乏力」的現象。一旦對手出招超出教材範圍，便無從應對。這段強調「內功」的重要性，即可遷移、可組合、可推導的底層能力。只有建立跨題材的知識網，才能將新問題映射到已知結構與方法，不再陷入無盡追新。內功不足會直接反映在架構穩定度、效能與可維護性上。

### 三階段學習藍圖
作者提出清晰學習路徑：第一階段是計算機概論與資料結構，養成正確邏輯與基本問題解法，屬於合格程式設計師必備。第二階段是作業系統與系統程式，使你理解系統機制與底層運作，對建構元件、平台與基礎設施尤為重要，是軟體工程師的基礎。第三階段是 OOP 與設計模式，以及 XP、TDD 等方法論，幫助你設計合理架構、以正確流程開發，邁向架構師的必要能力。路徑強調由底層到方法的漸進深化。

### 為什麼從資料結構開始
作者將討論聚焦在第一階段，因為許多工程師「會寫」但邏輯「怪怪的」，症結在資料結構與演算法。學習內容包括常見排序、樹與表的儲存與查找策略、堆疊與佇列的行為、雜湊表的取捨，以及時間複雜度意識。重點在於「何時用何種結構」而非只會調用 API。作者不把這稱為高深理論，而是基本作法；只要掌握這些邏輯，至少能把程式正確寫出來，並對效能有初步判斷。

### 基礎練習：排序與集合
具體練習從手寫排序開始，例如泡沫排序與快速排序，要求理解步驟並用熟悉語言實作，不得依賴內建排序。接著進入集合差異，例如 .NET 的 List 與 LinkedList：雖然用法相似，但在插入、查找、遍歷、記憶體區域性等面向表現差異很大；當資料從百筆擴至萬筆、百萬筆時，時間成本如何增長，關鍵在資料結構與演算法複雜度。此段訓練的是可度量的效能觀與結構選型能力，而非語法糖。

### 應用情境：導航與路徑
作者以導航系統示例：地圖如何儲存（圖的節點與邊、權重設計），起終點如何求最佳路徑（如 BFS/DFS、Dijkstra、A* 等思路），在不談畫面與框架下，單憑資料結構與演算法即可求解。這說明資料結構是從「寫功能」到「解問題」的橋梁。若缺乏這些能力，再多 C#/ASP.NET 書籍也幫不上忙；語言只是工具，能否抽象、建模與選對演算法才決定能不能解出實務問題。

### 自我檢核與後續計畫
最後提供三項檢核作業：以手動排序撲克牌驗證你對排序步驟與實作的掌握；在記憶體中處理百萬通訊錄並實現高效搜尋，考驗結構設計與查找策略；以台灣高速公路為圖模型產生建議路線，驗證建模與路徑算法能力。這些題目與資料庫、Web 框架無關，純粹考邏輯與架構思維。作者將持續以系列文章深入，希望讀者先打好基礎，再學熱門技術，避免困於無止盡的追新，而能穩步升級為能設計與判斷的專業者。

## 資訊整理

### 知識架構圖
1. 前置知識：基本數學與邏輯（集合、函數、離散數學基礎）、至少一種程式語言的基礎語法、基本問題拆解能力與偽程式思維。
2. 核心概念：
   - 基本功優先於速成：工具能簡化操作，但知識與理論只會越來越多，扎實內功才有持久競爭力。
   - 資料結構與演算法：能用正確資料結構與排序/搜尋策略解題，是合格程式設計師的門檻。
   - 系統層面理解：作業系統與系統程式觀念，讓你理解程式在系統上的行為與資源使用，支撐工程化開發。
   - 軟體設計與工程方法：OOP/Design Patterns 與 XP/TDD 等方法論，幫助正確設計架構與提升開發流程品質。
   - 應用導向練功：以實務問題（如導航最短路徑、海量通訊錄查找）驗證並鞏固基礎。
3. 技術依賴：
   - 資料結構與演算法 → 依賴計算機概論與基本語法/邏輯。
   - 作業系統與系統程式 → 依賴資料結構/演算法基礎，理解記憶體、程序、I/O 等。
   - OOP/Design Patterns/XP/TDD → 依賴前述基礎與系統理解，方能做出合理抽象與可測試設計。
   - 工具與框架（.NET Collections 等）→ 依賴對其背後資料結構與複雜度的理解，才能正確選型。
4. 應用場景：
   - 大量資料查找與快取（通訊錄百萬筆資料的快速查詢）。
   - 路徑規劃與圖論應用（導航最佳路徑、交流道規劃）。
   - 一般商務系統效能優化（正確選用 List/LinkedList/HashTable）。
   - 架構設計與團隊開發（以 OOP/設計模式與 TDD 建立可維護系統）。

### 學習路徑建議
1. 入門者路徑：
   - 打穩語法與邏輯：選一語言（如 C# 或 JavaScript），練習基本 I/O、陣列、迴圈、函式。
   - 演算法起手式：手寫 Bubble Sort、Selection Sort，再進階到 Quick Sort；不可呼叫內建 sort。
   - 資料結構入門：理解 Array、LinkedList、Stack、Queue、Hash Table、Binary Tree 的操作與時間複雜度。
   - 小作業驗收：實作撲克牌排序與基本搜尋（線性/二分搜尋）。
2. 進階者路徑：
   - 深化資料結構：樹與堆（Binary Search Tree、Heap）、雜湊碰撞處理；認識圖與遍歷（DFS/BFS）。
   - 系統觀念：處理程序/執行緒、記憶體管理、I/O、檔案系統基本原理；觀察程式在 OS 上的效能行為。
   - 工具內涵：對 .NET/Java Collections 的底層實作與複雜度做比較（List vs LinkedList vs Dictionary）。
   - 演算法實作題：迷宮（用 Stack/DFS）、K 最近/Top-K（Heap）、頻率統計（Hash）。
3. 實戰路徑：
   - 專案一：百萬筆通訊錄的快速讀取與查找，設計索引/雜湊與快取策略，量測延遲。
   - 專案二：高速公路路徑推薦，建模為圖，實作最短路徑（Dijkstra 或 BFS 於等權重）。
   - 工程化實踐：以 TDD 開發核心演算法，重構以套用合適的設計模式（Strategy 用於排序、Repository 封裝資料訪問）。
   - 效能與觀測：建立基準測試，評估不同資料結構/演算法在 10^2、10^4、10^6 規模的差異。

### 關鍵要點清單
- 基本功優先：沒有速成，內功（理論與邏輯）決定上限 (優先級: 高)
- 計算機概論：理解電腦如何執行程式與資料表示，是一切抽象的地基 (優先級: 高)
- 時間與空間複雜度：以 Big-O 分析選擇演算法與資料結構 (優先級: 高)
- 排序演算法：手寫 Bubble/Quick 並理解適用情境與複雜度 (優先級: 高)
- 搜尋策略：線性、二分與雜湊查找的取捨與前提 (優先級: 高)
- 核心資料結構：Array、LinkedList、Stack、Queue、Hash、Tree 的操作與代價 (優先級: 高)
- List vs LinkedList：插入/刪除/隨機存取的效能差異與實務選擇 (優先級: 高)
- 圖與路徑：用圖模型與 DFS/BFS/Dijkstra 解決路徑與連通問題 (優先級: 中)
- 作業系統基礎：程序、執行緒、記憶體、I/O 對效能與正確性的影響 (優先級: 中)
- 系統程式觀念：系統呼叫、檔案與緩衝，理解軟硬之間的邊界 (優先級: 中)
- OOP 與抽象：以類別/介面建模問題領域，降低耦合 (優先級: 中)
- 設計模式：Strategy、Factory、Observer 等提升可維護性與可擴充性 (優先級: 中)
- 測試驅動開發（TDD）：以測試保護演算法與重構，形成良好回饋循環 (優先級: 中)
- 實務題練習：撲克牌排序、百萬筆查找、導航路徑作為綜合演練 (優先級: 高)
- 工具不等於能力：會用框架不代表理解原理，避免只學「招式」 (優先級: 高)