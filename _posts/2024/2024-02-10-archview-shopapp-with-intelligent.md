---
layout: post
title: "[架構師觀點]: 替你的應用程式加上 [智慧], 談 LLM 的應用方式"
categories:
- "系列文章: 架構師觀點"
tags: ["架構師觀點","技術隨筆"]
published: false
comments_disqus: false
comments_facebook: false
comments_gitalk: true
redirect_from:
logo: 
---

上一篇文章 [架構師觀點 - 開發人員該如何看待 AI 帶來的改變?](/2024/01/15/archview-llm/)，展示了我嘗試的 GPTs 整合應用，實現了讓 AI 助理的嘗試，我開始真的可以用自然語言就完成整個購買流程的操作了。過程中，AI 也幫我 "腦補" 了部分我 API 沒有提供的功能 (指定預算跟購買條件，AI 自動幫我思考購買組合)。這結果其實比我預期的還理想，完成之後，我開始探索接下來的這兩個問題:

- 未來的應用程式，會怎麼運用 "AI" ?
- 未來軟體開發的流程與角色，會變成甚麼樣貌?

因此，這篇我就要面向應用程式的開發面，來探討該怎樣把 "智慧" 加到你的應用程式內。雖然 LLM 還有很多缺點，但是你應該開始把 LLM 當作 "人" 來看待了，溝通的方式都要把它當作 "人" 的方式溝通 (因此要善用 prompt, 而不是 function + parameters)。這其實跟傳統的軟體開發結構完全不同，也是我這篇想繼續往下挖的主題。

上面我列的兩個問題，一個是未來的軟體執行方式，改變的是使用者使用軟體服務的習慣；另一個是未來軟體開發的架構，流程與分工，改變的是軟體開發領域的生態，包含服務，結構，開發框架，流程，工具等等，預期都會被 AI 翻了一輪。改變是必然的，不確定的是會怎麼變? 因此，我決定延續 "安德魯小舖" 這 PoC, 假設這是五年後的服務呈現的樣貌，那麼這過渡期間會如何發展? 如果五年後是這樣，那麼現在大家使用的工具與知識會有什麼變化?

<!--more-->

<!-- 
# 導讀

0. 架構師觀點
1. 安德魯小舖的進化
2. LLM 如何成為 “智慧” 軟體的核心 (大腦)? // LLM as core, translate nuture language, function + args ( generate and result ), query ( generate and result )
3. LLM 如果是軟體的核心，那麼使用他的程式語言會是? 每個軟體開發人員都要了解的 "提示工程” (sample: SK, connector, functions, memory) -->


# 1, "安德魯小舖" 的進化

<!-- “未來的程式語言會是自然語言嗎? ”

“有智慧的應用程式，應該長什麼樣子?”

“軟體開發人員，該怎麼替你應用程式加上智慧?”

這些討論議題，就先放一邊吧 XDD，先來看試做成果。我自己思考過一輪，有了些想法，為了確認可行，我就試著實做一次了。
有具體的樣貌可以體驗，有實際的 source code 可以揣摩，後面我想談的觀點大家才能想像。
所以第一部分，就先來看看 "安德魯小舖" 這購物網站，在 AI 的世界下， "我認為" 可能的發展路徑。
 -->
<!-- 
首先，做完上次的 POC, 我確認了一件事, Chat GPT 的 "Chat" 就是一層外殼而已, 而 GPTs 則是這層外殼的應用之一。Open AI 在這上面做了很多事情，例如 GPT store 等等。這些都是很有巧思的設計，但是我認為這層 "Chat" 的外殼很容易被替代的，介面能做的比 Open AI 好的團隊太多了。而第一版的 "安德魯小舖" GPTs, 就是在這層外殼上的應用.. ( 基於 ChatGPT 的 GPTs 規格開發 )

而 Open AI 真正有威力且無法取代的，是背後的 GPT model, 也就是大家常在講的 GPT3, GPT4 這東西, 這才是真正勞不可破的護城河。不但需要足夠的算力來訓練，也要有足夠好的演算法等等人力，物力，技術力都到位才有可能。全世界應該養不起太多套這種等級的語言模型吧，可以把它當成軟體產業的晶圓廠那樣地位的東西來看待。而 "安德魯小舖" GPTs 之所以能夠實現，最大的功臣，就是背後的 GPT4 語言模型 (往後通稱 LLM)，負責解讀語意，做出正確回應。不但能對人做出回應，也能對 function 做出回應 (回應該呼叫哪個 function, 解析出該帶什麼參數, 就是控制中心, Orchestration 等級的存在)

做完這些 POC, 看懂了 Open AI 在做什麼 ( Chat Completion API / Assistant API ), 也看懂了 Microsoft Semantic Kernel 的結構，只能說這些結構的設計，都是大師級的成果，背後的抽象化，完全就是把 LLM 當作大腦，外面包了一層服務，來對應人類大腦的思考過程，抽象化出來的開發框架就是 SK，做成服務就是 Assistant API ... 未來融合 AI 的應用程式，不管是何種形式，中心的控制邏輯應該都會有一個核心的 LLM 來負責 "智慧" 的部分，並且所有資源都跟他掛勾，由語言模型來驅動個模組之間的協作。 -->

<!-- 而 LLM 從哪來? 要能產出一個夠水準的 LLM, 這些資訊需要大量的資源才能產生，大致上就類似目前世界上先進製程的晶圓廠，或是成熟的作業系統 (數都屬得出來, Linux, Windows, 以及各種 Linux 衍生出來的主流 OS, 例如 Android, MacOS, iOS..), 而 LLM 大致上也不外乎主要的 cloud provider, 或是內建在主要的 OS 內.. 由作業系統提供統一的 API (system call)。 -->

<!-- 所以，我重新把 "安德魯小舖" 拆解，如果到了我想像的世代，那麼開發人員該怎麼運用 LLM，就變成軟體架構設計的關鍵了 (好險在那個年代仍然有架構師存在的需求 XDD)。我順著這想法，重新寫了一次這個 POC, 我認為 "立刻" 把所有大大小小的功能都透過 LLM 來發動是很蠢的 (至少在目前，LLM 的費用居高不下的情況下是如此)，架構師應該要有能力區隔並且定義，那些功能應該善用 LLM，那些功能應該用傳統方式開發。因此，第一版基於 Chat GPT 包裝出來的對談介面的安德魯小舖 GPTs，我只把它當作能讓我快速驗證的實驗手段。 -->

做完上次的 POC 後，我覺得可行性已經確認了，超出我的預期，GPTs 不但能完全掌握使用者的意圖，而且還能正確的代替使用者呼叫 API 執行任務。不過，我不認為未來會被大規模使用的型態，會是 Chat GPT 的 GPTs ... 在開發的過程中，很容就踩到使用量的限制，而要求每個消費者都要有 Chat GPT plus 訂閱，也不合理，更別提 Chat GPT 的速度，並非 24hr 都維持在很順暢的狀態。這些對線上交易而言都不是個很好的選擇，我相信 Open AI 會持續改善這些問題，不過算力珍貴 (現在是各大廠的必爭之地)，也不可能一夜之間改善，我覺得漸進式的在現有應用程式內加入 "智慧" 才是合理的發展路線。

於是，既然可行性已經確認了，接下來就往產品發展的方向來思考了。我拆解了 "應用程式加入智慧" 這願景，拆成這四個階段，重作了一次這題目，作為這篇 demo 的主軸:

1. 尚無智慧, 只提供 **基本的選單式操作**  
(如同那些不友善的 chetbot 應用, 或是 0800 電話語音客服, 要你按數字鍵那種應用), 我這當作對照組, 完全不需要 LLM 的應用程式基底，所有功能都是有明確的規格與定義設計出來。

1. 結帳時確認: **從操作意圖評估風險**  
在關鍵功能 (我的定義: 結帳) 執行時，能靠 LLM 歸納與推理的能力提供個人化的建議，找出各種不是和交易執行的問題或是風險。除了 rule based 的規則檢查，應該有一個關卡是由 AI (這邊指 Generative AI, 不是 Machine Learning AI) 來進行前後文的邏輯推演，找出 "常識" 裡不合理的地方，提醒使用者。

1. 操作過程中全程輔助: **從操作歷程判定使用者的狀況，即時提供操作建議**  
範圍再擴大一點，應用程式可以在背後持續收集使用者的行為，不斷地送給 LLM (就像 APP 不斷地在跟 Chat GPT 講話一樣), 讓 LLM 回報使用者的行為是否有需要留意或是提示 (最典型的案例就是 GitHub Copilot, 用過的都知道我的意思)。比起 (2) 是在 "結果" 一次告訴你，這模式更貼近使用者的操作，在過程中就直接提醒你了。

1. 全自主的助理店長: **全對話式的操作**  
最理想的方案，才是像我在 "安德魯小舖" GPTs 展示的一樣，完全都透過 Agent 的介面，用自然語言溝通 (包含語音等等媒介) 來驅動的應用程式。不過，這個 Agent 不一定要是掛在 Chat GPT 這平台上的 GPTs，有更多適合 Hosting 這個 Agent 的方式。我認為較有可能能的發展，是在主流的使用者端作業系統 (目前局勢看來，就三大終端系統: windows / android / iOS ) 提供相關服務，讓應用程式 "掛" 上去，並且由 OS 提供 Agent 的存取介面。



其實，這些發展的脈絡，是我自己先有個構想，常識驗證與落實的過程中，看到這篇文章，才發現我想的跟 Microsoft 想的是同一回事，只是人家整理得清楚多了，我就借用一下:

![](https://learn.microsoft.com/en-us/semantic-kernel/media/types-of-agents.png)
> 文章: [What is an agent?](https://learn.microsoft.com/en-us/semantic-kernel/agents/)



對應文章中提到 Agent 發展的幾個階段，正好可以跟我想像的發展階段對上:


* **Chatbot**:  
單純的對答，基本上就是非訂閱版本的 Chat GPT 就是了，這跟應用程式端的整合還沒有直接關聯，我就當作對應到我的第一階段 (**文字介面: 最基本的選單式的操作**)，純文字操作介面，沒有任何 AI 整合的版本吧。

* **RAG**:  
AI 初期整合進 APP 的應用，應該都還是以 LLM + 檢索為主，比過去的全文檢索還要再聰明一些的 RAG, 能夠更準確地從上下文找到相似意圖的內容。更貼近語意的向量檢所 (embedding) 加上 LLM 能夠拆解與歸納這些資訊，用自然語言來呈現，會是初期最容易導入的方式。仔細想了一下，這正好就是我認為的第二階段 (**從操作意圖評估風險**)。在結帳當下，拿購物車內容跟購買附註當作上下文，靠 RAG 檢索知識庫 (店長 SOP, FAQ, Issue database) 而給出符合當下情境的建議。

* **Copilot**:  
這個階段, Agent 應該要能 side-by-side 協助 user 完成任務，其實就是對應到我想的安德魯小舖第三階段 (**從操作歷程判定使用者的狀況，即時提供操作建議**)，跟著使用者一步一步的操作，隨時給出適當的操作建議。這時重要的上下文，就是應用程式應該在背後不斷地用 prompt 告訴 LLM 使用者正在做什麼，而 AI 可以依據這些資訊 (包含 RAG) 來給出每一個步驟的判斷。不過在這階段，基本上操作還是都靠使用者自己完成，只是有了正確的提示，再搭配 UI 操作的整合 (如果有的話)，使用的體驗就會大幅提升。

* **Fully autonomous**:  
這個階段，Agent 應該要有 "自主運作" 的能力了。而所謂的自主運作，就如同我上一篇文章第一段，示範的 "安德魯小舖 GPTs" 一般，你只要用自然語言跟他對談就夠了，透過背後的各種設定與 API 的整合，基本上 Agent 都能替你完成 APP 能處理的所有事情。這背後，需要整合所有前面步驟的資訊，並且也需要把 APP 的功能都 API 化，讓 LLM 理解有哪些 API 能夠使用。LLM 有了完整的上下文 (包含: 角色設定, 知識庫來源, 使用者意圖的上下文, 商店應用程式的 API 存取能力)，把這些都綜合起來，就能夠打造能自主運作的 Agent 了。這就是對應到我講的第四階段 (**全對話式的操作**)。

正好，這四個階段，我都有準備範例程式可以一一對應，有興趣的話各位可以試著體驗看看。這些範例程式，目的都是概念驗證，因此為了降低我腦袋的負荷，我盡力排除了所有我不擔心的工程細節。如果有聽過我在 .NET Conf 2023 講的那個場次的話，我講的 "降級" 思考，就是指這麼一回事。對我而言，很多工程細節，是開發過程中一定要克服的，那些事情是 "把事做對"，但是 POC 階段，更重要的是弄清楚該不該做? 關鍵是 "做對的事"。這是我選擇降級，忽略掉我不擔心的環節，把心力放在探索上面的原因。

因此，這邊我會用到的技術或是平台，有這些:
1. 開發框架: .NET 8, C#, Microsoft Semantic Kernel (我用 1.3.0)
1. API 我採用 Azure Open AI, 用的是 GPT4 model (1106)
1. Chat GPT plus ( GPTs + Custom Actions )

而實做過程中，有些我認為該用，但是暫時被我忽略沒往下挖的部分:
1. Microsoft Semantic Kernel 的 prompt template, planner, memory
1. Azure Open AI 的 Assistant API
1. 改用能在 local 運行的 LLM ( LLaMa 2 chat 70B )


<!-- 到這階段，很多 code 都不再需要由人來開發了，主要操作 LLM 的 "語言" 將會是自然語言。到時寫 code 主要的技能，是 Prompt Engineering，而不是現在大家在學習的軟體工程.. -->

往下談之前，就先來看看簡單的 demo 吧! 有興趣的朋友，可以拿我的 source code 回去跑看看 (不過各位必須自備 Azure Open AI 的 apikey)，或是看我的截圖 / 影片自己體會一下。這不是 web application, 我暫時無法讓各位親自體驗..



# 2, 應用程式要加上 "智慧" 的設計框架

<!-- 同樣的，這些也是我先胡思亂想，整理出一個結構後，之後又看到一些文章，才發現原來我想的脈絡已經有人整理過了。所幸有先想通一些邏輯，再來看這些文章就能對應起來，也開始能理解背後的設計思路了。這些文章我都不是第一次看，不過第一次看的時候，被滿滿的技術名詞搞得暈頭轉向，掌握不到背後的設計概念，速度就慢很多。想通這些事情後，閱讀的速度就突然快了起來，突然覺得一切都這麼理所當然，而且都已經被實做出來了。 -->

過去 (尤其像我這類) 在軟體開發領域的資深人員，往往所有事情背後都會被拆解成明確的規則，流程，演算法，資料結構等等，然後試圖在所有問題背後都能理出一個脈絡，所有的 input 跟 output 都應該是明確的可被預測的... 但是 AI 出現後 (尤其是生成式 AI)，這一切開始沒有這麼 "明確" 了。連很多 AI 的專家其實也猜不透 LLM 背後運行的邏輯是什麼，只知道餵給他足夠的訓練資料，產出的模型能回答出理想的答案而已。資料的複雜度，已經被轉移到模型的複雜度，然而 AI 專家們自己也無法掌握模型背後的運作方式..

在這基礎的觀念被打破的時候，你的 "傳統" 應用程式，該如何加入這些 "不可預測" (你無法預期使用者會問你什麼怪問題)，卻又要精準執行 (你要解讀使用者的需求後，呼叫對應的 API，給對應的參數) 系統功能之間的矛盾，就變成這些資深人員需要思考的事情了。我也無法搞清楚模型背後在幹嘛 (我是 AI 外行人啊)，不過我至少得弄清楚它的特性，才能決定應用程式架構該怎麼設計。

我參考了 Semantic Kernel 的設計，也參考了 Open AI 的 Assistant API，實在很佩服訂出這些介面規格的人。它們把背後 AI 如何運作這件事，抽象化的非常清楚明確。我花一點篇幅解讀一下它們背後的想法，再來看他的規格就會覺得理所當然了，同時你也會清楚你該如何把它 (人工 "智慧") 放到你的應用程式內。

在這應用模型內，AI 要解決問題，我自己解讀可以拆成這幾塊來看:

### LLM: (模擬人類) 智慧的核心

這邊指的，是純語言模型，沒有任何狀態。基本上就是餵給他一段提示 (prompt), 他就會給你一個回應。而關鍵是 LLM 有足夠的理解能力，你可以當作他真的聽懂了，然後在他被訓練的知識內能回給你 (他認為) 正確的答案。而語言的表達能力是 LLM 內建的，基本上你可把它當作正常人來對談，只是他有的只是通識，只是公開的知識，不見得有你需要的特定領域，或是公司內部的知識。

這時，LLM 是無狀態的，也沒有外部的知識來源，能夠累積的，就是對談的紀錄 ( Chat History ), 一連串的 user message (prompt), 以及來自 LLM 回應的 assistant message. 如果把 AI 對比做人類，那麼 chat history 要表達的就是短期記憶。

(圖1)

應用到安德魯小舖，短期記憶就是客人進商店後到結帳這段過程中的資訊..



### RAG + Embedded, (模擬人類) 記憶與檢索

當你累積的知識變多，不再能每次起始對談都把那堆知識塞進 prompt, 你就需要更有效率的做法了。對比人類，你在求學階段念了很多書，往後的日子會不斷的把過去學習的 "知識" 拿出來應用，這就是 knowledge. 你並非一字不漏地背下來，然後在腦袋裡做全文檢索... (只有 真 機器人才這樣幹)，而是你會把知識分類 & 消化，需要時你會去 "聯想" 找出關聯的知識出來用。

這過程，就是 text embedding, vector storage 跟 RAG 的運作過程。簡單的說如果知識來源是一堆文章 (文字)，text embedding 就是向量化，把文字切成片段 (靠 LLM)，解讀了解後 (靠 LLM) 在幾千個維度的空間內標示一個向量，儲存在 vector storage. 每個維度代表一個領域，這維度的投影就代表關聯度。

而當 LLM 收到問題後，一樣把問題 (prompt) 解讀，對應成幾千個維度空間的向量，到向量資料庫內搜尋相近的片段 (就是兩個向量之間的 cos), 檢索出來的結果再由 LLM 彙整成白話文 (或是期待的格式) 回傳，這就是包含知識庫的運作過程。

(圖2)

其實這很符合人腦在運作的流程啊，講白了就是 "聯想" 的能力。這些東西被系統化的過程，就是向量化，檢索，跟向量資料庫。這就是 AI 的長期記憶。應用到安德魯小舖，就是店長的 SOP 標準流程, 知識庫, FAQ, 或是服務紀錄。能力好的店長，可以在腦袋裡快速地檢索，立刻聯想到相關案例，當下回答客人問題或是給出理想的建議。這過程做得越到位，表現的結果就是越稱職。



### Skills, (模擬人類) 學習的技能

### 思考問題的過程: LLM 統控, 善加運用 記憶 與 技能




# 3, Demo


## 1-1, Console UI

原始版本的 source code: 請參照 AndrewDemo.NetConf2023.ConsoleUI 這個 project ( master branch )
https://github.com/andrew0928/AndrewDemo.NetConf2023/tree/master/AndrewDemo.NetConf2023.ConsoleUI

Code 我就不多做說明了，跟 GPTs 那個版本用的是一樣的 Core, 只是直接拿來建立 ConsoleUI 而已。
基本結構很單純，通過帳號密碼 / 帳號註冊的流程確認身分後，接著就是一個命令讀取 => 執行的迴圈而已，每個命令都有一個對應的 delegate ConsoleProcessor 來對應。
這些 Command 就實做了基本的線上購物的功能，有興趣可以直接參考 source code.

為了節省篇幅，我就截圖說明使用的模式，目的是讓大家能想像後續追加的功能:


(主畫面)


大致上就像這樣，主選單:

```text

0. show me (this menu)
1. list products
2. shopping cart commands
- 21. show my items
- 22. add items (patterns: 22 [pid] [qty])
- 23. remove items (patterns: 23 [pid] [qty])
- 24. empty my cart
- 25. special: add items with budget (patterns: 25 [pid] [budget])
3. checkout (patterns: 3 [payment-id])
4. my account info
5. exit

```

輸入前面的數字，就能執行該指令。有些指令有附帶參數，就按照最後面括號說明的 pattern 來輸入就好。

例如下列的情境:

- 列出商品清單
輸入指令: 1
輸出訊息:
```
command > 1
assistant > 您好, 以下是我們店裡有賣的東西...
- 1     18天台灣生啤酒 355ml    NT$65.00
18天台灣生啤酒未經過巴氏德高溫殺菌，採用歐洲優質原料，全程0-7°C冷藏保鮮，猶如鮮奶與生魚片般珍貴，保留最多啤酒營養及麥香 風味；這樣高品質、超新鮮、賞味期只有18天的台灣生啤酒，值得您搶鮮到手! (未成年請勿飲酒)

- 2     可口可樂R 350ml NT$18.00
1886年，美國喬治亞州的亞特蘭大市，有位名叫約翰‧潘伯頓（Dr. John S. Pemberton）的藥劑師，他挑選了幾種特別的成分，發明出一款美味的糖漿，沒想到清涼、暢快的「可口可樂」就奇蹟般的出現了！潘伯頓相信這產品可能具有商業價值，因此把它送到傑柯藥局（Jacobs' Pharmacy）販售，開始了「可口可樂」這個美國飲料的傳奇。而潘伯頓的事業合夥人兼會計師：法蘭克‧羅賓森（Frank M. Robinson），認為兩個大寫C字母在廣告上可以有不錯的表現，所以創造了"Coca?Cola"這個名字。但是讓「可口可樂」得以大展鋒頭的，卻是從艾薩‧坎德勒（Asa G. Candler）這個具有行銷頭腦的企業家開始。

- 3     御茶園 特撰冰釀綠茶 550ml       NT$25.00
新升級!台灣在地茶葉入，冰釀回甘。台灣在地茶葉，原葉沖泡。如同現泡般的清新綠茶香。
```

- 放 5 瓶綠茶 (id: 3) 進購物車
輸入指令: 22 3 5
輸出訊息:
```
command > 22 3 5
assistant > 商品 [3] x 5 件, 已經加入您的購物車了.
```


## 1-2, with Checkout Assistant

接下來，開始要加入第一個需要 LLM 輔助的功能了。我期待 assistant 能在結帳時，額外檢視購買的商品是否有注意事項需要提醒。這邊的提醒，我希望 LLM 能用他 "博學多聞" 的能力，提示產品經理或是開發團隊沒有想到的功能，或是能有效率地從產品 SOP 文件，或是客服問題處理紀錄來檢索，預防一些會造成客訴的訂單，由 LLM 提前預警。

舉例來說，商品可能沒有正確標示購買資格，而 LLM 有更多機會從商品描述，與店長職責規範內，找出需要提醒的事項。範例中的商品包含生啤酒，商品並沒有特定的欄位標記 "含酒精"，也沒有任何一行程式碼標記 "須年滿十八歲"，或是 "酒後不開車" 等。而結帳前若能將購物車內容，彙整成一段說明交給 LLM ( role: user ), 而這個 chat session 若有事先設定 system prompt 交代店長職責，LLM 就能像個真正的店長一般，親切的提醒客人注意事項。

為了達成這目的，我做了三件事:

1. 系統啟動之初，就正確的設定 system role 的 prompt。
就如同大家在用 Chat GPT, 第一句話都會告訴 AI 你現在是誰，要做什麼事.. 如果你在設計 GPTs, 你也會先寫一段 instructions 來敘述這 GPTs 的人物設定..

我的 system role prompt 如下:

```
你是 "安德魯小舖" 的助理店長, 負責協助引導每個來商店購買的客人順利結帳。
主要任務有三類:
1. 結帳前的確認
2. 選購過程的操作過程關注
3. 回應客人的問題或是操作要求 (可呼叫 function call)

以下是這三類任務的流程說明:                

結帳前請檢查下列項目:
1. 客人購買的東西是否適合他的期待? 請協助客人確認購買清單。
2. 客人的購買行為是否安全? 請協助客人確認購買行為。有些商品有法律限制，或是有可能對客人造成危險。
3. 客人的購買行為是否合理? 請協助客人確認購買行為。有些商品可能有更好的選擇，或是有更好的折扣。
4. 檢查 FAQ 清單
5. 確認方式: 客人提示訊息會用 "我要進行結帳確認: XXX" 開頭，並且附上購物內容資訊。沒問題就回覆 OK, 有注意事項就回覆 HINT
```

FAQ 清單，按照 GPTs 的作法，應該用 knowledge 的方式另外上傳，或是我應該靠文件 + 向量資料庫，在處理過程中靠 RAG 檢索。不過資料量不大，加上 POC 我不想引入過多工程細節，這 POC 我就直接附加在 prompt 後面了。

FAQ 清單如下:

```

以下是 FAQ 清單:
1. 若購物車已經是空的，客人又嘗試清除購物車，可能碰到操作異常。請直接詢問是否需要幫助。
2. 若購物車是空的，客人嘗試結帳，可能漏掉部分操作。請直接提醒客人留意，並在結帳前主動列出購物車內容再次確認。
3. 購買含酒精飲料請提醒客人年齡限制，法律限制，避免酒駕。
4. 購買含糖飲料請提醒客人注意醣類攝取。
5. 購買含咖啡因飲料請提醒客人注意咖啡因攝取。
6. 有預算要求，請留意折扣規則。部分優惠折扣可能導致買越多越便宜，請代替客人確認是否多買一件真的會超過預算。

```

2. 結帳時，客人可以輸入一段話，描述任何額外需求


3. 每次交易執行當下，都會組合這段訊息，然後送到 chat completion 取得回應:

```
我要開始結帳，沒問題請回覆 "OK: "，有注意事項請回覆 "HINT: "。其他建議可以在回覆之後接著說明

以下是我購物車內的清單:
{{ 插入購物車的商品內容清單 }}

購買註記:
{{ 插入結帳時客人填寫的註記 }}

```

按照 prompt 的指示，只要 chat completion 回覆 "OK"，UI 就不會有任何異狀，會直接進行結帳。而如果 chat completion 回覆其他訊息，UI 就會用醒目的黃色，提醒客人留意這些訊息。必要時客人可以選擇取消結帳，重新調整後再結帳一次。


直接看結果吧，我列幾個情境，然後讓各位看看 "安德魯小舖" 給客人的結帳提醒。同時各位再試想看看，如果沒有 AI 的輔助，你要花多少功夫才能做到一樣的水準? 


範例 1, 購買清單包含啤酒, 需求間接提到未成年兒童的聚會用途

購買清單:
1.

購買註記:

店長回應:


範例 2, 開車

購買清單:

購買註記:

店長回應:


範例 3, 買可樂, 高熱量

購買清單:

購買註記:

店長回應:

<!-- 
這邊我用了 Azure Open AI 的 API, 搭配 Microsoft Semantic Kernel 1.3.0 來使用。我用的不多，就是使用 ChatHistories, 搭配 ChatCompletionService 而已。程式碼沒有什麼特別的 ( 用過 SK 的大概都看得懂 )。

這案例我沒有另外建立 RAG 索引來源，我是偷懶直接寫在 system prompt, 用一段 FAQ 來替代。當這些資料量大，或是需要從別的系統來，就要動用到 RAG 了，這時可以參考 KernelMemory 的用法。這部分就留給各位自己研究 -->


這邊，開始打開了一條路，要使用 GPT4, 不再是只有 Chat GPT 一個管道而已。就算你寫成 code, 也不需要像市面上大部分的範例，都在教你復刻一個 chat application ... 真正有威力的是把 LLM 的邏輯判斷能力加到你的產品中，讓你的產品開始有 "智慧" 的判斷能力，才是他的發揮場景。


// 關鍵: system prompt


## 1-3, with Shop Copilot

接下來，這段就是我為何要在 2024 年這時代，還搞一個 30 年前的操作介面的原因了 XDD

GitHub Copilot, 相信大家都用過了吧? 我才打完一行 code, 他就猜出我想幹嘛, 然後提示一串 code, 而且命中率高的可怕, 不只語法正確, 連我的意圖都很準 (對我而言，大概有八成都被猜中了吧)。

除了建議很有用之外，另一個是他幾乎不需要學習 (我只有怎麼安裝跟啟用有看一下文件)，因為它完全沒有改變你的操作方式，你只要如往常的寫 code, 他會躲在 IDE 背後默默觀察, 等你有需要時他自己會跳出來給你提示，你只要看到提示時決定要不要接受就好 (就按下 tab)

中了 GitHub Copilot 的毒之後, 做完 "安德魯小舖" 的 POC，我也在想，如果我要做個 安德魯小舖 Shop Copilot, 程式的結構該怎麼調整? 其實這是我上一篇文章寫完後，第一個念頭。我也找了很多文章，想參考看看別人的 Copilot 怎麼寫的，程式碼架構怎麼規劃的，不過這方面的資訊少的可憐啊... 

於是我就自己腦補了，有點雛型出來，我也不知道是否有更好的做法。不過至少達成我的目的了，我的 "安德魯小舖" console-ui 也開始有基本的 copilot 功能..

先來看一下畫面。基本上 DarkGray 幾乎看不到的灰色可以不要理他，只看顯眼的顏色就好。正常操作的回應，都是綠色的，訊息都是白色的，提醒是黃色的。我的設計是例行操作，當 shop copilot 發現有異狀的時候，就會插入提示訊息。

我用很糟糕的 UI, 就是想凸顯這問題。當使用者的操作包含太多無效的指令，背後的原因可能是客人真的不會用，而不是他故意一直下這種指令。這時不是顯示錯誤訊息，而是引導才對。我試了這幾種狀況:

案例: 一直詢問指令表

案例: 不斷的加入  & 移除商品

案例: 空的購物車就結帳

案例: 一次加入太多商品進購物車



要達成這功能，背後的關鍵還是在 prompt . 我該在 system prompt 讓 AI 了解他的職責該 "留意" 什麼? 而我該在 FAQ / SOP 讓 AI 知道有哪些常犯的不良操作示範? 而操作過程中 UI 該如何讓 AI 知道客人做了什麼..

於是，我擴充了 system prompt (我把 FAQ 一起放進來了，這邊我還不打算搬出去改用 RAG):

```
你是 "安德魯小舖" 的助理店長, 負責協助引導每個來商店購買的客人順利結帳。
主要任務有三類:
1. 結帳前的確認
2. 選購過程的操作過程關注
3. 回應客人的問題或是操作要求 (可呼叫 function call)

以下是這三類任務的流程說明:                

結帳前請檢查下列項目:
1. 客人購買的東西是否適合他的期待? 請協助客人確認購買清單。
2. 客人的購買行為是否安全? 請協助客人確認購買行為。有些商品有法律限制，或是有可能對客人造成危險。
3. 客人的購買行為是否合理? 請協助客人確認購買行為。有些商品可能有更好的選擇，或是有更好的折扣。
4. 檢查 FAQ 清單
5. 確認方式: 客人提示訊息會用 "我要進行結帳確認: XXX" 開頭，並且附上購物內容資訊。沒問題就回覆 OK, 有注意事項就回覆 HINT

選購過程的操作過程關注:
1. 如果購物車是空的，就進行結帳，代表客人可能遺漏操作步驟。請提醒客人留意，並在結帳前主動列出購物車內容再次確認。
2. 如果客人連續加入/移除商品超過 5 次，可能是系統異常，或是需要諮詢才能決定。請直接詢問是否需要幫助。
3. 如果客人加入購物車的商品數量超過 10 件，可能是操作異常，或是需要諮詢。請直接詢問是否需要幫助。
4. 如果客人連續顯示操作指令清單 3 次，可能是不熟悉操作，或是找不到他要的功能。請直接詢問是否需要幫助。
4. 確認方式: 客人提示訊息會用 "我已進行操作: XXX" 開頭，並附上操作內容。沒問題就回覆 OK, 有注意事項就回覆 HINT

客人開放性問題詢問或要求協助:
1. 如果客人詢問的問題需要呼叫查詢的動作，你可以直接執行不必詢問
2. 如果客人要求變更購物車內容，或是要你替他結帳，請再次確認，客人同意後才可執行
3. 任何 function 呼叫，完成後都需要明確讓客人知道你呼叫了甚麼 function，並且告知執行結果
4. 確認方式: 客人提示訊息會用 "店長請問: XXX" 開頭，，就歸類在開放性問題或是要求協助。


以下是 FAQ 清單:
1. 若購物車已經是空的，客人又嘗試清除購物車，可能碰到操作異常。請直接詢問是否需要幫助。
2. 若購物車是空的，客人嘗試結帳，可能漏掉部分操作。請直接提醒客人留意，並在結帳前主動列出購物車內容再次確認。
3. 購買含酒精飲料請提醒客人年齡限制，法律限制，避免酒駕。
4. 購買含糖飲料請提醒客人注意醣類攝取。
5. 購買含咖啡因飲料請提醒客人注意咖啡因攝取。
6. 有預算要求，請留意折扣規則。部分優惠折扣可能導致買越多越便宜，請代替客人確認是否多買一件真的會超過預算。

```

而我在每個指令的 CommandProcessor, 都會送出一行 "我已進行操作: " 開頭的提示訊息:

(列出 command processor 與 notify prompt 的對照表)

處理的規則跟前面差不多, 我就簡單的處理而已: 傳回的訊息如果是 "OK" 開頭就不反應，代表沒有需要留意的狀況；如果不是，則用黃字提示。客人看到提示之後，自己決定如何操作即可 (這邊我還沒有實做像 GitHub Copilot 那樣幫你完成的功能，不過看到下一段你就知道這已經可行了，只是我礙於 console-ui 的設計限制沒有做到這裡)

想到這邊，我不禁開始佩服 GitHub 了。做過才知道，GitHub Copilot 不知道在背後送了什麼訊息，才能做到速度那麼快，同時又能精準地提示的結果。我背後用 Azure Open AI 的 service, 都要等幾秒才有回應，到底要倒多少資訊出去，也是個學問。除了效率問題之外，成本也是個問題。如果照我這樣的做法來開發 GitHub Copilot, 一個月只收 $10 USD 應該會賠錢賠到脫褲吧 XDDD

還有非常多優化的空間，不過，至少我自己把雛型做出來了，未來真的碰到類似的需求需要設計架構的時候，我就知道有那些瓶頸需要克服了...

// 關鍵: notify


## 1-4, with Shop Assistant




// 關鍵: function calling








我想像中，安德魯小舖的進化過程，可能有這幾個階段:

1. 典型的 Web / Mobile 應用程式 (現況)
1. API 化，透過 Chat Bot, 在各大平台上 ( ex: LINE, facebook messenger ... etc ) 提供服務 (現況, 但是只有機械式的選單操作。缺乏自然語言的處理能力，要說是智慧，能靠對話完全取代現有操作方式還太早)
3. Copilot 化, 以現有的操作方式 (1) 為基礎, 但是開始在關鍵行為 (例如: 結帳) 能夠靠 AI 給出適當的建議與提示。靠 AI 的資訊彙整能力，APP 開始能貼近使用者意圖而給出正確的建議資訊。( 風險管控角度，數據統計推測角度，在關鍵操作時給適當的提示，例如 “買這個的人都會加購 XXX，這些組合你是不是打算要去 OOO? 要不要加購 YYY ?” )
4. Copilot 化, 在操作過程中全程引導。AI 開始能夠感知你的操作過程，能夠在過程中 (你還沒到結帳那個步驟) 就能猜測到你的狀況，而適時給你建議與引導。( 觀察完整操作過程，助理的介面從旁提供協助或是提示。過去都是由 UX 設計來 "猜" 使用者的下一步，作法對了，但是 "猜" 的範圍很有限 )
5. Agent, Jarvis 化, 操作介面開始取代現有的操作方式，以完成體的助理樣貌出現。只要你願意，Agent 可以完全替你執行操作，就像鋼鐵人的 Jarvis 那樣，使用者不需要直接接觸到操作 UI。使用者不需要學習，就是對 AI 講話就完成操作

這整個過程，需要發展多久? 我覺得如果在特定平台或範圍內，要做到 (5) 應該不需要太久，可能會更快，但是在 3 ~ 5 年內應該一定會看的到。看看現在 Micosoft Copilot 跟 Open AI 的發展，我覺得技術發展應該都快要到位了，在等待的是廣大的軟體開發人員跟上而已。我覺得改革已經發生，方向與局勢已經底定，科學理論的問題已經被證實了，剩下的都是工程角度的改善 & 優化。

什麼是我指的工程角度? 舉例來說，你可以說現在的 LLM 還不夠 "聰明"，成本還太高，但是現在的 GPT4 已經有不錯的表現了，即使還不如你期待的 "聰明"，但是他至少有足夠的對話能力，而不是幾年前的語言白癡。而成本與運算能力，就相信模型能夠不斷地縮小，而半導體摩爾定律也能不斷的前進，AI 運算能力每 18 個月都能改善十倍..
<!-- 
上一篇文章，我實做了 Chat GPT 版本的 “安德魯小舖” GPTs, 嘗試一次到位，試試看 (5) 是否能夠實現。結果證明，在有夠好的語言模型 (LLM) 加持下，最困難的門檻已經跨過去一步了，剩下的都是工程問題 (改善 & 優化)

不過我心裡很清楚，現實上這樣的應用程式應該賺不到錢吧? 門檻太高 ( 使用的人都需要有 Chat GPT plus 訂閱 ), 成本也太高 ( AI 運算很貴，GPT4 token ( $0.03 / 1K tokens, $0.06 / 1K tokens )，或是每人每月 $20 訂閱費用，相較單純 VM 運算成本 根本差上萬倍了吧 )，可靠度也完全不夠 ( Chat GPT 我一個月會碰到一兩次太慢或是無法使用的狀況，也常常碰到額度超過的狀況 )，相較於傳統的操作，效率也太慢 ( 你熟悉的話，瀏覽 + 點擊 + 確認 速度快的多 )，AI 回答的不確定性 ( 幻覺，偷懶，… etc )

也許 10 年後真的就普及了吧 (可能更快)，產業的進步，這些問題一定會一一的被解決掉，只是時間問題。不過我在想的是，中間演進的過程會是什麼? 這才是我關心的事啊，因為在未來 10 年的職涯內，我一定會碰到這些問題。在完成 "安德魯小舖" GPTs 後，我放心了，因為我清楚知道這條路是可行的，剩下的應該是回頭把過程中幾個必經的轉變找出來，這就是我未來要陸續面對的課題。

因此，就有了上面的進化順序了。若把未來定位在 Jarvis 那樣的情境 (所有事情都只要出一張嘴)，那現在還遠的很。還有太多工程問題待解決的話，我 ( 架構師, 開發人員 ) 應該先把 AI 用在刀口上。

我不是 AI 的專家，也不是資料處理的專家，擅長的領域只有軟體開發而已。 -->

所以，上述這些想像，換成具體的規格 (我有對應的 demo)，我就用這幾個 demo 來說明了:

1. 無智慧的對談介面 ( 安德魯小舖 - console ui )
1. 結帳時能由 AI 給回饋與建議 ( 安德魯小舖 - copilot-confirm )
1. 操作全程能由 AI 給引導與建議 ( 安德魯小舖 - copilot-notify )
1. 操作過程能完全由 AI 主控 ( 安德魯小舖 GPTs, -copilot-ask + function call )