---
layout: post
title: "微服務架構 - 從狀態圖來驅動 API 的實作範例"
categories:
- "系列文章: 微服務架構"
tags: ["系列文章", "架構師的修練", "microservices"]
published: false
comments_disqus: false
comments_facebook: false
comments_gitalk: false
redirect_from:
logo: /wp-content/images/2022-03-25-microservices15-api-design/2022-03-27-15-03-23.png
---

微服務 API 的設計與實作，來到第二篇。

上一篇刊出後，有朋友給我 feedback, 講架構的文章太多了, 但是每個人看了同樣的文章, 最後實作出來的落差都很大啊。這年代缺的不是資訊，缺的是如何應用。Do the things right 比 do the right thing 還要重要。雖說微服務主要概念是只解決特定領域的問題，縮小範圍但是把它做到極致的哲學。但是專注特定領域，指的是專注商業應用的領域，工程維度的細節一個都不能放啊! 舉例來說，微服務都靠 API 溝通，你 API 規格可以專注在特定領域好好設計，但是你能放棄效能，高流量下的穩定性與正確性，以及資訊安全等等議題嗎? 這些我想一個都沒辦法放掉 (放掉任一個老闆都會抓狂吧...)

所以，第二篇的主軸，我決定把內容重心擺在理想的設計，該如何搭配成熟的技術實作出來? 架構師最難的課題就是這個，你必須在整體的系統內找到背後統一的脈絡，做到每個子系統之間的協作是具有一致性的，而不是單純的從各個領域挑出最酷的技術來用就好了。例如最常見是安全機制，要在跨服務協作的前提下，讓大家的安全機制都標準化才能互通。同樣的道理，除了安全機制，其他在 Logging 處理，Configuration 的處理，認證授權的管控等等都是一樣。這些設計必須貫通整個系統，從前台 (面對 enduser)、後台 (面對客戶的管理者 staff)、中台 (面對開發商與營運商 developer / operator) 都是。

這些都是微服務架構設計的難題啊，我在第一篇提到如何用狀態機來收斂你的設計 (不論你用甚麼方法分析，DDD 也好，UML 也好..)，將設計與實作都能擺在狀態機上面用一樣的方式驗證。這篇，我想延續狀態機的想法，當你有了很好很收斂的設計之後，我想完整的用 .NET 的生態系走過這整個從設計到實作的過程，期待能兼顧商業需求、架構與工程的需求都能兼顧。這篇會牽涉到很多實作的細節，涵蓋實作一個完整功能的微服務必要的架構跟設計。


<!--more-->

{% include series-2016-microservice.md %}



# 重新複習: 系統設計與狀態機

既然這篇都要講到實作，那我先在這個段落先交代好需求跟全貌吧。理解全貌你才會知道你設計的力道要掌握在哪裡才是剛剛好。過度設計會浪費資源，反之則會埋下技術債。我的原則是設計要看得夠遠，但是你可以只實作你需要的部分。這是天平的兩端，要拿捏得好唯一的方式是抽象化要做的到位。抽象化作的好，你的結構就會符合實際的結構，對應夠精準就能跟得上變化 (因為邏輯結構都跟實際的一樣)。抽象化的夠精準，你就能夠在同樣的介面下，先實作基本的功能，未來有需要的話才能維持同樣的介面，但是將背後的實作水準提升到另一個檔次。

所以，關鍵就是上一篇提到的介面設計了，我用 API 涵蓋這個介面，但是實際上介面設計包含 API，以及 API 背後的邏輯跟規則等等相關機制，所以上一篇才會用狀態機 (FSM, Finite State Machine) 來收斂 API 的結構。這次我要示範的是大部分系統都會有的會員機制。我先用這張架構圖，定義一下，在微服務架構下，所謂的 "會員" 這領域的內部服務 (或是有的公司都愛稱呼他 "中台")，應該長什麼樣子?

![](/wp-content/images/2022-04-25-microservices16-api-implement/2022-04-05-01-35-35.png)

我想像的微服務，不是直接對外開放的 API，而是同時要服務內部其他團隊或是系統的 API 才對。因此需求主要是來自內部其他系統需要怎麼處理 "會員" 這 domain 的需求。這些 API 應該要能降低或是取代每個系統直接存取會員資料庫的要求，從 direct database access 換成 member service API access 才是，因此 API 的設計都針對內部怎麼看待 "會員" 的分析，而不是對外的各種功能或是畫面的需求。從上面這張圖來看，會員服務就是中間虛線框起來的範圍。

待會我們就拿上一篇的 FSM 以及分析出來的結果來對應了。這些 API 我力求精簡，有很多需求，其實不一定每個都要開 API，有些是呼叫端可以自己處理或加工，有些是可以合併多個 API 就能達成。除非有分散式交易，或是呼叫次數 (批次處理) 的考量，否則我一律精簡的處理，力求開放的面積最小化為原則。

還記得上一篇最後的 FSM 嗎? 來複習一下:

![](/wp-content/images/2022-04-25-microservices16-api-implement/2022-04-05-01-43-54.png)

會員服務背後最核心的資料 (這邊我稱作 Entity), 就是一個一個會員的帳號紀錄了。會員帳號資料的主要狀態，就是該帳號在系統內的啟用與停用等。狀態是會改變的，促使狀態轉移的就是 FSM 上的箭頭；每一個箭頭都代表一個動作 (action), 這通常是 API 最主要的來源。FSM 上面用狀態 (點) 跟動作 (線) 組合起來的就是狀態圖，你必須在對的狀態下才能呼叫該 API 處理該筆會員資料，只要 FSM 上沒有標示的就應該明確的禁止呼叫 (例如 HTTP API 就應該回應 403 或是 500)。呼叫的過程可能會促使狀態發生改變，連帶地就會觸發事件通知 (event)。最後就是安全問題，並不是每個人，每套系統，每個團隊拿到 API 都可以任意改變狀態的。有些是從你能存取那些範圍的資料來限定，有些事你能替這些資料做那些事來限定。這邊我舉最明確的一個來示範: 同一組 API 我要能區分是來自前台 (Web Site / BFF) 的呼叫，或是來自後台 (Admin Console) 的呼叫。兩者能操作的 API 應該有區別才對。

這些資訊，其實在上一篇文章，都已經在狀態圖上面標示清楚了。為了清楚一點呈現，我把他列成表格:

![](/wp-content/images/2022-04-25-microservices16-api-implement/2022-04-05-01-53-17.png)

我按照行為來分類，分成三區，後面要對應 FSM 的實做會容易一些。第一區的 action, 是執行後會直接改變會員資料的狀態，因此我定義了 action, init state, final state 欄位, 來標示只有該筆資料處於 {init state} 時才能執行 {action} 動作，並且執行完畢後狀態會轉為 {final state}。同時，這動作只有列在 {Granted Identity Type} 清單內的認證類型才能執行。這邊的 "USER" 就是指來自前台，直接對應 End User 操作所需要呼叫的 API，而 "STAFF" 則是對應後台，對應管理者操作所需要呼叫的 API。兩者功能需求就有明顯的差別了，尤其是在能做的事情上後者權限大很多。即使都是呼叫同一組 Member Service API, 至少你發給這兩者的 access token 也要有所區別才行。

看懂這張表之後，後面就好辦了。能表格化，就能變成資料結構，就能用 code 來處理。除了第一張表格收納了會影響狀態的 action(s) 之外，第二張表收的 action(s) 跟第一張表類似，要在特定狀態下才能對該使用者呼叫執行，只是執行後他的狀態不需要改變，因此 final state 欄位我就用灰色表示。第三張表就更單純了，只跟授權 ( USER or STAFF ) 有關，不針對特定使用者，或是不在意特定使用者狀態的 API 都屬於這區。

到這邊，需求都清楚了嗎? 沒問題的話就開始實做了! 以下所有的 code 都來自這個 project, 有興趣的可以自行到我的 GitHub Repo, 自行 fork 出去研究。


# 專案分層, Contracts, Core, WebAPI, Tests, CLI

# Token, API 的安全機制與運作模型

# StateMachine, 狀態機要回應那些問題

# Service, 服務的主要邏輯
## 整合 token, statemachine
## 單元測試

# Controller, 延伸 Service, 從 C# 到 HTTP

# Middleware, ASP.NET 的 AOP 運作機制

# 整合測試, PostMan



















因此，想通背後的脈絡，一直是我認為最重要的一環，那麼龐大的系統你要維持一致，你就必須做好抽象化，訂好規則，所有團隊用各自擅長的技術來配合。架構師不可能自己搞懂所有細節，原因其實很單純，因為根本不可能。如果你的團隊不大，大約 5 ~ 10 個以內，那你的確有可能摸透所有團隊採用的 tech stack, 但是這種規模的團隊通常有能力夠好的工程師就能運作順利。當團隊多到 50 - 100 甚至更多時，你不可能摸透所有的細節的 (尤其你的團隊能力越好的時候越是如此)，你能做的是訂好架構讓大家來遵循，所以才會有上一篇文章，微服務的 API，不論你用哪種分析方式，到時作階段時應該要收斂成狀態圖，並且把幾個領域的十座細節 (狀態、動作、事件、授權) 都用同樣的方式標示清楚。你可以把參數跟格式下放，但是那些狀態或哪種腳色能做那些事，這是一定要掌控的，這就是狀態圖主要要維持全系統都一致的部分。

這篇文章，我就用我最熟悉的 C# / ASP.NET 來示範吧! 我用標準的 Repo / Service / Controller 結構來時做這個範例，關鍵的商業邏輯都集中在 Service 層來處理。越來越被重視的安全問題，應該要用 Context 的概念貫穿前後才對 (認證授權不應該只存在 WebAPI 而已，應該要能深入到 Service)，因此我也把 JWT 的體系拿來運用在 API token 身上。由於涵蓋的層面很廣，因此每個環節的細節我都點到為止，各位可以自行擴充。

雖然都說是 "微" 服務了，但是不代表它就可以省略一些環節。微服務的 "微" 是指每個服務都負責單純專一的領域，是精簡，而不是簡陋。因此每個服務本身的設計考量一個都沒有少。我就拿安全機制來說好了，API 呼叫過程的安全性，應該從呼叫端 client + SDK 就要開始考慮了，中間的 API gateway / BFF 也有它該負責的環節，往後到服務本身的 ASP.NET Core Middleware, 或是 Controller, 到後端的 Service, 再到 Repository 為止，都有要注意的環節。這次正好是個機會，可以把我前面介紹的方法全部整合在同一套 POC 上面來驗證說明。