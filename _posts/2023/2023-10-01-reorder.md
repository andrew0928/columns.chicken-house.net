---
layout: post
title: "架構面試題 #5: Reorder Messages"
categories:
- "系列文章: 架構師的修練"
tags: ["系列文章", "架構師的修練", "架構師觀點", "刻意練習", "抽象化"]
published: false
comments_disqus: false
comments_facebook: false
comments_gitalk: false
redirect_from:
logo: 
---

好久沒有來練習解題的技巧了，這次來聊聊串流訊息的重新排列的做法。在面對架構設計的議題上，透過 Message Queue 配合並行處理是很平常的。而我最常被問到的問題就是:

>
> 如果我透過 API 短時間收到大量的 Request, 我如何保證訊息必須按照順序處理?
> 

被問過好幾次這種問題之後，我才發現，有非常大比例的人其實沒那麼清楚這些架構相關的基礎建設是幹嘛用的。例如我這邊提到的 Message Queue, 光是 FIFO 不知道意義的就不少了。Message Queue 為了保證順序，是必須做出一些犧牲的，使用上也會有一些限制。當你不了解這些因果關係，你可能就會誤用了。

回到收到的 API request 順序問題，我常碰到的是你都不分青紅皂白的就丟到 Message Queue, 才來問我順序該怎麼辦, 我只能雙手一攤說我也沒轍啊 XDD!  如果你能掌握來源，在順序還沒亂掉之前就放進支援 FIFO 的 Message Queue，就沒這堆問題了。如果來源的控制權不在你手上，偏偏這些訊息又都是我們自己商業上的應用 (不大可能找的到基礎建設來幫我搞定的 case)，你就必須自己面對這問題了，不論你用不用 Message Queue, 你必須在 Queue 之前或是之後 (我推薦之前) 就把順序問題處理好才是正途。這篇我就是想來聊聊當你不得不面對時，你有沒有能力面對?

這讓我聯想到，當年在學網路通訊時，TCP 跟 UPD 的差異就是會處理封包順序問題，也剛好讀過背後的作法。類似先前研究過的 [微服務基礎建設: 斷路器 #1, 服務負載的控制](/2018/06/10/microservice10-throttle/) 那篇，談 Rate Limit 那類問題一樣，業界已經有 QoS 的做法可以參考，讀懂候你就有能力自己實做，應用在其他類似的商業需求上 (非基礎建設需求，這類需求我都建議你不要自己做，用現成的比較可靠)。就拿這題當作練習，來看看你會怎麼面對這些問題。



## 練習前的思考: 我需要了解這些機制嗎?

這種問題，總是會讓人覺得是否有必要重新發明輪子? 而我的回答千篇一律，我沒辦法直接給 YES or NO 的答案。我對這類事情的判斷是:

>
> 你需要有能力了解原理 (但不用真的去開發)，然後才能判斷要不要自己開發 (重新發明輪子)。如果必要，你才有能力執行。
> 

不必要的情況，是已經有很成熟可靠的基礎建設了。比如已經有可靠的 TCP 協定，你就不需要自己處理 connection 的問題 (封包重送、排列、交握等等) 了，這很多餘，完全不必要。

但是當有類似的商業應用，你需要類似的機制 (例如有依序扣庫存的需求，或是交易要求) 時，你必須要有能力按照順序執行 (交付) 交易要求十，執行順序的差異可能會影響判定的結果，而你沒辦法直接使用基礎建設的情況… 你就必須對這些問題的解法有基本認知，並且在必要的時候有能力自己實做。

因此，有沒有必要? 你需要自行判斷。一般小規模的案子應該都不需要用上這樣的技巧，但是當你負責特定系統的關鍵設計時，你可能就需要具備這樣的能力，確保系統的開發不會被技術限制所影響。你需要做的，至少先了解背後的原理或是演算法，並且照著這篇的練習，練過你就知道真正要自己做的難度，在心裡記得這經驗即可。這些練習不大花時間，但是將來你在判斷技術選擇時，就能幫助你立刻做出技術決策。



## 1. 訊息排序的基本觀念

排序 (sort) 其實很容易，有個欄位判定大小，照順序排列就可以了。不過訊息不是資料庫，他會源源不絕的送進來，你也沒有時間排序好再處理，你必須收到一筆就處理一筆 (頂多有一點點範圍的 buffer 而已)，因此要處理的方式也不大相同。

參考:

[Event Ordering in Distributed System - GeeksforGeeks](https://www.geeksforgeeks.org/event-ordering-in-distributed-system/)

[Causal Ordering of Messages in Distributed System - GeeksforGeeks](https://www.geeksforgeeks.org/causal-ordering-of-messages-in-distributed-system/)

另外，我也貼一下 Wiki 上面提到 TCP 處理封包沒有依序傳輸的處理方式:

 [傳輸控制協定 (TCP, Transmission Control Protocol)](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%BE%E4%BE%8B)

 其中有一張圖，說明了傳輸過程中接收端怎麼靠 buffer + ack 達成這件事:

 ![](/wp-content/images/2023-10-01-reorder/2023-10-08-22-07-18.png)



相關的討論很多，我貼這幾篇就好，平常我都會看這類介紹看一下人家怎麼解題的，但是大部分都看完有個印象就好了。這年代你不需要用腦袋 "背” 下所有的解決方式，腦袋很貴的，你只要當作索引，需要時有正確關鍵字 (或是現在要改成: 有正確的 Prompt) 可以去查出正確解法就夠了。


我自己消化過這些問題，結論有幾個:

1. **你的訊息必須要能標示順序**  
當你拿到任意兩個 message, 你能否從訊息本身知道誰先誰後? 能否知道中間有無漏掉第三個 (或更多) 訊息? 舉例來說，有來源標記的 timestamp, 就能判斷先後；有來源標記的 sequence number, 你就能判斷中間有無掉號碼..
1. **你必須界定處理範圍** (緩衝時間)  
如果你先收到後面的訊息，你有多少時間 (緩衝) 能等待前面的訊息送過來? 例如 3 sec 內前面的訊息沒收到你就要放棄了 (有些訊息有時效性，你無法抓著他等太久)
1. **你必須界定處理範圍** (緩衝空間)  
類似 (2)，如果你先收到後面的訊息，你有多少空間 (緩衝) 能等待前面的訊息送過來? 例如中間掉的訊息超過 10 個你就要放棄了 (有些場合你的暫存空間有限，你無法保留過多訊息)

其中，(1) 談的其實是訊息結構的設計與定義，(2) (3) 則是處理能力與容錯能力 (我把他歸類在 SLO) 的要求。基本概念就是這樣，從來源不斷收到的訊息，會擺在 buffer 內，如果你判定順序都對，而且是連續的不需要處理，就直接處理掉了。如果不連續，你就必須先收著 (留在 buffer 內)，並且等待下一個應該收到的訊息到來，直到 buffer 內暫時留著的訊息也能拿出來為止。

而例外處理則是 buffer 空間不夠，或是保留的時間太久，你不能再等下去了，你就要明確地告訴後面一關，有多少訊息被放棄了。這大概就是約略的處理方式。

想清楚作法，我想建立一個模型，來表達上面的結構。同時這個模型，我會把關鍵的部分 (溝通介面 & 資料定義) 直接用 code 來描述規格。我想像的處理模型:


![](/wp-content/images/2023-10-01-reorder/2023-10-09-17-39-18.png)



對應到程式碼，主要就這三部分，以及我自己追加的監控體系:

1. command source: 訊息來源, 會按照流水號標號送出, 並且模擬網路傳輸會有不固定的延遲, 導致接收時可能會有順序的變化 ( 'GetCommands` )
1. command buffer: 需要緩衝 (buffer) 來存放未按順序收到的 command, 重新排列後往後送的機制 (`IReOrderBuffer`)
1. command handler: 執行接收到的 command, 這邊預期一定要是正確的順序 (`ExecuteCommand`)
1. monitor: `Metrics`, (後面說明)

接下來，我就分別用程式碼來描述上面這四項應該長成什麼樣子，先把整個解題的框架建立起來，而你要練習的，就是把 (2) 用你的想法做出來，讓整個體系能夠運作。最後 (4) 則是我要模擬觀察特定的指標 (Metrics) 來了解整個系統的運作狀況。

相關程式碼，如果你忍不住的話可以先看我的 [GitRepo](https://github.com/andrew0928): [Andrew.ReOrderDemo](https://github.com/andrew0928/Andrew.ReOrderDemo), 或是看完我的說明再去挖 code 出來看也可以。

上面列的四點，都分別在 Program.cs 內有應用的方式，我按照這邏輯個別介紹:


### 1-1, 訊息來源 ( GetCommands )

直接來看 code, 我也不多寫什麼框架或是類別了，我直接在 Program.cs 就放上我的主程式架構:


```csharp

// 模擬實際接收到的 Command 順序 (會按照亂數前後位移)
static IEnumerable<OrderedCommand> GetCommands(int period = 100, int noise = 500) { ... }
        

// 接收到的 Command 結構
public class OrderedCommand
{
    // 流水號，從 0 開始，按照約定必須是連續編號
    public int Position = 0;

    // command 建立的時間
    public DateTime Origin = DateTime.MinValue;

    // command 收到時間
    public DateTime OccurAt = DateTime.MinValue;

    // command 內容說明
    public string Message;
}

```

在 GetCommands() 內, 我會依序產生一連串的 OrderedCommand 的來源，用 IEnumerable<OrderedCommand> 的方式逐筆傳回。其中的規則很簡單，每個 Command 要標示順序 (Position), 預設從 0 開始編號, 一定要是連續流水號。除了標號之外也要標示來源端發出時間 (Origin), 以及模擬網路傳輸，可能造成的隨機延遲 ( 0 ~ {command_noise} msec ) 標示實際收到的時間 (OccurAt)。最終 GetCommands() 傳回的順序，會按照 OccurAt 來排列的，而不是 Origin (意思是會考慮傳輸的隨機延遲後真正收到的順序), 因此你要在後面的階段 (Command Buffer) 想辦法把錯亂的順序修正回來。修正過程中可能會有些狀況，因此你必須盡快的辨識出哪些 Command 能正常送出 (SEND)，那些已收到的 Command 必須被丟棄 (DROP)，那些應該收到但是遲遲未收到的應該被略過 (SKIP)。



### 1-2, 重整訊息順序 ( IReOrderBuffer )

```csharp

    public interface IReOrderBuffer
    {
        public bool Push(OrderedCommand data);
        public bool Flush();

        public event CommandProcessEventHandler CommandIsReadyToSend;
        public event CommandProcessEventHandler CommandWasDroped;
        public event CommandSkipEventHandler CommandWasSkipped;
    }

```

我的構想是: 從 1-1 收到的訊息，都立刻放進 (Push) 能串流重新排序的 IReOrderBuffer，後續的動作都由 IReOrderBuffer 的實做 (就是你要練習的部分) 來決定。你要決定哪些訊息可以被處理，決定好了就透過事件來通知 Command Handler 該做什麼事。這邊定義了三個事件:

1. CommandIsReadyToSend:  
這事件就可以通知 Command Handler, 某個 Command
1. CommandWasDroped:  
Command 已經收到, 但是因為各種原因 (例如收到過去流水號的指令，或是 Buffer 滿了被迫丟棄) 必須放棄處理的通知
1. CommandWasSkipped:  
跟 CommandWasDropped 類似，但是差別在於 Skip 的指令還沒收到 (因此我也不知道內容是啥)，只是從流水號判定中間應該還有存在某些 Command 掉在半路上。同樣，因為這種原因，告知必須略過指定的 Command 事件通知



### 1-3, 處理訊息 ( ExecuteCommand )

這部分就沒什麼了，單純的把 IReOrderBuffer 判定結果後通知的 Command 接過來處理而已，處理前做一點基本的檢查 (順序):

```csharp

        static object _sync_command = new object();
        static int _last_command_position = 0;
        static bool ExecuteCommand(OrderedCommand cmd)
        {
            if (cmd == null) return false;
            if (cmd.Position <= _last_command_position)
            {
                Console.WriteLine("Execute Command Fail: Wrong Orders...");
                return false;
            }

            lock(_sync_command)
            {
                if (cmd.Position <= _last_command_position)
                {
                    Console.WriteLine("Execute Command Fail: Wrong Orders...");
                    return false;
                }
                _last_command_position = cmd.Position;
            }

            Console.WriteLine($"Execute Command: {cmd}");
            return true;
        }

```

既然有 GetCommands(…), 當然也有 ExecuteCommand(…). 經由 GetCommands(…) 收到, 包含隨機的延遲送來的 commands, 經過 Buffer 的處理重新排列後, 依序交給 ExecuteCommand(…) 處理。

這邊收到 Command 該做什麼事，並不是我這篇的重點，所以我只簡單地寫了一段 code, 確保交給 ExecuteCommand(…) 的 command 絕對是按照順序的 (我只 check 先後順序，沒有 check 跳號)。跳號沒有檢查，是因為傳輸的過程中可能真的有掉封包，你連收都收不到。


### 1-4, 監控運作狀態 ( Metrics )

這段我後面實做再補充細節，我只先交代目的。我希望能有類似監控介面來了解這個 Buffer 的運作狀況，於是我先抓了幾個指標 (metrics), 我想要每秒知道這些數據:

- Push: 每秒有多少 command 被 Push 到 Buffer 內
- Pop: 每秒有多少 command 能順利被執行 ( CommandIsReadyToSend 事件發出 )
- Drop: 每秒有多少 command 判定被丟棄 ( CommandWasDropped 事件發出 )
- Drop Rate (%): 丟失率, drop / push x 100%
- Buffer Delay: 因為 Buffer 處理的延遲時間
- Buffer Usage: 因為 Buffer 處理所需的保留 command 空間 (區間最大值)

後面我會模擬幾種狀況，實際跑看看這些數據。不同的實做，我相信這些指標的表現都會有差異，你可以先思考的是你最看重 / 最想優化的指標是哪一個。先能量測才能改善，量測的基礎就是定義指標並且要有能力觀察他。



### 1-5, 牛刀小試

介面都先設計好了，理論上整個系統結構該怎麼交互運作，應該都確定了吧! 先來 TDD (Test Driven Development) 一下，用 Unit Test 來模擬一下我想像的幾個情境:


```csharp

        [TestMethod]
        public void BasicScenario2_OutOfOrderCommand()
        {
            this.SequenceTest(
                100,
                new int[] { 0, 1, 2, 3, 5, 4, 6, 7, 8, 9, 10 },
                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
        }
        
```

這段測試，我人工指定了 command 的接收順序, 留意一下第一個參數是 source_sequence, 別眼花了, 不是照順序安排的, 0 ~ 10 之間, 4 跟 5 的順序是對調的。

我收到這樣的 input, 我期待的結果是整套機制能幫我重新排好, 因此我期待的結果 expected_sequence 是 0 ~ 10 連續排列。

不過別誤會了，這可不是一般排序的作業練習。看不到的時間序背後，你可能拿不到完整資料前，你就必須決定部分結果了。例如我希望收到 0 時，你已經確定 0 是第一個了，你根本不用等待後面的指令，你就可以把 0 送出了。而收到 3 之後接著收到 5, 擬就必須先抓著 5, 等等看待會會不會收到 4, 再一次把 4 & 5 送出去。

因為有串流 & 時間延遲等問題，因此才會有 Metrics 這回事。在結果正確的前提下，你還要想辦法讓這些指標越漂亮越好。因此，來看看 SequenceTest(...) 背後做了什麼:


```csharp

        private void SequenceTest(int buffer_size, int[] source_sequence, int[] expect_sequence)
        {
            IReOrderBuffer buffer = new ReOrderBuffer(buffer_size);

            int count = 0;
            buffer.CommandIsReadyToSend += (sender, args) =>
            {
                Console.WriteLine($"SEND: {sender.Position} - {args.Reason}");
                Assert.AreEqual(expect_sequence[count], sender.Position);
                count++;
            };
            buffer.CommandWasDroped += (sender, args) =>
            {
                Console.WriteLine($"DROP: {sender.Position} - {args.Reason}");
            };
            buffer.CommandWasSkipped += (sender, args) =>
            {
                Console.WriteLine($"SKIP: {sender} - {args.Reason}");
            };

            foreach (var cmd in this.GetBasicCommands(source_sequence))
            {
                bool result = buffer.Push(cmd);
            }

            buffer.Flush();
            Assert.AreEqual(expect_sequence.Length, count);


            var metrics = (buffer as ReOrderBuffer).ResetMetrics();
            Console.WriteLine($"-----------------------------------");
            Console.WriteLine($"Metrics:");
            Console.WriteLine($"- PUSH:          {metrics.push}");
            Console.WriteLine($"- SEND:          {metrics.send}");
            Console.WriteLine($"- DROP:          {metrics.drop}");
            Console.WriteLine($"- SKIP:          {metrics.skip}");

            Console.WriteLine($"- Command Delay: {metrics.delay / metrics.push:0.000} msec");
            Console.WriteLine($"- Buffer Usage:  {metrics.buffer_max}");
        }


```

準備好 IReOrderBuffer 的實做之後，把物件產生出來，設定好各種事件 (CommandIsReadyToSend, CommandWasDropped, CommandWasSkipped) 該怎麼處理, 之後就是從 GetBasicCommands() 逐一把 Command 放 (Push) 進 IReOrderBuffer 就結束了。

我在 CommandIsReadyToSend 的 event hander 內埋了一點 code, 用來比對跟 expected_sequence 是否一致:

```csharp

int count = 0;
buffer.CommandIsReadyToSend += (sender, args) =>
{
    Console.WriteLine($"SEND: {sender.Position} - {args.Reason}");
    Assert.AreEqual(expect_sequence[count], sender.Position);
    count++;
};

```

不一樣的話，Assert 就會讓整個 Unit Test 的框架回報給我測試失敗了。這大家應該都熟了，我就不多說。後面我多印了一點輔助資訊，不影響測試是否通過，不過有助於了解執行狀況，我先貼一下執行這個單元測試的 test output:

```text

BasicScenario2_OutOfOrderCommand
   Source: BasicOrderedTests.cs line 21
   Duration: 10 ms


Standard Output: 
SEND: 0 - SEND_PASSTHRU
SEND: 1 - SEND_PASSTHRU
SEND: 2 - SEND_PASSTHRU
SEND: 3 - SEND_PASSTHRU
SEND: 4 - SEND_PASSTHRU
SEND: 5 - SEND_BUFFERED
SEND: 6 - SEND_PASSTHRU
SEND: 7 - SEND_PASSTHRU
SEND: 8 - SEND_PASSTHRU
SEND: 9 - SEND_PASSTHRU
SEND: 10 - SEND_PASSTHRU
-----------------------------------
Metrics:
- PUSH:          11
- SEND:          11
- DROP:          0
- SKIP:          0
- Command Delay: 0.132 msec
- Buffer Usage:  1

```

細節後面都會再交代，這 test output 看幾個重點就好:

1. **看時間序**  
總共印出了 11 行 ( 0 ~ 10 ) SEND, 背後有標記 SEND 的 "原因"。除了 #5 是 "SEND_BUFFERED" 之外，其他的原因都是 "SEND_PASSTHRU"。這代表 #5 是預先被收到並暫存在 Buffer 內，延遲一段時間才被送出執行的，其他都是接收到直接轉送 (穿透: PASSTHRU) 立刻執行。
2. **看統計**  
#5 被暫存, 因此他的延遲可能特別高一點，最後 Command Delay 顯示的是所有 Command 的平均延遲, 演算法沒調好的人 (假設你用很蠢的方式全部收完再排序一次送出，延遲就會很難看)。另外其他的統計，Buffer Usage 代表過程中你 Buffer 最大放了多少站存 Command 在裡面，以及 PUSH / SEND / DROP / SKIP 的次數統計..

其他還好幾個測試 (到目前為止我寫了 13 個)，我就不一個一個貼了，後面有需要再調出來看






## 2. 環境模擬

基礎結構定義好之後，我開始來設計環境模擬的部分了。

前面 1-1 提到，我用 GetCommands() 來代表外界收到的一連串 Commands, 參數 boost 代表要不要真正花時間去等待延遲，不要加速的話，你看他一行一行訊息跳出來的時間會比較有真實感，加速的話就跳過等待時間了，可以跑快一點。


### 2-1. 模擬網路傳輸延遲 (隨機)

我在裡面設置了一些機關，每個 Command 都有可能有些 "飄移”，先看看 code:

```csharp

        static IEnumerable<OrderedCommand> GetCommands(int period = 100, int noise = 500)
        {
            int total_count = 1000;
            TimeSpan cmd_period = TimeSpan.FromMilliseconds(period);
            int cmd_noise = noise;

            List<OrderedCommand> orders = new List<OrderedCommand>();
            DateTime start = DateTimeUtil.Instance.Now.AddSeconds(1.0); // warn up time

            Random rnd = new Random(867);

            for (int i = 0; i < total_count; i++)
            {
                //if (rnd.Next(100) == 0)
                //{
                //    Console.WriteLine($"RANDOM-LOST: {i}");
                //    continue;   // 1% lost rate
                //}

                //
                // todo: 隨機可以改成高斯分布
                //
                var order = new OrderedCommand()
                {
                    Position = i,
                    Origin = start + cmd_period * i,
                    OccurAt = start + cmd_period * i + TimeSpan.FromMilliseconds(rnd.Next(cmd_noise)), 
                    Message = $"CMD-{i:#00000}"
                };
                orders.Add(order);
            }

            int check_count = 0;
            foreach (var c in (from x in orders orderby x.OccurAt ascending select x))
            {
                DateTimeUtil.Instance.TimeSeek(c.OccurAt);
                check_count++;
                yield return c;
            }

            Console.WriteLine($"CHECK-COUNT: {check_count}, {orders.Count}");
        }

```

這邊為了重複測試，所以隨機 Random 我特地給固定的種子，希望每次跑的亂數表都是一樣的，這樣調整才看得出效果。很多這種 POC 驗證用途的 code, 你不能用一般 production code 的規範來要求他，因為目的完全不同，這就是一例。

我為了 GetCommands(...) 產生模擬用的 OrderedCommand 序列, 定了兩個參數，分別是產生週期 (int period = 100), 跟傳輸的干擾雜訊強度 (int noise = 500)。我用一張圖來說明:


![](/wp-content/images/2023-10-01-reorder/2023-10-09-19-21-14.png)


在上圖的例子, #1 在 Command Source 時間線產生的時間點就是 {#1}.Origin, 而傳送到 Command Buffer 端的時間點就是 {#1}.OccurAt, 中間的時間差就是 Delay (msec). 而 GetCommand 的第一個參數 period (單位 msec)，是說每個 Command 在 Command Source 端間隔多久會被發出。

第二個參數 noise 則代表每個 Command 的延遲 (delay) 都會落於 0 msec ~ {noise} msec 的範圍內, 隨機分布 (其實我有寫註解，這邊應該用高斯分布會更好一點，不過我一時偷懶就沒補上這段 code)。給定這兩個參數後，GetCommands(...) 就會用這樣的條件，幫你產生 1000 筆連續的 Command 序列。

試想一下，你有可能碰到圖上 #2 跟 #3 的例子: 當 #2 延遲了很久才送到，#3 很快就送到了。只要 period 夠小, noise 夠大, 你碰到的機會就越大。極端一點你會碰上 #5 都收到了，#2 還沒收到的例子。這時 Buffer 的大小就很重要，我保留這些參數就是後面打算觀察這些行為。


### 2-2. 模擬網路傳輸丟失請求

另外我中間也註解掉一段，後面會再打開。我也模擬了一定機率的 Command 會憑空消失，你等多久都收不到的情況。如果你有仔細看我前面的 Unit Test 那 13 個測試案例，其中有兩個就是模擬這狀況，我先貼 code:

```csharp

        [TestMethod]
        public void BasicScenario5_LostCommand()
        {
            this.SequenceTest(
                100,
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 },
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 });
        }

        [TestMethod]
        public void BasicScenario13_BufferLimitAndLostCommand()
        {
            this.SequenceTest(
                3,
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 },
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 });
        }

```

一模一樣的案例，都是測試 #0 ~ #10, 中間掉了 #5 的情況，差別只是 Buffer 不一樣大 (從這案例可以知道, Buffer 並不是越大越好)。你可以想像這行為也是隨機的，就是我拿掉的那段 code 想表達的意義。

我印一小段產生出來的 Command 序列，驗證一下我上面的描述 (參數是 period = 30, noise = 500):

```text

PUSH: #1,  Origin: 00:00:01.039, OccurAt: 00:00:01.144, Delay: 105.000 msec
PUSH: #5,  Origin: 00:00:01.159, OccurAt: 00:00:01.273, Delay: 114.000 msec
PUSH: #10, Origin: 00:00:01.309, OccurAt: 00:00:01.327, Delay:  18.000 msec
PUSH: #0,  Origin: 00:00:01.009, OccurAt: 00:00:01.343, Delay: 334.000 msec
PUSH: #8,  Origin: 00:00:01.249, OccurAt: 00:00:01.368, Delay: 119.000 msec
PUSH: #6,  Origin: 00:00:01.189, OccurAt: 00:00:01.374, Delay: 185.000 msec
PUSH: #3,  Origin: 00:00:01.099, OccurAt: 00:00:01.405, Delay: 306.000 msec
PUSH: #7,  Origin: 00:00:01.219, OccurAt: 00:00:01.420, Delay: 201.000 msec
PUSH: #4,  Origin: 00:00:01.129, OccurAt: 00:00:01.451, Delay: 322.000 msec
PUSH: #2,  Origin: 00:00:01.069, OccurAt: 00:00:01.464, Delay: 395.000 msec
PUSH: #11, Origin: 00:00:01.339, OccurAt: 00:00:01.512, Delay: 173.000 msec
PUSH: #19, Origin: 00:00:01.579, OccurAt: 00:00:01.589, Delay:  10.000 msec
PUSH: #20, Origin: 00:00:01.609, OccurAt: 00:00:01.616, Delay:   7.000 msec
PUSH: #18, Origin: 00:00:01.549, OccurAt: 00:00:01.622, Delay:  73.000 msec
PUSH: #16, Origin: 00:00:01.489, OccurAt: 00:00:01.645, Delay: 156.000 msec
PUSH: #13, Origin: 00:00:01.399, OccurAt: 00:00:01.664, Delay: 265.000 msec
PUSH: #12, Origin: 00:00:01.369, OccurAt: 00:00:01.695, Delay: 326.000 msec

```



### 2-3. 用 Buffer 串接來源與目的地

若把這些 code 都組在一起 ( Command Source + Buffer + Handler )，整合起來的用法大概像這樣:


```csharp


        static void Demo2_ExecuteCommandWithReorderBuffer()
        {
            int command_period = 100;
            int command_noise = 500;
            int buffer_size = 10;

            DateTimeUtil.Init(new DateTime(2023, 09, 16));
            IReOrderBuffer ro = new ReOrderBuffer(buffer_size);

            // 略, 每秒鐘會讀取一次 ro 的 metrics 寫成 csv
            DateTimeUtil.Instance.RaiseSecondPassEvent += (sender, args) =>
            {
                // write metrics
            };

            ro.CommandIsReadyToSend += (sender, args) =>
            {
                ExecuteCommand(sender);
            };

            foreach (var item in GetCommands(command_period, command_noise))
            {
                ro.Push(item);
            }
            ro.Flush();

            // 略, 印出執行過程中的 metrics 統計
        }

```

我拿掉處理 metrics 部分的 code 了，因為那些不影響主流程，這樣用法應該就清楚了，基本上跟剛才看到的單元測試差不多用法，準備好 Buffer, 把 GetCommands() 抓到的東西都 Push() 進去, 等著 Buffer 的事件通知去處理就好，我就不多解釋。




### 2-4. 模擬監控機制

回頭來看看被略過的 Metrics:

```csharp

            int _log_sequence = 0;
            Console.Error.WriteLine($"TimeInSec,Push,Send,Drop,Skip,BufferMax,Delay");

            var overall_metrics = (ro as ReOrderBuffer).ResetMetrics();
            DateTimeUtil.Instance.RaiseSecondPassEvent += (sender, args) =>
            {
                // write metrics
                Interlocked.Increment(ref _log_sequence);
                var metrics = (ro as ReOrderBuffer).ResetMetrics();
                double avg_latency = 0;
                if (metrics.send > 0) avg_latency = metrics.delay / metrics.send;
                Console.Error.WriteLine($"{_log_sequence},{metrics.push},{metrics.send},{metrics.drop},{metrics.skip},{metrics.buffer_max},{avg_latency}");
            };

```

這邊我用懶人的做法，什麼套件都不用，用我 20 年前就在用的伎倆... 我把 CSV 的內容寫到 Standard Error, 你看到的第二行就是 CSV 的擋頭欄位名稱，後面每秒就把 metrics 照欄位，用逗號分隔印出來。

雖然這些都會被混在 console 上面，不過實際上 Standard Output 跟 Standard Error, 是兩個獨立的串流, 你用 pipeline 可以分別導向到檔案。

你想把 Stdout 轉到檔案，可以用 > 來做:

```shell

dotnet run > myfile.txt

```

而如果你想把 Stderr 轉到檔案，則可以用 2> 來做 (就是第二個串流的意思):

```shell

dotnet run 2> myerror.txt

```


而我準備了這個 windows command prompt 用的批次檔 (不是 powershell, 我真的是老人 XDD):

```cmd

cls
rd /s /q output
mkdir output

:: Usage: dotnet run {command period in msec} {command noise} {buffer size}

dotnet run 100 100  100 2> output\metrics-100-100-100.csv
dotnet run 100 200  100 2> output\metrics-100-200-100.csv
dotnet run 100 300  100 2> output\metrics-100-300-100.csv
dotnet run 100 400  100 2> output\metrics-100-400-100.csv
dotnet run 100 500  100 2> output\metrics-100-500-100.csv
					 						  
dotnet run  70 100  100 2> output\metrics-070-100-100.csv
dotnet run  70 200  100 2> output\metrics-070-200-100.csv
dotnet run  70 300  100 2> output\metrics-070-300-100.csv
dotnet run  70 400  100 2> output\metrics-070-400-100.csv
dotnet run  70 500  100 2> output\metrics-070-500-100.csv
					 						  
dotnet run  30 100  100 2> output\metrics-030-100-100.csv
dotnet run  30 200  100 2> output\metrics-030-200-100.csv
dotnet run  30 300  100 2> output\metrics-030-300-100.csv
dotnet run  30 400  100 2> output\metrics-030-400-100.csv
dotnet run  30 500  100 2> output\metrics-030-500-100.csv

```

跑完後我就可以去收結果的 .csv 了。這技巧我過去用過好幾次了，常看我文章的朋友們應該不陌生，用 EXCEL 打開，加上簡單的圖表，你就可以看到這些每秒印出一筆的 metric 展現的樣子:


![](/wp-content/images/2023-10-01-reorder/2023-10-09-19-55-31.png)

我刻意切一些 EXCEL 的畫面，背後的數字就是 CSV 來的。這樣做的目的很單純，將來如果這是個重要的系統，我一定得監控他才行。甚至我在 POC 的時候我就想要監控了。但是，如果你現在就要把 metric 寫到監控系統，這對架構師來說太折磨了 XDD，我重點不是要整合到監控系統，而是我想在 POC 階段就思考我該看那些 metrics, 我想知道我的設計在模擬的情況下，這些 metrics 會有甚麼表現。

因此這做法，就完美的模擬了以後系統真的上線後，我想要看的 dashboard. 我現在在意的是:

1. 我是否抓對指標?
1. 實際模擬跑起來的狀況?

透過這幾行 code 的技巧，我完全可以把整套系統的設計思路，控制在 500 行 code 內，單機就能重複模擬執行的複雜度內。這些都滿意了，再交給執行團隊，幫我把它變成真正能上線的系統。

環境模擬到這邊大概都告一段落，萬事俱備，剩下的就等你怎麼實做 IReOrderBuffer 介面了!

如果你想自己挑戰看看，先看到這邊就別往下看了，可以抓我的 code 回去自己挑戰看看。當然我的實做也跳過很多進階的功能，你也可以看完我後面的基本實做，然後再改進補上我沒做完的部分。

準備好的話就往下看，這次看看 IReOrderBuffer 我的設計思考方式



## 3. Reordering Buffer 的設計

回到主軸，IReOrderBuffer 的設計。前面提到這個介面的用法，也先用測試案例示範怎麼運用這個 interface 了 (還真的是測試驅動開發 + Contract First 啊)，我這段打算用這幾個主軸來談:

1. interface + event definition
1. data structure & settings
1. push - core logic, 驅動整個 buffer 運作的主要引擎
1. (不談) 另一個驅動的引擎 timer
1. metrics, 檢視引擎運作狀況的儀表板
1. adapters, 整合引擎 (push)，資料結構 與事件


然而，從需求面來看，我這次不會處理所有問題。我先挑最關鍵的主結構，其他能延伸出去處理的議題，我就暫時略過，留給各位練習的機會 (其實是我懶而已 XDD，有機會再補下一篇的話我再追加)。

我接下來的示範，我會處理這些範圍:
1. 重新排列序列
1. 控制 Buffer Size
1. 處理掉訊息的機制

我不會處理這些需求:
1. 訊息重送的處理機制 (同一個訊息送兩次)
1. 精準的時間控制 (例如: 都沒有新訊息進來，但是有訊息超時了也能主動 DROP / SKIP)
1. 訊息過期的處理



既然介面是重點，那再貼一次吧，沒幾行多貼一次省的還要捲回去看:

```csharp

    public interface IReOrderBuffer
    {
        public bool Push(OrderedCommand data);
        public bool Flush();

        public event CommandProcessEventHandler CommandIsReadyToSend;
        public event CommandProcessEventHandler CommandWasDroped;
        public event CommandSkipEventHandler CommandWasSkipped;
    }

```

為了讓這些介面能夠順利動起來，是需要上面那些東西一起串起來的，我拿掉實做，只留下定義跟類別簽章:

```csharp

    public class ReOrderBuffer : IReOrderBuffer
    {
        // data structure & settings
        private int _current_next_index = 0;
        private SortedSet<OrderedCommand> _buffer = new SortedSet<OrderedCommand>(new OrderedCommandComparer());
        protected readonly int _buffer_size = 0;

        public ReOrderBuffer(int buffer_size_limit) { ... }

        // IReOrderBuffer interface
        bool IReOrderBuffer.Push(OrderedCommand data) { ... }
        bool IReOrderBuffer.Flush() { ... }
        event CommandProcessEventHandler IReOrderBuffer.CommandIsReadyToSend { ... }
        event CommandProcessEventHandler IReOrderBuffer.CommandWasDroped { ... }
        event CommandSkipEventHandler IReOrderBuffer.CommandWasSkipped { ... }

        // metrics
        private int _metrics_total_push = 0;
        private int _metrics_total_send = 0;
        private int _metrics_total_drop = 0;
        private int _metrics_total_skip = 0;
        private int _metrics_buffer_max = 0;
        private double _metrics_buffer_delay = 0.0;

        public (int push, int send, int drop, int skip, int buffer_max, double delay) ResetMetrics() { ... }

        // adapters
        protected bool Send(OrderedCommand data, CommandProcessReasonEnum reason) { ... }
        protected bool Drop(OrderedCommand data, CommandProcessReasonEnum reason) { ... }
        protected bool Skip(int position, CommandProcessReasonEnum reason) { ... }
    }


```


### 3-1, 用 Buffer 來 Re-Order Command 的規則

整個 Buffer 的核心邏輯，還是在演算法身上。我就先從怎麼用 Buffer 來處理 command 的規則說起好了，我看了一些相關文章介紹，盡可能剝掉不必要的細節 (那些可以以後再加回去) 留下關鍵的規則。這個題目從一開始，都是希望有個 ReOrderBuffer 來處理重新排序的問題，給他限制資源 (這就是資料結構問題)，只能暫存一定時間內的 command (這就是核心邏輯問題), 弄清楚資源必須準備多少 (這就是時間跟空間複雜度問題)，超過這範圍的 command 就得丟棄。

因此一切設計都從這裡開始，我多描述一點串流排序的做法。來看這個案例，如果我收到的 command 順序是這樣:

#1, #3, #4, #2

則:
- 收到 #1 會立即執行 #1
- 收到 #3 偵測到缺 #2, 所以 #3 會先被保留起來
- 同上，收到 #4 也會被保留起來
- 收到 #2 會立即執行 #2, 執行後檢查 buffer, 發現連續的 #3, #4 也都在, 就會緊接著執行

用時間序 (從上到下) 來對比收到的跟執行的順序:

| time sequence | push | execute | buffered |
| --- | --- | --- | --- |
| 1 | #1 | #1 |  |
| 2 | #3 |  | #3 |
| 3 | #4 |  | #3, #4 |
| 4 | #2 | #2, #3, #4 |  |

還記得前面的 Unit Test 嗎? 我事後也用我自己寫的 Unit Test 跑了這個 case 14, 輸出就當作對照組:
(每次 PUSH 可能都會引發接續的 SEND / DROP / SKIP 動作, 這些動作結束後會印出 Buffer 內的清單)



測試案例 #14: BasicScenario14_ArticleDemo1

```csharp

        [TestMethod]
        public void BasicScenario14_ArticleDemo1()
        {
            this.SequenceTest(
                100,
                new int[] { 0, 1, 3, 4, 2 },
                new int[] { 0, 1, 2, 3, 4 });
        }

```



測試輸出訊息:

```text

PUSH: 0
SEND: 0 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 1
SEND: 1 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 3
      (Buffer: 3)
PUSH: 4
      (Buffer: 3, 4)
PUSH: 2
SEND: 2 - SEND_PASSTHRU
SEND: 3 - SEND_BUFFERED
SEND: 4 - SEND_BUFFERED
      (Buffer: --)

```

果然，寫 code 沒那麼複雜的話，寫 code 比寫文章輕鬆啊 XDD, 再來看複雜一點的例子，如果我收到的順序是: #1, #3, #5, #2, #6, #4, #7, #8 的話

| time sequence | push | execute | buffered |
| --- | --- | --- | --- |
| 1 | #1 | #1 |  |
| 2 | #3 |  | #3 |
| 3 | #5 |  | #3, #5 |
| 4 | #2 | #2, #3 | #5 |
| 5 | #6 |  | #5, #6 |
| 6 | #4 | #4, #5, #6 |  |
| 7 | #7 | #7 |  |
| 8 | #8 | #8 |  |



對照組 測試案例 #15, BasicScenario15_ArticleDemo2

```csharp

        [TestMethod]
        public void BasicScenario15_ArticleDemo2()
        {
            this.SequenceTest(
                100,
                new int[] { 0, 1, 3, 5, 2, 6, 4, 7, 8 },
                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 });
        }

```



```text

PUSH: 0
SEND: 0 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 1
SEND: 1 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 3
      (Buffer: 3)
PUSH: 5
      (Buffer: 3, 5)
PUSH: 2
SEND: 2 - SEND_PASSTHRU
SEND: 3 - SEND_BUFFERED
      (Buffer: 5)
PUSH: 6
      (Buffer: 5, 6)
PUSH: 4
SEND: 4 - SEND_PASSTHRU
SEND: 5 - SEND_BUFFERED
SEND: 6 - SEND_BUFFERED
      (Buffer: --)
PUSH: 7
SEND: 7 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 8
SEND: 8 - SEND_PASSTHRU
      (Buffer: --)

```



以上，是靠 Buffer, 將順序不對但是先接收到的 Command 暫存起來，然後適當時機再送出去的邏輯，你就想像你在玩牌，等著抽到缺的那張關鍵牌，抽到後就能整個排組打出去的感覺，你手上的手牌就是 Buffer, 你的出牌技巧就是演算法。你得判斷哪些牌要留久一點 (要賭)，那些要盡快出出去。



### 3-2, Buffer Size 越大越好嗎?

接下來，考慮一個複雜一點的狀況: 掉訊息

掉訊息困難的地方在於: 在當下你不會知道這訊息是已經掉了，還是只是晚一點才會拿到。已經掉了的話你越早放棄他 (SKIP) 越好，反正你等再久也等不到，早點放棄可以用更低的 Buffer，也能讓後面的訊息更早發出去；

晚一點到的話你等他越久越好，你的訊息完整性會更好 (都不用放棄任何一個訊息)，但是你需要更大的 Buffer, 暫存更多 Command 在 Buffer 內，也會讓更多 Command 的延遲提高，有可能違背你對整個系統的 SLO 期待。

決策的部分下一章在聊，這段先聊做法。我用這兩個測試案例來說明。直接看測試案例 #5 跟 #13，兩者安排的 source_sequence 完全一樣，都是 #0 ~ #10, 但是中間少掉 #5，而兩個案例只差在 Case #5 的 Buffer Size 給很夠 (100), 另一個 Case #13 則給剛剛好不夠的大小 (3)，來看看預期的反應:


測試案例 #5: BasicScenario5_LostCommand

```csharp

        [TestMethod]
        public void BasicScenario5_LostCommand()
        {
            this.SequenceTest(
                100,
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 },
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 });
        }

```

跑出來的結果:


| time sequence | push | execute | buffered |
| --- | --- | --- | --- |
|  1   |  #0   |  #0   |     |
|  2   |  #1   |  #1   |     |
|  3   |  #2   |  #2   |     |
|  4   |  #3   |  #3   |     |
|  5   |  #4   |  #4   |     |
|  6   |  #6   |     |  #6   |
|  7   |  #7   |     |  #6, #7   |
|  8   |  #8   |     |  #6, #7, #8   |
|  9   |  #9   |     |  #6, #7, #8, #9   |
|  10   | #10    |     | #6, #7, #8, #9, #10    |
|  11   | (flush) | #5(skip), #6, #7, #8, #9, #10    |     |


```text
  Standard Output: 
PUSH: 0
SEND: 0 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 1
SEND: 1 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 2
SEND: 2 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 3
SEND: 3 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 4
SEND: 4 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 6
      (Buffer: 6)
PUSH: 7
      (Buffer: 6, 7)
PUSH: 8
      (Buffer: 6, 7, 8)
PUSH: 9
      (Buffer: 6, 7, 8, 9)
PUSH: 10
      (Buffer: 6, 7, 8, 9, 10)
SKIP: 5 - SKIP_BUFFERFULL
SEND: 6 - SEND_BUFFERED
SEND: 7 - SEND_BUFFERED
SEND: 8 - SEND_BUFFERED
SEND: 9 - SEND_BUFFERED
SEND: 10 - SEND_BUFFERED
-----------------------------------
Metrics:
- PUSH:          10
- SEND:          10
- DROP:          0
- SKIP:          1
- Command Delay: 0.451 msec
- Buffer Usage:  5

```

因為 Buffer 夠大 (處理過程需要 5, 這案例給 100), 所以看起來為了等 #5 進來等了很久，連 #10 都收到了還在等，要不是測試已經跑到最後一步強迫呼叫 Flush() 來清光 Buffer, 這 case 可能還會繼續等下去。試想一個極端的 case, 如果你有 1000 或更大的 Buffer, 而你的 Command 從 #0 ~ #1000, 你只掉了 #5, 這麼大的 Buffer 會導致你把整個序列都放進 Buffer, 而 #5 以後的 Command 你一個也送不出去，直到 Flush() 為止.. (這不見得是你期待的結果)。



再來看測試案例 #13, BasicScenario13_BufferLimitAndLostCommand, 一樣的輸入, 只是我故意把 Buffer 限縮到只有 3, 要呈現 Buffer 不夠處理強迫丟棄的情境:


```csharp


        [TestMethod]
        public void BasicScenario13_BufferLimitAndLostCommand()
        {
            this.SequenceTest(
                3,
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 },
                new int[] { 0, 1, 2, 3, 4,    6, 7, 8, 9, 10 });
        }

```





跑出來的結果:


| time sequence | push | execute | buffered |
| --- | --- | --- | --- |
|  1   |  #0   |  #0   |     |
|  2   |  #1   |  #1   |     |
|  3   |  #2   |  #2   |     |
|  4   |  #3   |  #3   |     |
|  5   |  #4   |  #4   |     |
|  6   |  #6   |     |  #6   |
|  7   |  #7   |     |  #6, #7   |
|  8   |  #8   |     |  #6, #7, #8   |
|  9   |  #9   | #5(skip), #6, #7, #8, #9    |     |
|  10   | #10    |  #10    |     |
|  11   | (flush) |     |     |



```text

Standard Output: 
PUSH: 0
SEND: 0 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 1
SEND: 1 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 2
SEND: 2 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 3
SEND: 3 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 4
SEND: 4 - SEND_PASSTHRU
      (Buffer: --)
PUSH: 6
      (Buffer: 6)
PUSH: 7
      (Buffer: 6, 7)
PUSH: 8
      (Buffer: 6, 7, 8)
PUSH: 9
SKIP: 5 - SKIP_BUFFERFULL
SEND: 6 - SEND_BUFFERED
SEND: 7 - SEND_BUFFERED
SEND: 8 - SEND_BUFFERED
SEND: 9 - SEND_BUFFERED
      (Buffer: --)
PUSH: 10
SEND: 10 - SEND_PASSTHRU
      (Buffer: --)
-----------------------------------
Metrics:
- PUSH:          10
- SEND:          10
- DROP:          0
- SKIP:          1
- Command Delay: 0.015 msec
- Buffer Usage:  3


```

這是另一個極端的例子，Buffer 給的很小 (Size 只有 3)，因此等不了多久，才收到 #8 就決定要放棄等待 #5, 直接 SKIP(#5), 後面就一路順暢了。整體 Buffer 佔用空間很少，延遲也很低。但是如果 #5 在 #9 後面才出現，你收到也沒用，被迫得 DROP(#5) 了，相較 Buffer 夠大的情況下，能夠完全沒有 DROP command 的情況下完成任務。

請牢記這 Buffer 的作法，與這幾個 Test Case, 用這些案例套用待會的 code 你才能理解為何 code 需要這樣安排。演算法就先聊到這邊，接下來看 code...




### 3-3. 資料結構


為了實做上面那些演算法，我在 ReOrderBuffer.cs 這類別實做了 IReOrderBuffer 這介面，並且宣告了這些 private variable, 主要就是要建構能處理上述那些案例的 data structure (包含 settings), 我貼這部分的 code:

```csharp

    public class ReOrderBuffer : IReOrderBuffer
    {
        // data structure & settings
        private int _current_next_index = 0;
        private SortedSet<OrderedCommand> _buffer = new SortedSet<OrderedCommand>(new OrderedCommandComparer());
        protected readonly int _buffer_size = 0;


        // metrics
        private int _metrics_total_push = 0;
        private int _metrics_total_send = 0;
        private int _metrics_total_drop = 0;
        private int _metrics_total_skip = 0;
        private int _metrics_buffer_max = 0;
        private double _metrics_buffer_delay = 0.0;

        public (int push, int send, int drop, int skip, int buffer_max, double delay) ResetMetrics() { ... }
    }

```

資料結構這部分很單純，我只宣告了一個變數 ```int _current_next_index```, 用來標記照順序的話下一個 Command Position 應該是哪個；另外我宣告了一個 SortedSet<OrderedCommand> 來代表佔存那些已經收到，但是還無法處理的 Command 用的 Buffer 而已。我用了 SortedSet<T>, 它可以幫我排序 (為了讓他自動排序，所以我替 OrderedCommand 實做了 IComparer<T> 介面)，同時 Set 會幫我排除相同的 Command. 如果將來我還需要實做排除已經略過的 Command, .NET 的 SortedSet<T> 還能支援我做各種交集 (Interset)、聯集 (Union) 等等集合的運算。不過這次還用不到，點到為止。

附上為了讓 SortedSet 能正常運作，補上的 IComparer 實做:

```csharp

    public class OrderedCommandComparer : IComparer<OrderedCommand>
    {
        public int Compare([AllowNull] OrderedCommand x, [AllowNull] OrderedCommand y)
        {
            return x.Position.CompareTo(y.Position);
        }
    }
    
```

而 Buffer 的運作，需要一些來自外部的設定。在 3-2 聊了一些 Buffer 大小的選擇，就是其中之一 (目前也只有這個)，就是 int _buffer_size, 這變數決定了 SortedSet<T> 的容量上限，超過了你還 PUSH 的話，Buffer 就應該觸發 SKIP 的機制，預先略過部分可能等不到它的 command.

理論上這些範圍限制也需要包含時間，不過這次略過時間，有機會再回過頭聊這個主題時再補上這部分。


### 3-4, 監控指標 Metrics

為了監控這整個過程的運作，我設置了六個監控指標:

```csharp

        // metrics
        private int _metrics_total_push = 0;
        private int _metrics_total_send = 0;
        private int _metrics_total_drop = 0;
        private int _metrics_total_skip = 0;
        private int _metrics_buffer_max = 0;
        private double _metrics_buffer_delay = 0.0;


        public (int push, int send, int drop, int skip, int buffer_max, double delay) ResetMetrics()
        {
            return (
                Interlocked.Exchange(ref this._metrics_total_push, 0),
                Interlocked.Exchange(ref this._metrics_total_send, 0),
                Interlocked.Exchange(ref this._metrics_total_drop, 0),
                Interlocked.Exchange(ref this._metrics_total_skip, 0),
                Interlocked.Exchange(ref this._metrics_buffer_max, 0),
                Interlocked.Exchange(ref this._metrics_buffer_delay, 0));
        }

```

在 Buffer 運作的過程中，隨時都會更新這六個數值，其中四個 ( push, send, drop, skip ) 是單純的 counter, 而 buffer_max 則是只保留最大值的指標, delay 則是保留所有 send 的 command 的 delay 時間總和。

為了能方便取用，我設計了一個 method: ResetMetrics(), 它能同時歸零這六個指標，同時把歸零前那瞬間的數值傳回來。我這邊特地用了 Interlocked 的技巧來實做，不是說我的 POC 負載有多高，會碰到 racing condition 等狀況，而是這是我自己用來提醒以後所有看到這段 code 的人，POC 高度簡化的環境，很多問題都會被遮蔽，而我習慣用 "降級" 的技巧來簡化問題，這樣寫是提醒我，未來我真的把這些 metrics 搬出去 (例如放到 Redis), 這是提醒我我應該要用同等規格，用正確地 Redis 指令來操作它們 (Redis 也有 [GETSET](https://redis.io/commands/getset/) 這指令可以直接對應 Interlocked.Exchange, 這在計算機科學裡面, 聊到作業系統的多工處理, 都是很基本的課題)


題外話，如果你有參加我在 DevOpsDays Taipei 2023 的 Keynote Speech 的話，我提到的維運設計，就是指這樣的思路。



### 3-5. Push() , 驅動 Buffer 運作的引擎

直接來看最核心的部分，也是驅動整個 ReOrderBuffer 的主要 method: Push()

規格跟定義清楚後，code 其實不難寫，邏輯重點抓好就好了。我移除非關鍵的 code, 直接來看 ReOrderBuffer 的實作。我只貼Buffer 本身的資料結構，以及驅動整個 Buffer 運作的 Push():


```csharp

    public class ReOrderBuffer : IReOrderBuffer
    {
        private int _current_next_index = 0;
        private SortedSet<OrderedCommand> _buffer = new SortedSet<OrderedCommand>(new OrderedCommandComparer());
        protected readonly int _buffer_size = 0;


        public ReOrderBuffer(int buffer_size_limit)
        {
            this._buffer_size = buffer_size_limit;
        }


        bool IReOrderBuffer.Push(OrderedCommand data)
        {
            this._metrics_total_push++;
            this._metrics_buffer_max = Math.Max(this._metrics_buffer_max, this._buffer.Count);

            if (data.Position < this._current_next_index)
            {
                // drop
                this.Drop(data, CommandProcessReasonEnum.DROP_OUTOFORDER);
                return false;
            }
            else 
            {
                if (data.Position == this._current_next_index)
                {
                    this.Send(data, CommandProcessReasonEnum.SEND_PASSTHRU);
                    this._current_next_index = data.Position + 1;
                }
                else
                {
                    this._buffer.Add(data);
                }

                do
                {
                    if (this._buffer.Count > this._buffer_size && this._current_next_index < this._buffer.Min.Position)
                    {
                        // skip:
                        this.Skip(this._current_next_index, CommandProcessReasonEnum.SKIP_BUFFERFULL);
                        this._current_next_index++;
                    }
                    while (this._buffer.Count > 0 && this._current_next_index == this._buffer.Min.Position)
                    {
                        var m = this._buffer.Min;
                        this._buffer.Remove(m);
                        this.Send(m, CommandProcessReasonEnum.SEND_BUFFERED);
                        this._current_next_index++;
                    }
                } while (this._buffer.Count > this._buffer_size);

                this._metrics_buffer_max = Math.Max(this._metrics_buffer_max, this._buffer.Count);
                return true;
            }
        }

        
    }

```



目前的版本，由於都是由 Push() 驅動，所以寫起來很單純。實際狀況則都是跟時間賽跑啊，我舉個情境，如果照 #1, #3, #2, #4 順序 PUSH, 而輸入 #1, #3 的時候就停了, 如果你想要保證 500ms 內回應, 所以需要在完全沒有任何 input (push) 的情況下, 主動 Skip #2, 才能讓早已收到的 #3 能快點被處理的話該怎麼辦?

這時，就不能只單靠 Push() 來驅動了，必須有另一條管道是由時間 (timer) 來驅動的途徑才辦的到。不過我前面就講了, 這暫時不再我這次要實做的範圍內，跟時間相關的機制，各位有興趣可以挑戰看看，也歡迎發 PR 給我 XDD, 不然就等我哪天想到了再來補後半段..

上面這段 code 也不長，我猜各為自己看 code 應該也能看得懂。前面說明過資料結構，這時 Push() 的內容就很明瞭了，收到 Command, 先排除完全不處理 (早就過號的) Command, 剩下的就分兩路，一個是 position 正好就是下一個, 馬上就 SEND_PASSTHRU 轉發出去了。

接下來，不管是不是直接轉發，或是被存起來，後面的動作就一致，看看補上了目前這個 Command 之後，Buffer 內是否有能夠一起跟著送出去的 Command? (就是 SEND_BUFFERED 的狀況)

這時，如果 Buffer 已經滿了，就要做額外的裁定了。如果 Buffer 還沒滿，就繼續暫存無所謂，如果已經滿了，而你卻又在等待某個號碼補進來，這時你就被迫得立刻做決定了。我的選擇是優先保留已經收到的 command (順位比較大的)，而選擇放棄不再等待下一個就要執行，但是卻還沒進來的 command. 原因是網路不穩定的話，這個 command 可能永遠不會進來，我可能賠了夫人又折兵。另外，丟掉後面的 command, 也可能造成連鎖效應，等到我要處理到後面的時候，又會面臨那個 command 也不會再進來了，丟失 command 會變成連鎖反應越滾越大..



結果好壞後面再說，這裡是要讓各位了解判斷的邏輯。規則弄清楚了，對照著 code 大概就能理解背後的邏輯，我就不逐行解釋了。

會驅動整個 Buffer 運作的，除了 PUSH 之外，另一個就是 Flush, Flush 是在你確定指令通通都結束時，強迫 Buffer 做個清算，把還留在 Buffer 裡的 command, 該 Skip, 該 Send 的都一次清算完畢。規則類似，只是條件不同，我直接貼 code 就好:


```csharp

        bool IReOrderBuffer.Flush()
        {
            while(this._buffer.Count > 0)
            {
                if (this._current_next_index == this._buffer.Min.Position)
                {
                    // pop
                    var m = this._buffer.Min;
                    this._buffer.Remove(m);
                    this.Send(m, CommandProcessReasonEnum.SEND_BUFFERED);
                    this._current_next_index++;
                }
                else
                {
                    // skip
                    this.Drop(
                        new OrderedCommand()
                        {
                            Position = this._current_next_index,
                            Message = "Command not received, and skip waiting. Message body unknown."
                        },
                        CommandProcessReasonEnum.SKIP_BUFFERFULL);
                    this._current_next_index++;
                }
            }            

            return true;
        }


```


### 3-6, Adapters 串聯事件機制



最後，剩下轉發出來的 SEND / DROP / SKIP, 額只是更新 metrics, 轉發事件等搭配的作業，我直接貼程式碼。最終的事件都是在這邊被發出來的，發出事件後，外界就可以透過 CommandIsReadyToSend / CommandWasSkipped / CommandWasDropped 來接收通知，做對應的處理了 (你要把它轉發到支援 FIFO 的 Message Queue 也行)。

這部分的 code:


```csharp

        protected bool Send(OrderedCommand data, CommandProcessReasonEnum reason)
        {
            this._metrics_buffer_delay += (DateTimeUtil.Instance.Now - data.Origin).TotalMilliseconds;// (this._metrics_average_latency * this._metrics_total_pop + (data.OccurAt - data.Origin).TotalMilliseconds) / (this._metrics_total_pop + 1);
            this._metrics_total_send++;
            this._send?.Invoke(data, new CommandProcessEventArgs()
            {
                Result = CommandProcessResultEnum.SEND,
                Reason = reason,
            });

            return true;
        }


        protected bool Drop(OrderedCommand data, CommandProcessReasonEnum reason)
        {
            this._metrics_total_drop++;
            this._drop?.Invoke(data, new CommandProcessEventArgs()
            {
                Result = CommandProcessResultEnum.DROP,
                Reason = reason,
            });

            return true;
        }

        protected bool Skip(int position, CommandProcessReasonEnum reason)
        {
            this._metrics_total_skip++;
            this._skip?.Invoke(position, new CommandProcessEventArgs()
            {
                Result = CommandProcessResultEnum.SKIP,
                Reason = reason,
            });

            return true;
        }




```










### 3-7. DateTime Mock

另一個需要特別交代的，你可能會看到一個不認識的類別: DateTimeUtil, 因為這段模擬會牽涉到時間序，而我要是在 code 裡面直接用到 DateTime.Now 這類功能時，會很麻煩，一不小心我現在 run 的好好的 code, 明年就不能跑了。所以我自己寫了一個 DateTime 的 Mock, 可以控制我想要模擬的時間軸，除了讓我可以任意自訂 "現在" 的時間之外，我也可以壓縮時間線的進行，例如前面提到的 GetCommand(), 我不需要真的 Sleep 100ms, 我只要用 DateTimeUtil.TimePass() 就能做十間跳躍 (只能往後跳), 如果你真的用 Sleep, 時間也會往後跳。而我設置每秒一次的 timer, 他也會正確地幫我觸發。

先前我有一篇說明這個 DateTime Mock, 有興趣可以參考:
* [[架構師的修練] - 從 DateTime 的 Mock 技巧談 PoC 的應用](/2022/05/29/datetime-mock/)























回顧前面，我舉的兩個例子，如何收到訊息後重新排列的規則情境。前面只提到了 buffer 應該怎麼重新排列的 "規則" 而已，但是現實狀況其實不會這麼理想，其中包含了各種意外狀況，我列幾個可能碰到的情境:

1. 會以意料之外的順序收到 command (就前面提到的)
1. 可能碰到 command 遺失 (根本沒收到，你等再久都不會收到)
1. 可能碰到 command 延遲超過你的預期 (此例我們定 500ms, 實際上可能是 5000ms)
1. 可能碰到同樣 command 被送了一次以上

前面我示範的 GetCommands(), 我只模擬了 (1) 的情境，(2), (3), (4) 都跳過了，各位有興趣可以自行擴充 (有興趣可以留言，我擴充題目，讓各位發 PR 來大亂鬥?)。

回頭看看 Buffer 的設計，基本上都是用 Buffer 站存收到了還不能處理的 Command 為前提的處理方式。不過考慮上面的 (2)，如果 #1, #2, #3, #4, #5 的訊息，你漏掉了 #2, 你把 #3, #4, #5, ... #100 留在久都等不到 #2, 這時 Buffer 總有一天會炸掉，而你永遠無法繼續往下處理，系統就掛了。

因此，實際狀況下，Buffer 的容量應該是有限的，而你能等待的時間也應該是有限的 (這是串流及時處理，不是批次處理啊，不燃你就收到 #1 ~ #1000 筆後存到 DB 再重新排序就好了)，你也應該隨時監控這些狀況，妥善設置 Buffer 的資源，跟精確控制系統允許的最大延遲才對。當 Buffer 內的訊息停留太久，你也該果斷的判定，放棄那些 Command 能讓你的整個系統能繼續運作下去?

這些問題是困難的，舉例來說，你可以加大資源，讓 Buffer 能夠容納更多 Command, 也能夠允許更長的 Delay, 但是這真的是好事嗎? 你可能為了等待一個極端的 Command 丟失，讓整個系統延遲了 5000 msec, 也許你只要放棄這個 Command, 系統的整體延遲就在 100ms 以內也說不定。

因此這就是我需要模擬，同時需要監控的原因。我如果能模擬我面臨的實際狀況，這練習我希望也能讓我知道我該如何掌控這些參數，達到最佳結果。

所以，回頭來看看我在 1-4 沒有交代清楚的指標:

- Push: 每秒有多少 command 被 Push 到 Buffer 內
- Pop: 每秒有多少 command 能順利被執行 ( CommandIsReadyToSend 事件發出 )
- Drop: 每秒有多少 command 判定被丟棄 ( CommandWasDropped 事件發出 )
- Drop Rate (%): 丟失率, drop / push x 100%
- Buffer Delay: 因為 Buffer 處理的延遲時間
- Buffer Usage: 因為 Buffer 處理所需的保留 command 數量 (區間最大值)

當我調整 Buffer 的各種設計 & 配置時，Drop Rate, Buffer Delay, Buffer Usage 就變成我關心的指標了。你可以嘗試各種組合，看看怎樣才能達到最佳的組態。

看懂這些設計跟規劃之後，就開始嘗試實做吧! 這邊我保留一點空間 (不然全都講完了，怎麼叫做 "架構面試題" ?)，我只示範最基本範圍的 ReOrder 處理，其他進階的留給各位發揮。如果各位真的有機會被我面試的話 (或是你有機會面試我你也可以問我 XDDD)，歡迎你跟我聊聊這些我沒寫出來的細節你會怎麼處理。

我接下來的示範，我會處理:
1. 重新排列順序
1. 控制 Buffer Size
1. 掉訊息

我不會處理:
1. 訊息重送 (同一個訊息送兩次)
1. 都沒有新訊息進來，但是已經有訊息超時了 (我這版本都還是靠新訊息進來驅動所有動作的，因此沒訊息進來就等同當機)
1. 訊息超時





```csharp

    public class ReOrderBuffer : IReOrderBuffer
    {

        bool IReOrderBuffer.Push(OrderedCommand data)
        {
            this._metrics_total_push++;
            this._metrics_buffer_max = Math.Max(this._metrics_buffer_max, this._buffer.Count);

            if (data.Position < this._current_next_index)
            {
                // drop
                this.Drop(data, CommandProcessReasonEnum.DROP_WRONG_ORDER);
                return false;
            }
            else if (data.Position == this._current_next_index)
            {
                // pop series
                this.Pop(data, CommandProcessReasonEnum.POP_PASSTHRU);
                this._current_next_index = data.Position + 1;

                while (this._buffer.Count > 0 && this._buffer.Min.Position == this._current_next_index)
                {
                    var x = this._buffer.Min;
                    this._buffer.Remove(x);

                    this.Pop(x, CommandProcessReasonEnum.POP_BUFFERED);
                    this._current_next_index = x.Position + 1;
                }

                this._metrics_buffer_max = Math.Max(this._metrics_buffer_max, this._buffer.Count);
                return true;
            }
            else if (this._buffer.Count >= this._buffer_size)
            {
                this.Drop(data, CommandProcessReasonEnum.DROP_BUFFER_SIZE_FULL);
                return false;
            }
            else
            {
                // queued & refresh buffer
                this._buffer.Add(data);

                this._metrics_buffer_max = Math.Max(this._metrics_buffer_max, this._buffer.Count);
                return true;
            }
        }



    }


```

這段我建議別急著看我寫了什麼 code, 而是先想想我前面提到的演算法，我按這順序收到 #1, #3, #4, #2 的處理步驟:

| time sequence | push | execute | buffered |
| --- | --- | --- | --- |
| 1 | #1 | #1 |  |
| 2 | #3 |  | #3 |
| 3 | #4 |  | #3, #4 |
| 4 | #2 | #2, #3, #4 |  |


背後的邏輯就是:


1. 如果 Push 進來的 command position 比 _current_next_index 小，代表收到過去的 command, 丟棄: Drop()
1. 如果 Push 進來的 command position 跟 _current_next_index 一樣，就代表順序對了，直接執行: Pop(), 同時會接著檢查下一個是否也在 buffer 內，有連續號碼的就一起執行，直到 buffer 空了或是又有跳號
1. 如果 Push 進來的 command position 比 _current_next_index 大，代表中間有掉 command, 先放進 buffer 等待處理

過程中，會同時更新對應的 metrics, 也會處理 settings 相關的限制，我就不逐一說明。了解邏輯後，寫成 code 就是上面那段了，執行結果應該就像上面的表格說明一樣，大家可以自己用腦袋 run 看看。



### 2-3. Event 的處理


其實這段就交代一下而已，這樣才算完整說明，但是關鍵部分其實 2-2 就說完了。這部分是交代真正要發出 event 的部分作法。前面的 Push() 決定了 Pop() 要丟出執行的事件，其實有多做一道把關，就是檢查這個 command 是否超過允許的最大延遲時間 (_command_max_delay), 超過的話就把它扔了 (Drop).

兩者 ( Pop, Drop ) 的實做都差不多，做些基本的判斷，更新 metrics，接著就直接發出 IReOrderBuffer 定義的兩個事件了。由於 C# 一些規矩，中間的 event 有些轉換，程式碼中的 _pop 就是 CommandIsReadyToSend 事件，而 _drop 則是 CommandWasDropped 事件。

直接看程式碼比較快:

```csharp

    public class ReOrderBuffer : IReOrderBuffer
    {

        protected bool Pop(OrderedCommand data, CommandProcessReasonEnum reason)
        {
            if ((DateTimeUtil.Instance.Now - data.Origin) < this._command_max_delay)
            {
                this._metrics_buffer_delay += (DateTimeUtil.Instance.Now - data.OccurAt).TotalMilliseconds;// (this._metrics_average_latency * this._metrics_total_pop + (data.OccurAt - data.Origin).TotalMilliseconds) / (this._metrics_total_pop + 1);
                this._metrics_total_pop++;

                this._pop?.Invoke(data, new CommandProcessEventArgs()
                {
                    Result = CommandProcessResultEnum.POP,
                    Reason = reason,
                });
            }
            else
            {
                this._metrics_total_drop++;
                this.Drop(data, CommandProcessReasonEnum.DROP_COMMAND_EXPIRED);
            }
            return true;
        }




        protected bool Drop(OrderedCommand data, CommandProcessReasonEnum reason)
        {
            this._metrics_total_drop++;
            //Console.WriteLine($"DROP: {data.Position:#000}, {data.Message}; ({reason})");

            this._drop?.Invoke(data, new CommandProcessEventArgs()
            {
                Result = CommandProcessResultEnum.DROP,
                Reason = reason,
            });

            return true;
        }

    }


```

另一個需要特別交代的，你可能會看到一個不認識的類別: DateTimeUtil, 因為這段模擬會牽涉到時間序，而我要是在 code 裡面直接用到 DateTime.Now 這類功能時，會很麻煩，一不小心我現在 run 的好好的 code, 明年就不能跑了。所以我自己寫了一個 DateTime 的 Mock, 可以控制我想要模擬的時間軸，除了讓我可以任意自訂 "現在" 的時間之外，我也可以壓縮時間線的進行，例如前面提到的 GetCommand(), 我不需要真的 Sleep 100ms, 我只要用 DateTimeUtil.TimePass() 就能做十間跳躍 (只能往後跳), 如果你真的用 Sleep, 時間也會往後跳。而我設置每秒一次的 timer, 他也會正確地幫我觸發。

先前我有一篇說明這個 DateTime Mock, 有興趣可以參考:
* [[架構師的修練] - 從 DateTime 的 Mock 技巧談 PoC 的應用](/2022/05/29/datetime-mock/)



## 3. 執行 & 監控


















預期結果

實際測試 ( snapshot → replay )

## 5. 寫在最後

DevOpsDays Taipei 2023 - 架構師也要 DevOps

降級的應用 => 實際專案，將 ReOrderBuffer 背後用:

[ API service ] -> [ ReOrder Service + Redis ] -> [ FIFO Message Queue ] -> [ Command Workers ]





常常有人問我，說解題一定要這麼複雜嗎? 有沒有簡單搞定的方法?

其實複雜的問題都是人自己搞出來的，簡單的方法是有，就是你別生出這麼難解的問題就好了 (XDDD)，既然問題都在那邊就只能解決了。上火星有簡單的方法嗎? 以人類現在的科技沒辦法，你就只能去面對重重挑戰了。

這種 re-order 的問題，解法不是沒有，其實文章內提到的演算法，早在各種層面都已經被實做出來了。你不想自己解的話，就要配合現成的實做。例如:

1. 用 TCP/IP 的機制:
想辦法從源頭就用同一個 TCP connection 來傳輸就好，不過如果源頭就是分散的多個平行 request 那就沒辦法。
2. 用 Message Queue (FIFO) 的機制:
同上，在 message 的順序亂掉之前，就將他用正確順序放進 message queue 就解決了。Message Queue 的機制會保證傳輸到另一端的時候仍能保證順序的正確性 (其實背後用的也是類似的演算法)

還是回到同樣的一句話，如果這問題可以變成基礎建設的問題，你就不要自己做了，用現成的比較可靠。如果這問題已經變成獨特的商業問題，你就必須要有自己面對的能力了 (或是將他轉移成基礎建設的問題)。不過，不經過這些練習，你是不會有這樣的理解與判斷能力的，你也不會有自己解決的選項。

在寫這篇，正好在臉書看到這則 PO 文，相當有感，就貼來給大家參考:

這剛好是同一件事的兩面，你用了對的 MQ, 他就能幫你保證。你看規格，他有標註 FIFO 就是指這件事。不過，如果你自己平行處理，同時 10 workers 都從 MQ 拿東西，MQ 可以保證他給你的順序都是對的，但是你自己寫的 10 workers 真的能照順序執行嗎? 這就是你自己要保證的問題了。

你會有各種狀況，需要在自己的 code 內處理類似問題，