# [架構師觀點] LLM 的抽象化介面設計

## 摘要提示
- 抽象化介面: 以「先定義介面再談實作」的方式，拆解 LLM 與背後服務的互動規格。  
- 真人隱喻: 把 LLM 想成「真人客服」，用對話 Prompt 與之溝通，便能抓住 API 設計脈絡。  
- 工人智慧: 以 Uber 式「媒合真人」為例，說明同一介面可同時驅動 AI 與真人兩種 Worker。  
- SessionState: 對話需保留前後文與可用工具，介面必須能攜帶並轉移這些狀態。  
- IChatBot/Ask: 以 C# 介面 `IChatBot.Ask()` 示範最小可行抽象，支援串流、多輪回覆。  
- Dispatcher/Switch: 透過 Operator 交換器將會話指派給可用 Worker，形成可水平擴充的後端。  
- 重造輪子: 親自做 POC 可踩完整設計坑，之後對照 OpenAI Assistant 等規格就能精準映射。  
- 預測能力: 理解抽象後能推測 API 未來演進，預留擴充點、降低升級痛苦。  
- 架構師修練: 把「抽象→實作→比對」當刻意練習，可複製到 ORM、ThreadPool、RBAC 等領域。  
- 工程心法: 學會框架式思考，比死背文件更能靈活掌握新技術並做出長久可維護的設計。  

## 全文重點
作者以「LLM 介面抽象化」為題，分享自己如何透過重新發明輪子的方式，練習把大型語言模型嵌入應用架構。核心做法是先把 LLM 想成「真人客服」：前端只需提供能持續對話的 `IChatBot.Ask()` 介面；後端則像 Uber 平台，有 Dispatcher／Switch 負責把每一次對話工作派給可用的 Worker，Worker 可以是真人也可以是 AI 模型。為了支援多輪對話、工具調用與擴充，SessionState 被抽出來保存歷史與指令，並在 Worker 切換時一併傳遞，使 Worker 保持無狀態(stateless)。  
作者接著以 C# 代碼示例串起前後端設計，並說明若要計費、串流、圖靈測試或多模型切換，只需在既有抽象上擴充即可。經過 POC 後再對照 OpenAI Assistant API、Ollama、gRPC 等現有規格，發現大廠的設計意圖多能映射到自己推導出的結構。過程雖耗時，但能鍛鍊三種能力：1) 精確選用成熟元件；2) 快速理解並預測框架演進；3) 在自家專案中預留升級空間，降低日後技術債。作者強調，這種「抽象化→實作→對照」的刻意練習，過去亦讓他在 ORM、ThreadPool、RBAC 等領域獲益良多；對架構師而言，這就是持續進化與保持領先的關鍵心法。

## 段落重點
### 寫在前面：「工人智慧」的介面設計
作者先回顧 2010 年代 Uber 式「媒合平台」與早期聊天機器人的工人智慧案例，說明同一聊天介面既可由真人回答也可由 AI 回覆。透過此隱喻，他確立「把 LLM 當真人」的抽象，後續所有介面設計皆圍繞「對話」與「派工」展開，並明確點出自己這篇文章的重點並非 AI 技術，而是介面抽象與架構思維。

### 開始 coding ...
在程式層面，先提出極簡 `IChatBot.Ask(string)` 介面，後再演化為 `IEnumerable<string>` 以支援串流輸出。前端 Demo 只需迴圈讀寫即可運行；後端則需實作 Dispatcher (Operator) 與 Switch 來分配 Worker。此處強調：良好抽象能讓前端與後端解耦，各自迭代而不互相耦合。

### 第一版實作
作者以簡化的 Class Diagram 展示 Operator、Switch、Worker 及 Session 之間的關係，並討論如何在 Worker 側保持無狀態，將 Session 交由平台管理。這一版先驗證「真人工人」能被動態指派並多工服務，為後續替換成 LLM 奠定基礎，也順勢探討計費(token)與中途換人時的歷史轉移問題。

### 2024/08/02，LLM 抽象化
說明撰文動機：市面上 OpenAI Chat Completion、Assistant API、Semantic Kernel、LangChain、Ollama 等規格各異，若不用抽象化思考將難以統整。作者用重造輪子的方式歸納出共通核心，再拿來對照大廠方案，發現多能一一映射；若有差異，亦能快速找出原因並改良。此段亦列舉作者過去在 Stack Machine、ORM、ThreadPool、RBAC 等多項技術上的同類練習，說明其長期成效。

### 定義：圖靈測試與 SessionState
最後把問題拉回「若要寫一套能執行圖靈測試的 APP，介面該長什麼樣？」提出 `IIntelligence.Ask(question, session)`，SessionState 內含對話記錄與可用 Tools，回傳值改為 `IEnumerable<string | ToolUsage>`。如此即可同時支援 AI 回答、人類回覆、工具調用等場景，且方便橫向擴充。作者總結：掌握此抽象後，面對新版本 API 只要替換底層實作即可，真正做到高預測性與低維護成本，這正是架構師「猜得準又動得少」的秘訣。