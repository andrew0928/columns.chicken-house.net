# FlickrProxy #4 - 修正同步上傳的問題

## 摘要提示
- 同步上傳衝突: 多個請求同時觸發相同照片上傳，導致重複傳檔。  
- 臨界區 (Critical Section): 以 lock 包住「判定需否上傳」與「建立副本檔」兩步驟，保證原子性。  
- 過度鎖定問題: 以類別物件為鎖會讓所有照片請求互相等待，效能受損。  
- 依檔案鎖定: 為每張照片動態產生專屬 lock 物件，僅阻擋同圖檔請求。  
- LockHandle 實作: 以 Dictionary<string, object> 對映檔案雜湊值與鎖物件，確保同一檔案共用同一鎖。  
- 首次大量載圖: 若同頁多圖皆為首次請求，仍可能同時上傳多檔，占用頻寬。  
- 併發數量控制: 以 Semaphore 進一步限制同時上傳動作上限（範例設 2）。  
- Semaphore 用法: WaitOne 取得名額、Release 歸還名額，簡易實作併發節流。  
- 多執行緒常見陷阱: 初學者易犯「鎖太大」或「鎖錯物件」的錯誤。  
- 延伸閱讀: 作者投搞文章詳解 ASP.NET 中 Lock 與 Semaphore 的實戰運用。

## 全文重點
作者在維護 FlickrProxy 時，收到使用者回報：當相片第一次被存取時，程式需先將檔案同步上傳至 Flickr，再重新導向瀏覽器讀取 Flickr 端影像；若此過程尚未完成就有第二個 HTTP 請求抵達，程式會誤以為該圖尚未上傳而再傳一次，造成重複檔案。問題核心是「多執行緒環境下的競爭狀態」。  
第一版修正以 lock (this.GetType()) 將「判斷是否已建立快取資訊」及「建立 Flickr 副本檔」包在同一臨界區內，一次只允許一條執行緒進入。雖能避免重複上傳，但鎖定範圍過大：任何照片的請求都得排隊，喪失多核心 CPU 效益。  
作者進一步將鎖粒度縮小到「單一檔案」，為每張照片動態產生一個 lock 物件。透過 Dictionary 以檔案雜湊值 (或檔名) 做索引，確保同圖檔共用同一物件、不同圖檔互不干擾，顯著提升並行度。  
接著又觀察到「同一頁面含多張新圖」時，仍可能同時啟動大量上傳，對頻寬與 Flickr 服務都是負擔。於是引入 Semaphore 控制整體併發量：程式啟動前先建立 Semaphore(2,2)，每次上傳前呼叫 WaitOne() 取得名額，完成後 Release() 歸還，確保同時最多僅兩件上傳作業。  
整篇文章藉由真實維護經驗示範如何在 ASP.NET 環境中漸進式調整同步機制：由「大鎖」到「細鎖」，再到「協作式資源池」，並提醒開發者多執行緒程式設計常見的效能與安全性陷阱。

## 段落重點
### 問題描述與使用者回報
作者感謝使用者小熊子指出重複上傳 Bug：兩個瀏覽器請求同時到來，程式在第一次上傳尚未完成前又啟動第二次上傳，導致 Flickr 出現兩份同圖。

### 第一版修正：臨界區鎖定
以 lock (this.GetType()) 將「快取判斷」與「建立副本」兩行關鍵程式碼包在臨界區內，確保同時間只允許一條執行緒執行，問題雖解決，卻造成所有圖片請求序列化，影響效能。

### 過度鎖定的效能疑慮
作者反省：大鎖導致不同圖片也互相等待；若網站流量增加，四核心 CPU 形同單核心。需改進為更細粒度的同步策略。

### 第二版修正：依檔案鎖定
改以 lock (this.LockHandle)；LockHandle 屬性透過 Dictionary 保存「檔案雜湊→鎖物件」對映，確保同一檔案共用鎖、不同檔案各自獨立。程式碼示範了如何取得或建立物件並回傳作為鎖。

### 進一步優化：限制同時上傳數量
觀察到「同頁多圖初次讀取」會觸發多個上傳，仍耗頻寬。故使用 Semaphore(2,2) 先插兩根旗子，在 upload 之處 WaitOne/Release，限制系統同時僅有兩條上傳執行緒，避免對 Flickr 過度施壓。

### 結語與相關資源
透過真實維護案例，作者展示 lock 與 Semaphore 的正確用法，並提醒初學者避免「鎖太大或鎖錯物件」。若想深入 ASP.NET 多執行緒同步，可參考作者投稿於 RUN!PC 的系列文章。