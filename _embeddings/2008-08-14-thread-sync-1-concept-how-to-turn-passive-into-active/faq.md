# Thread Sync #1. 概念篇 - 如何化被動為主動?

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 為什麼在只有單一執行緒且必須定期刷新畫面的遊戲程式中，不能直接用「一路到底」的直覺流程撰寫邏輯？
當主程式被限制在一個不停刷新畫面的無窮迴圈時，任何遊戲邏輯都得被拆成許多小段，並在每次迴圈中被呼叫。若不用多執行緒或其他技巧，程式只能被動配合主迴圈，無法保持原本連貫的流程。

## Q: 在「猜數字」的 GameHost / Player 架構下，只靠多型讓 GameHost 不斷呼叫 Player.GuessNum() 有哪些困難？
Player 的完整猜測流程被迫拆成同一個方法在多回合中重複執行；上一回合提出的問題要到下一回合才拿到答案，邏輯被切得支離破碎，還得額外維護狀態，導致難以撰寫聰明的猜測策略。

## Q: 讓 GameHost 與 Player 各跑在自己的執行緒上，可以帶來哪些好處？
雙方都能用直覺且完整的思路撰寫程式，而不必被動等待對方呼叫；問題被簡化後，更容易實作複雜策略，也更符合「莊家與玩家各有一顆腦袋」的真實情況。

## Q: 兩個執行緒之間要交換資料時，文中建議採用哪一種同步機制？其基本做法是什麼？
建議使用 AutoResetEvent。需要資料的一方先呼叫 Wait() 進入等待；當另一方將資料寫入共用變數後，呼叫 Set() 喚醒對方。若下一次資料方向相反，兩邊再交換角色，重複同樣流程。

## Q: 除了提升效能之外，執行緒在這篇文章中被用來解決什麼問題？
執行緒被用來「簡化程式設計的複雜度」，讓各模組保持主動、獨立的思考流程，而不必為了配合單一執行緒而被動地拆解邏輯。