# [設計案例] 生命遊戲 #4, 有效率的使用執行緒

## 摘要提示
- 執行緒爆炸: 30×30 的生命遊戲若一格一執行緒，瞬間產生 903 條執行緒但僅佔不到 5% CPU。
- 主動式時間控制: 由 Thread.Sleep 轉成 yield return TimeSpan，使細胞可主動回報下次喚醒時間。
- GameHost 翻新: 從「放任執行緒」改為「集中排程」；核心任務變成喚醒與排程。
- 執行緒集區: 工作統一投遞至 ThreadPool，避免為每格細胞開專屬執行緒。
- ToDo List 排程器: 以 SortedList＋lock 實作，可回報下一個要醒的 Cell 及總量。
- 兩條關鍵執行緒: 一條處理排程與喚醒，一條獨立負責畫面刷新。
- 效能成果: 相同邏輯由 903→9 條執行緒，畫面與行為無差異。
- 遊戲伺服器思維: 共用執行緒與排程是 MMO、社群遊戲伺服器的核心模式。
- OOP 延伸: 下一步將利用繼承與多型擴充多樣生物行為。
- 範例程式: 文章末附 BLOG_4.zip 供讀者下載練習。

## 全文重點
作者延續「生命遊戲」系列，發現上一版程式在 30×30 的世界中為每個 Cell 建立一條獨立執行緒，結果產生 903 條執行緒卻只耗不到 5% CPU，既浪費系統資源又難以擴充。為貼近真實遊戲伺服器的需求，本篇先不談 OOP 多型，而是專注於效能優化，導入「集中排程、共用執行緒」的思維。

首先，將 Cell 的生命週期方法由 Thread.Sleep 改為 yield return TimeSpan。Cell 執行一次狀態轉換後，回傳自己欲休息的時間片，等待 GameHost 再度喚醒。這種寫法雖保留「主動」特性，但使原本單純畫面刷新的 GameHost 不得不接手「收集休眠時間並準時叫醒」的工作。

為此，作者設計了 CellToDoList，內部以 SortedList 儲存 Cell 與下一次喚醒時間，再配合 lock 保證執行緒安全。公開介面僅提供 AddCell、GetNextCell、CheckNextCell 及 Count，方便 GameHost 插入或取得下一個待處理 Cell。

新的 GameHost 啟動後會：
1. 預先呼叫每個 Cell 的 OnNextStateChangeEx() 取得第一次醒來時間並置入 ToDoList。
2. 以專屬執行緒持續刷新畫面。
3. 主迴圈中不斷從 ToDoList 取出最近要醒的 Cell；若時間未到則 Sleep 至指定時刻；時間一到即將 Cell 的下一次邏輯投遞至 ThreadPool 執行。
4. Cell 邏輯完成後再把自己以新時間放回 ToDoList，如此循環。

透過這種集中排程＋執行緒集區的設計，同樣 30×30 的世界僅需 9 條執行緒即可維持遊戲運轉，顯著降低執行緒上下文切換成本，也為日後在伺服器側管理大量遊戲實體打下基礎。作者最後指出，完善的 GameHost 只是開始，下一篇將聚焦繼承與多型以打造多樣化生物，並戲稱整體架構頗似電影《駭客任務》中的「母體」。

## 段落重點
### 引言：執行緒爆炸的尷尬
作者原想直接談 OOP 多型，但檢視上一版生命遊戲程式後，驚覺 30×30 的世界竟產生 903 條執行緒卻僅佔 5% CPU。若這是線上遊戲伺服器，少量玩家便能拖垮系統，因此決定先處理效能問題。

### 從被動喚醒到主動回報
回顧第 3 篇把 Cell 行為改成主動執行，但仍以 Thread.Sleep 控時。本篇繼續維持「主動」精神，改以 yield return TimeSpan 讓 Cell 自行回報休息時長，結構上只需將 Sleep 換成 yield，即可把連續邏輯拆段。

### yield return 改造細胞生命週期
展示修改前後的 WholeLife 方法：Sleep 版直接阻塞，yield 版則每次狀態轉換後回傳 TimeSpan。外觀改動小，卻讓外部呼叫模式完全改變；GameHost 不再能「放養」每條執行緒，而必須主動詢問每格 Cell 何時再執行。

### GameHost 角色翻轉與挑戰
新的 GameHost 得用 foreach 模式不停問「大爺，這次您要休息多久？」並準時叫醒。一句話總結：目標是重現 #2 範例的動態效果，但用更少、但更活躍的執行緒完成。

### 排程器：CellToDoList 的設計
要共用執行緒就得把工作切碎並妥善排程。作者決定做一張「時間表」：按下一次喚醒時間排序 Cell。需求只有「放進去、拿出來」，因此公開介面簡化為 AddCell、GetNextCell、CheckNextCell、Count。實作採 SortedList＋lock，確保 thread-safe。

### 新版 GameHost 的實作流程
GameHost 初始化時先呼叫所有 Cell 的 OnNextStateChangeEx 取得首個喚醒時刻並放入 ToDoList，接著啟動獨立執行緒刷新畫面。主線程進入 while 迴圈：取最早要醒的 Cell，若時間未到則 Sleep，時間到就把 Cell 邏輯丟進 ThreadPool。Cell 執行完再帶回新的醒來時間重入排程，如此無限循環。

### 效能比較與執行結果
與 #3 相同的邏輯和畫面效果，舊版需 903 條執行緒，新版僅 9 條即可。圖示也證實 CPU 使用率更集中。作者強調此模式正是 MMO 或社群遊戲伺服器常用的「集中排程＋執行緒集區」設計。

### 結語與後續計畫
雖然範例規模小，但練習的是「如何撰寫高效 GameHost」。完成排程基礎後，下一篇將以繼承與多型豐富生物種類。作者打趣說整個框架愈來愈像《駭客任務》的「母體」，萬物皆由程式掌控。範例程式已附於 BLOG_4.zip，供讀者實際體驗。