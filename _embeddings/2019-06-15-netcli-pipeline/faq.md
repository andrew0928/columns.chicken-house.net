# 後端工程師必備: CLI + PIPELINE 開發技巧

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 批次處理（Batch）、串流處理（Stream）與管線處理（Pipeline）最大的差異是什麼？
批次處理一次收集大量資料後依序完成所有步驟，第一筆與最後一筆完成時間都等於 N×(M1+M2+M3)，且過程中可能同時佔用 N 筆半成品的記憶體。  
串流處理則一筆資料從頭跑到尾再換下一筆，第一筆完成只需 M1+M2+M3，記憶體固定只保留 1 筆；但總時間仍是 N×(M1+M2+M3)。  
管線處理把「作業步驟」與「資料筆數」交錯，三個步驟同時進行，各階段像工廠輸送帶一樣傳遞半成品，理想情況下總完成時間縮短為 N×max(M1,M2,M3)，記憶體僅維持每階段各 1 份半成品（本例約 3 份）。

## Q: C# 範例中，為什麼最外層一定要有一個「什麼事都不做」的 foreach 迴圈？
因為每一層 `StreamProcessPhaseX()` 都只回傳一個 `IEnumerable<DataModel>`，真正的處理程式碼只有在對該 `IEnumerator` 調用 `MoveNext()` 時才會被觸發。最外層的空迴圈負責不斷呼叫 `MoveNext()`，才能驅動整條 Pipeline 依序取資料、處理並 `yield return` 出下一筆結果。

## Q: 改用 `async` + `yield return`（DEMO 4）之後，效能為什麼提升？
`async` 版本讓每個階段可以「先送出上一筆、同時準備下一筆」，等於在相鄰階段之間預留 1 筆隱形緩衝區。流程被局部平行化後，本例 5 筆資料的總時間從 22 s 縮短到 13 s，但記憶體使用量也比純 `yield return` 版略高（約 6 GB → 1 GB buffer 測試）。

## Q: 使用 `BlockingCollection`（DEMO 5）與 `async` 版相比有什麼差異？
`BlockingCollection` 把每個階段間的緩衝區顯式化並可自訂容量（例如 10 筆）。背景執行緒持續 PUSH 半成品到下一關，直到緩衝區滿才被 Block；因此整體更緊湊，P1 全部完成時間由 8 s 再縮到 5 s。但緩衝區越大，同時佔用的記憶體也越多，100 筆×1 GB 的測試最高衝到 25 GB。

## Q: 為什麼把 P1、P2、P3 拆成獨立 CLI 並用 shell pipeline 串接能簡化開發？
一旦封裝成獨立 CLI，平行執行、緩衝區、Process 關閉與資源釋放全交由 OS 的 pipe 機制處理。開發者只需讓每個 CLI 把資料寫到 STDOUT、從 STDIN 讀取即可；與 DEMO 5 近似的效能，只要十行上下的程式碼就能辦到，而且還能利用檔案重導向、`tee` 等指令更方便地做測試、重跑單一步驟或分散式處理。

## Q: 若 P1 執行速度遠大於 P2、P3，半成品會發生什麼事？OS 如何保護系統？
半成品會累積在管線緩衝區中；當 pipe buffer 被填滿時，OS 會 block P1 的 STDOUT 寫入，使 P1 暫停，直到 P2、P3 消化部分資料釋放空間，才繼續寫入。這讓系統在高吞吐量下仍能保持記憶體使用上限，不致無限制暴衝。