# [設計案例] 生命遊戲#1, 前言

## 摘要提示
- 設計案例: 作者計畫以「生命遊戲」為例，撰寫一系列探討軟體設計與實作的文章。  
- 生命遊戲: Game of Life 為 1970 年 Conway 提出的細胞自動機，核心規則簡單卻能展現複雜行為。  
- 與時俱進: 四十年來語言與平台大幅進步，作者欲嘗試 .NET／C# 新作法而非沿用舊式 C 風格。  
- 物件導向: 透過封裝與多型，讓各類細胞的獨特邏輯分離而不破碎。  
- yield return: 利用 C# 迭代器技術，保持程式流程連貫並降低「write only」程式碼的閱讀難度。  
- 多執行緒: 面對成千上萬個並行細胞，需以合理的 Thread 佈局或併發模型調度運算資源。  
- 範例反思: 市面常見 Java／C 範例多為「Java 寫 C」，未充分發揮語言特性。  
- Realtime 模擬: 每種細胞可能擁有不同時間節奏，程式須能同時處理多速率狀態更新。  
- 系列規畫: 主題龐大，作者預告後續多篇文章與範例程式，並歡迎讀者參與討論。  
- 提醒事項: 學生請勿照抄範例交作業，以免助教看不懂先進作法而被扣分。  

## 全文重點
作者久未撰寫有深度的技術文章，決定推出「設計案例」系列，以經典的 Game of Life 為題示範在現代 .NET／C# 環境下如何重新思考與實作。Game of Life 是 1970 年 Conway 發明的細胞自動機，僅依鄰近八格數量決定「孤單死亡、擁擠死亡、穩定存活、復活」四條規則便能演化出豐富圖樣。網路上現成範例多以 C 語言或「Java 寫 C」方式實作，程序式主迴圈將所有邏輯切得零碎，形成難以維護的「write only」程式碼。

面對這種古典題目，作者提出三大技術切入點：  
1. 以 C# 的 yield return 保持邏輯連續性，透過迭代器讓每個細胞流程宛如獨立協程；  
2. 以物件導向多型拆分各細胞類型，使不同生命週期或更新節奏的差異在類別層次解決；  
3. 以多執行緒或併發技巧處理大規模細胞並行，而非為每個細胞硬開一條 Thread，避免過度消耗資源。  

作者亦指出 Game of Life 可視為具時間概念的即時模擬，若細胞更新頻率各異更需妥善調度；這正是現代開發環境（委派、計時器、執行緒池、TPL 等）能施展拳腳之處。最後，作者自知工程量龐大，預期整個系列將持續數篇，待完成首支範例程式後再行發表，並開放讀者分享心得。  

## 段落重點
### 前言——從懶惰到動筆
作者坦言近期撰寫程式與研究新技術的量減少，Blog 內容也趨於沉寂；為激發創作動力，決定回歸基礎、挑戰老題目，以「設計案例」形式示範如何用現代技巧解決古典問題，並自嘲程度不及真正 Design Patterns，只能稱為「案例」。

### 從 Facebook 小遊戲談到 Game of Life
看見開心農場、My FishBowl 等模擬遊戲在社群爆紅，作者聯想起學生時期的課題——Game of Life，並引用維基百科簡介說明其歷史與數學背景；雖是 1970 年的設計，卻為今日眾多模擬遊戲之祖。  

### 舊式範例的不足與新語言優勢
網路上搜尋到的程式大多以 C 或「Java 寫 C」風格撰寫，未充分運用物件導向、執行緒或語言特色。作者認為現代開發強調 OOP、多執行緒及語言糖衣（如 yield return），正好能為此題注入新思維。

### 三大技術障礙與對策
1. 邏輯破碎：傳統主迴圈將細胞行為切片，難讀難維護；以 yield return 讓單一細胞擁有線性劇本可改善此問題。  
2. 多速率更新：細胞可能以 1 秒、2 秒或 5 秒為週期變化；以多型定義不同細胞類別，讓時間邏輯封裝於類別內。  
3. 大量並行：動輒上萬細胞若各開 Thread 將拖垮系統；必須利用 Thread Pool、Task Parallel Library 或其他並發模型統一調度。

### 結語與後續規劃
作者意識到題材龐大，可能需時數月完成整系列；預計先發佈 sample code，再逐步解析設計細節。亦鼓勵讀者嘗試實作並分享，唯提醒學生勿照抄以免作業遭拒，同時幽默地表示自己無法像 darkthread 提供讀者獎品。