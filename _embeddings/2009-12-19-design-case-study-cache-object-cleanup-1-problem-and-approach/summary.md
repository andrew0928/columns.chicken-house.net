# [設計案例] 清除Cache物件 #1. 問題與作法

## 摘要提示
- Cache.Remove: 直接用 Remove(key) 可刪單一快取，但必須記憶 key，規模一大就難維護。
- GetEnumerator: Cache 無 Keys 屬性，只能靠迭代器列舉現存 key，程式寫起來不直覺。
- 不確定性: 快取項目隨時可能被逐出，對迴圈操作或同步流程帶來風險。
- 瀏覽器快取案例: 以 URL 為 key 快取下載內容，模擬瀏覽器 Temporary Files 機制。
- 清除條件: 需求包含依網域、Content-Type、Protocol 等條件刪除部分快取。
- 既有解法: 自行維護 URL 清單或用 Regex 過濾迭代皆可行，但效能與可讀性差。
- CacheDependency: 將同類快取關聯到檔案，透過觸碰檔案一次失效整群快取。
- 優劣權衡: 檔案依賴法優雅且易用，卻引入額外 I/O 及外部資源耦合。
- 設計反思: 如何兼顧效能、簡潔與可維護性，是快取移除機制的核心課題。
- 系列預告: 本篇聚焦問題與構想，實作細節將於下一篇續寫。

## 全文重點
作者以 .NET HttpRuntime.Cache 為例，探討「如何有條件地移除一群快取物件」的設計問題。雖然以 Cache.Remove(key) 就能刪除單一項目，但前提是必須知道精確的 key；若要一次刪除多筆，尤其是依「網域」「檔案類型」「傳輸協定」等語意分類時，單靠 key 就顯得笨重。要列舉所有快取鍵也不如 Dictionary 那麼方便，因為 Cache 只能透過 GetEnumerator() 逐筆走訪，而快取本身又具有隨時可能被逐出的不確定性，讓程式不易寫得既安全又可讀。

為了說明痛點，作者舉出「以 Cache 取代瀏覽器 Temporary Internet Files」的情境：下載資源時以 URL 作為 key 存進快取，之後希望提供使用者選單，能依網站、檔案格式或協定清除部份暫存。傳統做法有二：一是自行維護所有下載過的 URL 清單，再用適當資料結構比對刪除；二是先列舉快取中所有鍵，再用正規表示式篩選。前者幾乎等於重寫一個快取機制，後者每次都得 O(n) 掃描大量資料，程式醜且效率差。

作者遂提出一個「既聰明又愚蠢」的折衷：在放入快取時，先將同一分類的項目都設定同一個 CacheDependency，使其依賴同一個檔案；真正要刪除時，只要 touch 這個檔案，即可一次讓整群物件過期。此法優點是 API 友善、邏輯乾淨，也符合 ASP.NET 本身原生的依賴機制；缺點則是把純記憶體操作繞到檔案系統，增加 I/O 開銷與外部資源耦合。作者承認該方案仍有改進空間，並預告下一篇將給出具體程式碼實作，以便進一步驗證效能與可維護性。

## 段落重點
### 引言：標題苦惱與 Cache 話題開場
作者自嘲取標題的困難，引入本文主旨──分享對 .NET HttpRuntime.Cache 的操作心得，尤其著眼於「手動移除快取物件」這件看似簡單卻潛藏問題的需求。

### 移除單一快取：Remove(key) 的侷限
透過 HttpRuntime.Cache.Remove("cache-key") 可立即刪除單一項目，但前提是程式必須額外記錄並維護 key；當快取筆數多、分類複雜時，程式碼將充斥硬碼字串與判斷，難以閱讀與維護。

### 列舉所有鍵：GetEnumerator 的不便與風險
Cache 不提供 Keys 屬性，只能用 foreach 迭代取得 key；然而迭代期間快取可能被驅逐，稍有不慎就會踩到 Null 風險，使得同步與錯誤處理額外麻煩。

### 快取的不確定性：操作需格外謹慎
Cache 本質上隨時可能因記憶體壓力或時間到期而移除項目，因此即使邏輯上像 Dictionary，也不能假設資料永遠存在；這種不確定性影響到列舉、比對與刪除等後續操作。

### 瀏覽器快取案例：URL 為 key 的應用
作者以「自行開發的簡易瀏覽器」為例，將下載內容以 URL 作為鍵值存進 Cache，藉此模擬 IE 的 Temporary Internet Files，並進一步提出需要「部分清除」的使用者功能。

### 部分清除需求：以語意條件刪除
具體需求包含：1) 清除特定網域的資源；2) 清除特定 Content-Type 的檔案；3) 清除特定協定(如 HTTPS)下載的內容。這些需求在實務上非常常見，卻難以用現成 API 優雅解決。

### 傳統解法與其缺點
兩個常見做法：自己維護 URL 清單以便查詢比對，或每次列舉 Cache 再用 Regex 篩選。前者幾乎重造輪子、資料易失真；後者時間複雜度高且程式碼雜亂，均不理想。

### 檔案依賴法：CacheDependency 的靈光一現
作者構思：事先按分類替每群快取綁定同一個檔案依賴，需要清除時只要觸碰檔案即可讓整批物件過期。此法善用 ASP.NET 原生機制，邏輯簡潔，卻引入檔案 I/O 開銷與外部依賴。

### 結語與續篇預告
本文提出問題並給出一種折衷構想；作者認為仍有改進與優化空間，並預告下一篇將展示實際程式碼，驗證該方案在效能、簡潔與可維護性上的平衡。