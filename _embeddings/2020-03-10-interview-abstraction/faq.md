# 架構面試題 #4 ─ 抽象化設計；折扣規則的設計機制

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 抽象化（Abstraction）的核心精神是什麼？
隱藏細節、提取重點。亦即把與問題無直接關係的實作細節隔離，只留下能解決問題所需的關鍵概念與行為。

## Q: 作者補充後對「抽象化」的完整定義是？
抽象化＝「提取重點，使主系統僅依這些重點設計流程；同時隱藏細節，讓與重點無關的變動不影響主系統，即便日後細節修改，主系統仍能正常運作」。

## Q: 為何僅用「歸納法」無法長久應付折扣規則？
歸納法只能從「已知」需求萃取規則，對未知或未來出現的新型折扣缺乏彈性，最後會衍生大量 if/else 或旗標 (flag) 設定，系統愈來愈難維護。

## Q: 文章中折扣機制抽象化後，購物車真正關注的重點是什麼？
購物車只關心兩件事：
1. 每條折扣規則在目前商品組合下能否成立？  
2. 若成立可折抵多少金額？  
至於計算過程、演算法與判斷條件則全數被隱藏在各別折扣模組裡。

## Q: 文章如何利用 OOP 把折扣規則抽象化？
1. 定義抽象基底 `RuleBase`，公開 `Process(Product[]/CartContext)` 介面，回傳 `IEnumerable<Discount>`。  
2. 每種折扣（第二件六折、滿件折百等）各自繼承 `RuleBase`，只實作自己的計算邏輯。  
3. 購物車（POS）僅按順序呼叫所有 `RuleBase` 物件，累加折抵金額，不需知道任何規則細節。  
如此即可新增、移除或調整折扣，而主流程一行碼都不用改。

## Q: OOP 三大權杖是哪些？它們與抽象化的關係為何？
1. 封裝 (Encapsulation) ─ 用來「隱藏細節」，是抽象化的手段。  
2. 繼承 (Inheritance) ─ 把共通行為上提，讓不同規則可用 is-a 關係共用介面。  
3. 多型 (Polymorphism) ─ 讓主程式可用同一型別 (`RuleBase`) 操作各種折扣規則，真正做到「一視同仁、各自表述」。

## Q: 按文中架構，日後要新增一條折扣規則只需做哪些事？
1. 建立新的類別繼承 `RuleBase`，在 `Process()` 實作自己的計算邏輯。  
2. 在系統啟動（或組態）時，把此規則物件加入 `POS.ActivedRules` 清單並排定順序。  
不必修改購物車結帳程式，也不需重新調整既有規則。