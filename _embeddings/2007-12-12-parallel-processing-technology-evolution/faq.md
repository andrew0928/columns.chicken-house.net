# 平行處理的技術演進

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是平行處理？
- A簡: 將工作切為可獨立子任務，同時分配至多核心或多執行單元執行，以縮短完成時間與提升資源利用。
- A詳: 平行處理是把一個可拆分的問題分割成多個彼此獨立或低耦合的子任務，交由多個處理單元同時執行，藉此縮短總執行時間。它與單一流程（序列）不同，強調同時進行、分工協作與合併結果。常見類型包含資料並行（同一操作套用於多筆資料）與任務並行（不同任務同時執行）。適用於高計算密度、可分割且同步成本不高的情境，如影像處理、數值模擬與批次資料處理。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q3, B-Q1, B-Q2, C-Q1

A-Q2: 為何多核心需要專為多核心設計的軟體？
- A簡: 單執行緒無法同時用滿多核心；需將工作拆分、並行安排與同步，才能實際汲取多核心效能。
- A詳: 多核心硬體提供多個可同時運作的運算單元，但若程式仍以單一執行緒序列執行，最多只用到一個核心。專為多核心設計的軟體，會在架構上支援任務拆分、平衡負載、恰當同步與避免共享資料衝突，使工作得以同時在多核心上進行。若未設計，常見問題包含：核心閒置、鎖競爭嚴重、通訊成本過高而效能不升反降。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q5, A-Q7, B-Q5, C-Q5

A-Q3: 並行（Concurrency）與平行（Parallelism）的差異？
- A簡: 並行重在正確地管理多流程互動；平行重在同時執行以提高效能，兩者相關但不等同。
- A詳: 並行關注如何組織同時存在的多個工作流程，使其互不干擾且正確互動；目標是可控的複雜度與正確性。平行則強調同一時間在多個處理單元上「同時執行」以追求速度提升。並行是設計與正確性議題，平行是效能議題。平行必須處理並行帶來的同步、共享狀態、死鎖與競賽等挑戰，但並行不一定能帶來速度提升。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q7, B-Q8, D-Q1

A-Q4: 多核心的核心價值是什麼？
- A簡: 在功耗受限下，以多個核心提升吞吐量與反應速度，讓軟體透過並行化獲得更高效能。
- A詳: 單核心時脈提升受功耗與熱限制，多核心藉由「水平擴張」提供更多同時運算能力。對軟體而言，若能有效分割任務並行執行，整體吞吐量與延遲可顯著改善。價值不僅在峰值效能，也在更好的資源利用率與可伸縮性，使應用能隨硬體核心數成長而獲益。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q26, B-Q15, D-Q10

A-Q5: 何謂「專為多核心設計」的軟體？
- A簡: 在架構層即考量並行分工、資料切分、同步策略與可伸縮性，而非事後補強的平行化。
- A詳: 專為多核心設計意味著從需求、資料結構到模組邊界皆為並行友善：任務可獨立執行、共享狀態最小化、同步粒度合理、避免阻塞熱點，並能自動調整平行度隨核心數擴張。以高階並行庫（如 TPL/TBB）或編譯器輔助取代手工執行緒管理，讓實作更簡潔且保持可維護。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q2, A-Q23, B-Q1, B-Q15

A-Q6: 為何單一流程（序列）不適合現代多核心？
- A簡: 序列程式一次只用一核心，留下其他核心閒置，無法獲取硬體並行帶來的吞吐提升。
- A詳: 序列設計假設一條執行路徑、單一共享狀態，簡化但限制效能上限。多核心提供多路平行運算能力，若不拆分任務，其他核心只能空轉。尤其在資料密集與可分割工作上，序列執行成為瓶頸。反之，並行設計能在保持正確性的前提下，同步地用滿硬體資源。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q2, B-Q5, C-Q1

A-Q7: 平行處理常見的主要困難有哪些？
- A簡: 流程控制、資料交換、臨界區、鎖競爭與競賽條件；正確性與效能兼顧最具挑戰。
- A詳: 典型難題包括：並行流程控制（拆分、同步、合併）、跨執行單元的資料交換（IPC 或共享記憶體）、臨界區保護（不可同時執行的片段）、鎖與競賽條件（資料一致性）、以及負載平衡與死鎖避免。多數精力容易耗在基礎機制，而非業務問題本身，故建議採用高階並行庫簡化。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q3, A-Q8, A-Q9, B-Q12, D-Q2

A-Q8: 什麼是臨界區（Critical Section）？
- A簡: 需以互斥保護的程式區段，避免同時存取共享狀態導致資料毀損或結果不一致。
- A詳: 臨界區是對共享資源（變數、容器、裝置）進行讀寫的程式區段，若多執行緒同時進入，可能發生交錯寫入、撕裂更新或可見性問題。典型對策為互斥鎖、Monitor、Mutex 或讀寫鎖，搭配縮小鎖粒度與減少共享狀態以降低競爭。過度鎖定會造成效能下降或死鎖風險。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q9, D-Q3, C-Q6

A-Q9: 什麼是競賽條件（Race Condition）？
- A簡: 多執行緒對共享狀態無序競爭，依時序不同產生不一致或不穩定結果的錯誤。
- A詳: 當多條執行路徑未妥善同步地存取共享資料（讀/寫）時，結果會依執行時序而變動，導致間歇性錯誤與難以重現的問題。預防方式包含：使用正確的同步原語、不可變資料結構、訊息傳遞模型，或採用無鎖演算法。偵測可靠資料競爭分析工具與單元/壓力測試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q10, D-Q2, D-Q6

A-Q10: 什麼是資料鎖（Lock）？
- A簡: 控制同一時間只有一執行單元進入受保護區段的機制，確保共享資料一致性。
- A詳: 鎖是互斥與同步的基礎原語，保證臨界區在任一時刻僅被一個執行緒執行。常見類型有互斥鎖（Mutex/Monitor）、讀寫鎖（多讀單寫），以及自旋鎖。正確使用可避免競賽，但過度或不當使用會造成鎖競爭、活鎖或死鎖，並拖累可伸縮性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q9, B-Q9, D-Q3

A-Q11: 什麼是 IPC（跨程序通訊）？
- A簡: 多進程間交換資料的機制，如管道、共享記憶體、Socket、訊號等。
- A詳: IPC 提供多個彼此隔離的程序交換資料與同步事件的方法。常見手段包含匿名/具名管道、共享記憶體與記憶體映射檔、消息佇列、Socket/TCP，以及訊號（signal）。多進程具更強隔離性與穩定性，但通訊與序列化成本較高，適合跨語言或安全性需求高的場合。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q11, C-Q9, D-Q1

A-Q12: fork 是什麼？在早期 Unix 如何運作？
- A簡: fork 複製當前程序形成子程序，父子同時執行；通訊需靠 IPC 機制協調。
- A詳: 在 Unix，fork 會建立一個近乎相同的子程序，擁有各自的位址空間與檔案描述子拷貝。父子分別從 fork 返回點繼續執行，彼此身份需自行分辨，並透過 IPC（如管道、共享記憶體、訊號）交換資料或同步。優點是隔離穩定與安全；缺點是資料共享困難、通訊與同步成本高。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, B-Q11, D-Q1

A-Q13: 執行緒（Thread）與程序（Process）差異？
- A簡: 程序具獨立資源與隔離；執行緒共享程序資源，啟動快但需自行同步共享狀態。
- A詳: 程序是資源配置與保護單位，彼此隔離；執行緒是執行單元，共享程序記憶體與開啟資源。多執行緒通訊成本低、切換快，但共享狀態帶來同步挑戰。多程序較穩定與安全，跨程序通訊成本高。選擇取決於隔離需求、穩定性要求與通訊延遲容忍度。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, A-Q11, B-Q12, D-Q4

A-Q14: Java 對多執行緒帶來什麼改變？
- A簡: 提供標準化執行緒與同步抽象，降低並行程式撰寫門檻，促進跨平台一致性。
- A詳: Java 內建 Thread、synchronized、wait/notify、Executor 等抽象，搭配記憶體模型定義與並行容器，讓多執行緒更一致與易用。它使開發者不必從 OS 原生 API 起步，轉而專注於任務拆分與正確同步，降低錯誤風險與學習成本。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q15, B-Q13, B-Q12, C-Q3

A-Q15: 什麼是 TPL（Task Parallel Library）？
- A簡: .NET 的任務平行函式庫，以 Task 與 Parallel API 簡化並行，並自動調度到適當執行緒。
- A詳: TPL 透過 Task 抽象與 Parallel.For/ForEach 等高階 API，將並行化包裝為委派工作。開發者只需描述「要做什麼」，由排程器決定「在哪裡與何時做」。它建立在執行緒集區之上，提供工作竊取、負載平衡與續延（延續）等能力，降低手動管理執行緒與同步的負擔。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, B-Q1, B-Q2, C-Q1

A-Q16: Parallel.For 是什麼？有何好處？
- A簡: 將迴圈每次迭代視為任務分派平行執行，自動分割負載並利用多核心加速。
- A詳: Parallel.For 讓傳統 for 迴圈在不大改動邏輯下，轉為平行執行。每個迭代是獨立工作，TPL 會分塊與調度到各執行緒，並動態平衡負載。好處是程式碼簡潔、可伸縮且易於遷移既有序列邏輯；限制在於迴圈內需避免共享狀態或妥善同步。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q15, B-Q2, C-Q1, D-Q1

A-Q17: TPL 與 Thread Pool 的差異？
- A簡: Thread Pool 提供執行緒資源；TPL 在其上層以 Task 模型與排程策略封裝並行邏輯。
- A詳: 執行緒集區是可重用的執行緒來源，不提供任務關係、依賴、續延與負載平衡策略。TPL 以 Task 抽象工作單元，加入工作竊取、分塊、續延、取消與例外匯流與等待等高階能力，使並行化更直觀且可管理。開發者多以 TPL API 操作，而非直接排程執行緒。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q1, B-Q6, C-Q3, D-Q4

A-Q18: 什麼是 Task Scheduler（任務排程器）？
- A簡: 決定 Task 何時在哪個執行緒執行的元件，實作負載平衡與工作竊取等策略。
- A詳: 排程器接收待執行任務，根據系統負載與執行緒可用性分派工作。常包含每執行緒的工作佇列與工作竊取機制，避免閒置並降低鎖競爭。默認排程器建基於執行緒集區，但可自訂以滿足特定限制（如 STA/UI thread）。妥善排程可提升吞吐與公平性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q1, B-Q6, B-Q17, C-Q5

A-Q19: 什麼是資料並行與任務並行？
- A簡: 資料並行同一操作套用多資料；任務並行讓多種不同工作同時進行，兩者可混合應用。
- A詳: 資料並行（如 Parallel.For）對資料集合各元素套用相同運算；適用於獨立且均勻的工作。任務並行將不同職責的任務同時執行，適用於管線、依賴圖。混用可提升整體吞吐：例如先任務切分成多管線階段，再於每階段內做資料並行。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q16, B-Q16, C-Q2

A-Q20: 為何優先考慮並行函式庫或編譯器而非手寫執行緒？
- A簡: 高階抽象自動處理排程與同步細節，減少錯誤並提升可維護與伸縮性。
- A詳: 手寫執行緒需自行管理生命週期、同步、錯誤與負載平衡，易出錯且難維護。函式庫（TPL/TBB）與編譯器可自動選擇平行度、動態分割負載、優化鎖與快取區域，讓開發者聚焦業務邏輯。亦避免硬編碼執行緒數造成擴展受限。這是實務與專家共同建議的優先路徑。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q23, B-Q1, B-Q14, C-Q1

A-Q21: 為什麼從迴圈平行化開始最有效？
- A簡: 迴圈常見且易分割，使用 Parallel.For 轉換成本低、可迅速取得多核心加速。
- A詳: 多數計算密集型程式含有大量迭代且每次迭代相對獨立，天然適合資料並行。以 Parallel.For/ForEach 重寫可快速驗證加速潛力，風險較小。迴圈平行化也能暴露熱點，為後續任務分解與結構性改造鋪路。務必檢查迴圈內共享狀態與 I/O，以免同步成本抵銷收益。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, B-Q2, C-Q1, D-Q1

A-Q22: 何時不建議平行化？
- A簡: 工作極短或高度相依、同步成本高、I/O 受限或序列瓶頸主導時，平行化不划算。
- A詳: 平行化有固定開銷（分割、排程、同步）。當任務粒度太小、共享狀態密集、強依賴序列步驟或主要受 I/O 延遲限制時，可能加速不成反降。應用 Amdahl 定律評估可平行比例，並以量測決定策略：僅平行化計算密集且獨立的部分，避免無效並行。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q27, B-Q20, D-Q1, D-Q8

A-Q23: 為何不鼓勵先從手寫多執行緒開始？
- A簡: 手工管理同步與生命週期易出錯且難伸縮，高階庫更安全高效，也更可攜。
- A詳: 手寫多執行緒需自行處理競賽、死鎖、資源清理與工作平衡，容易把時間耗在機制而非業務。高階庫提供任務抽象、續延、取消、例外傳遞與排程策略，降低複雜度並提升效能與可維護性。在必要時可下探低階，但應以庫為先。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q20, B-Q1, B-Q6, D-Q3

A-Q24: 硬編碼固定執行緒數的風險？
- A簡: 綁死擴展能力，遇到更多核心無法受益，且在資源爭用時容易飽和或飢餓。
- A詳: 寫死執行緒數（如固定 4）讓應用在 8、16 核系統上無法等比例提升，失去硬體投資價值。固定數量也未考量 I/O、背景工作與其他程式，易造成過度或不足。應改由排程器依當前環境動態決定平行度，或以可配置/自適應策略調整。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q20, B-Q15, C-Q5, D-Q10

A-Q25: 什麼是「工作竊取」（Work Stealing）？
- A簡: 閒置執行緒從其他忙碌執行緒的工作佇列竊取任務，以提升負載平衡與吞吐。
- A詳: 在多佇列架構中，每個工作者擁有本地佇列，優先處理自己的任務；當空閒時會從其他工作者尾端「竊取」任務，以避免不均衡造成核心閒置。此策略在 TPL 與 TBB 的排程器中常見，可降低全域鎖競爭並改善快取區域性與可伸縮性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, B-Q6, B-Q17, D-Q8

A-Q26: 什麼是可伸縮性（Scalability）？
- A簡: 能隨資源（核心數）增加而近似比例地提升效能，並維持穩定效率的能力。
- A詳: 可伸縮性描述系統在增加運算資源時，吞吐量或延遲如何變化。理想是近線性，但受限於序列部分、同步與通訊成本。設計上需降低共享狀態、避免熱點鎖、使用任務/資料分割與動態負載平衡，並以量測驗證隨核心數的實際增益。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q4, A-Q24, A-Q27, B-Q15

A-Q27: Amdahl 定律對平行化的啟示？
- A簡: 效能上限受序列部分比例限制；提升平行度需縮小不可平行的區段。
- A詳: Amdahl 定律指出整體加速比受限於不可平行部分比例，就算無限多核心也有上限。實務上需聚焦：減少序列瓶頸、降低同步成本、提高可平行比例與增加任務粒度。配合量測選擇值得平行化的區塊，避免投入在低報酬區段。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, A-Q26, B-Q20, D-Q1

A-Q28: 為何平行程式的通訊成本常是瓶頸？
- A簡: 跨執行單元資料交換與同步需額外開銷，易抵銷計算加速收益。
- A詳: 無論多程序（IPC）或多執行緒（鎖、快取一致性），跨邊界溝通都帶來延遲與資源爭用。若單位計算量低或共享狀態頻繁，通訊成本會主導效能。設計上應偏重不可變資料、批量交換、降低同步頻率與就地處理，並以量測評估通訊/計算比。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, A-Q11, B-Q5, B-Q20

A-Q29: Intel TBB（Threading Building Blocks）是什麼？
- A簡: C++ 的通用並行函式庫，提供 parallel_for、任務排程與容器，支援可伸縮平行化。
- A詳: TBB 以 C++ 模板實作高階並行抽象，包括 parallel_for/reduce、flow graph、並行容器與任務排程器。它類似 .NET 的 TPL，主張以「任務」與「演算法」抽象平行化，而非直接操作執行緒。對需要高性能與可移植性的 C++ 應用特別合適。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q14, C-Q10, D-Q10

A-Q30: 平行處理技術的演進脈絡為何？
- A簡: 由多程序與 IPC，到多執行緒與同步，再到以 TPL/TBB 等高階庫自動化平行化。
- A詳: 早期以 fork 多進程，隔離強但通訊成本高；後來引入執行緒，降低共享資料交換成本，卻帶來同步難題。近年趨勢以高階並行庫與編譯器輔助（TPL/TBB），以任務與資料並行抽象，降低機制負擔、提升可伸縮性，讓開發者專注業務邏輯與正確性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, A-Q15, A-Q29, B-Q1

### Q&A 類別 B: 技術原理類

B-Q1: TPL 的運作原理是什麼？
- A簡: 以 Task 抽象工作，排程器動態分配到執行緒集區，透過分塊與工作竊取平衡負載。
- A詳: 原理說明：TPL 將工作表示為 Task，交給 TaskScheduler，通常以執行緒集區為後端。關鍵流程：建立任務→加入佇列→工作者擷取執行→必要時竊取工作→完成續延與聚合。核心組件：Task、TaskScheduler、Parallel 類別、取消/例外機制。藉由動態調整平行度與分塊，提升吞吐與可伸縮性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, A-Q18, B-Q6, C-Q3

B-Q2: Parallel.For 的執行流程與分塊策略？
- A簡: 將迭代範圍分割為區塊，由多工作者平行處理，必要時動態調整與竊取任務。
- A詳: 原理說明：迴圈範圍被切成多個連續區塊（chunk），避免每次迭代皆排程的高成本。流程：初始化分塊→分派至執行緒→執行迭代→必要時產生更小區塊→合併完成。核心組件：Parallel、Partitioner、TaskScheduler。動態分塊與工作竊取降低負載不均與長尾問題。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q5, C-Q1, D-Q1

B-Q3: TPL 中 Task 與委派（delegate）的關係？
- A簡: 委派是要執行的代碼，Task 封裝此工作並提供排程、續延與例外處理等能力。
- A詳: 原理說明：委派代表可執行的方法；Task 將其包裝成可管理工作單元。流程：用委派建立 Task→交排程器→執行→完成後可續延或匯流。核心組件：Task<TResult>、Action/Func 委派、ContinueWith/WhenAll。此分層讓「執行什麼」與「如何排程」解耦。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q15, A-Q16, C-Q3, C-Q4

B-Q4: TPL 如何利用多核心與 CPU 規模？
- A簡: 依環境核心數動態決定平行度，透過工作竊取與分塊保持所有核心忙碌。
- A詳: 原理說明：排程器會根據可用處理器數（Environment.ProcessorCount）與系統負載自動調整工作者數。流程：估算平行度→建立任務→執行與竊取→觀察完成率與負載調整。核心組件：TaskScheduler、ThreadPool、ParallelOptions。這降低硬編碼帶來的擴展限制。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q24, B-Q6, C-Q5, D-Q10

B-Q5: 任務分割與粒度設計的原理？
- A簡: 任務需足夠粗以攤平排程成本，且足夠細以利負載平衡；以量測調參最佳化。
- A詳: 原理說明：平行化有分割與排程開銷。過細導致管理成本高；過粗負載不均。流程：找熱點→估算單位工作時間→設定初始分塊→量測→調整。核心組件：Partitioner、自訂分塊策略、ParallelOptions。目標是最大化計算/同步比並縮短尾端拖累。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q21, A-Q22, B-Q2, D-Q1

B-Q6: TPL 與 Thread Pool 的差異與關係？
- A簡: Thread Pool 提供執行緒資源；TPL 在其上實作任務模型、工作竊取與依賴管理。
- A詳: 原理說明：Thread Pool 是底層執行緒管理；TPL 以 Task 為單位封裝工作、續延、取消、例外傳遞，透過 TaskScheduler 管理分派。流程：Task 入列→工作者執行→續延佇列→完成匯流。核心組件：Task、TaskScheduler、ThreadPool。TPL 提升抽象層次與可維護性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, A-Q18, C-Q3, D-Q4

B-Q7: 任務完成通知與匯流機制如何運作？
- A簡: 透過續延（ContinueWith/WhenAll）與等待（Wait）協調依賴與結果收斂。
- A詳: 原理說明：完成通知透過 Task 狀態轉移與回呼；匯流用 WhenAll/WhenAny 聚合多任務。流程：建立任務→設定續延→平行執行→條件滿足觸發續延→結果收斂。核心組件：Task 經常態、續延 API、CancellationToken。這避免繁瑣的事件與旗標同步。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q4, D-Q7, A-Q7

B-Q8: Fork-Join 並行模型的機制？
- A簡: 將工作分叉為子任務平行執行，完成後在 Join 階段合併結果與同步。
- A詳: 原理說明：Fork 將任務遞迴切分，Join 匯聚結果。流程：拆分→提交子任務→平行執行→等待全部完成→合併。核心組件：Task遞迴、工作竊取排程、WhenAll。適用於分治演算法與樹狀處理，易映射到 TPL/TBB 的任務模型。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q19, B-Q2, C-Q3, C-Q8

B-Q9: 臨界區保護原理與常用同步原語？
- A簡: 以互斥確保一次僅一執行緒進入；常用 Monitor、Mutex、SemaphoreSlim、RWLock。
- A詳: 原理說明：互斥排他訪問共享資源，避免交錯寫入。流程：嘗試取得鎖→執行受保護區段→釋放。核心組件：lock(Monitor)、Mutex、Semaphore(Slim)、ReaderWriterLockSlim。選擇需考量等待策略、跨程序需求與讀寫比例，以兼顧效能與正確性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q10, D-Q3, C-Q6

B-Q10: 資料競爭偵測與避免的原理？
- A簡: 透過恰當同步、不可變物件與訊息傳遞避免；以分析工具與測試發現隱性競賽。
- A詳: 原理說明：競賽來自未同步的讀寫交錯。預防以鎖、原子操作、不可變資料或使用無共享模型（如消息佇列）。流程：識別共享狀態→決定同步策略→實作→用競賽檢測器與壓力測試驗證。核心組件：Interlocked、Concurrent 容器、通道/隊列。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q9, B-Q9, C-Q6, D-Q2

B-Q11: 多進程平行中的 IPC 機制如何運作？
- A簡: 以共享記憶體、管道或 Socket 傳遞資料，輔以訊號/事件同步跨程序協作。
- A詳: 原理說明：多進程各自隔離，需明確交換。共享記憶體速度快但需同步；管道/命名管道適於串流；Socket 跨主機；訊號/事件用於通知。流程：建立通道→序列化/拷貝資料→同步→處理→釋放。核心組件：MemoryMappedFile、NamedPipe、TcpListener、信號量。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q11, A-Q12, C-Q9, D-Q1

B-Q12: Java/.NET 如何簡化傳統執行緒與同步？
- A簡: 以標準執行緒 API、記憶體模型與高階並行庫，統一抽象並降低錯誤率。
- A詳: 原理說明：語言/平台提供一致的執行緒、鎖與可見性保證。流程：以高階 API 表達並行→由執行階段落實同步與排程。核心組件：Java Executor、.NET Task/TPL、並行容器與同步原語。使開發者免於處理 OS 細節，提升可攜與可維護性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q14, A-Q15, B-Q1, C-Q2

B-Q13: 例外在平行環境中的傳播與匯流？
- A簡: 任務內例外被封裝，於等待或匯流時聚合拋出，需顯式處理 AggregateException。
- A詳: 原理說明：Task 擷取例外並延遲至 Wait/Result/WhenAll 時拋出聚合例外。流程：執行任務→例外封裝→匯流→攔截 AggregateException→逐一處理。核心組件：AggregateException、ContinueWith 的 OnlyOnFaulted 選項。可避免未觀察例外造成崩潰。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q4, D-Q7, B-Q7, A-Q7

B-Q14: Intel TBB 的架構與核心元件？
- A簡: 任務排程器、parallel_for/reduce、flow graph 與並行容器，共同提供可伸縮抽象。
- A詳: 原理說明：TBB 以任務為核心，透過工作竊取排程；提供演算法模板與流圖管理依賴。流程：設計任務→映射至 parallel 算法→排程→執行→匯流。核心組件：task_scheduler_init、parallel_for、concurrent_* 容器、flow::graph。讓 C++ 採用現代平行模式。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q29, C-Q10, B-Q17, A-Q20

B-Q15: 可伸縮設計如何避免硬編碼平行度？
- A簡: 以排程器自適應平行度與配置參數化，並據量測自動或動態調整。
- A詳: 原理說明：讓平行度由環境與負載決定，不寫死執行緒數。流程：讀取可用核心數→設 ParallelOptions/TaskScheduler→量測→自動調整 MaxDegreeOfParallelism。核心組件：Environment.ProcessorCount、ParallelOptions、TPL Dataflow（選用）。提升跨平台效能可預測性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q24, B-Q4, C-Q5, D-Q10

B-Q16: 任務依賴（DAG）與排程原理？
- A簡: 以有向無環圖表示依賴，僅就緒任務可執行，藉並行度最大化縮短整體時間。
- A詳: 原理說明：節點為任務、邊為依賴，拓撲排序確定合法執行序。流程：建圖→標記就緒→分派執行→完成更新→迭代至終止。核心組件：續延（ContinueWith）、WhenAll/WhenAny、flow graph。此模型統一描述任務並行與匯流。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q19, B-Q7, C-Q4, D-Q7

B-Q17: 負載平衡與工作分配策略有哪些？
- A簡: 靜態分配、動態分塊、工作竊取與自適應調整，依工作時長分布選用。
- A詳: 原理說明：靜態策略簡單但遇長尾差；動態分塊可漸進切小；工作竊取在多佇列系統有效；自適應依量測調參。流程：估測→選策略→運行觀測→調整。核心組件：Partitioner、自訂排程器、量測探針。目標是讓所有核心盡量無閒置。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q25, B-Q2, B-Q5, D-Q8

B-Q18: 記憶體一致性與平行安全讀寫的原理？
- A簡: 需透過同步建立「happens-before」關係，確保寫入對其他執行緒可見。
- A詳: 原理說明：處理器與編譯器可能重排序存取，導致可見性問題。同步原語（鎖、volatile、fence）建立有序關係。流程：在共享變數讀寫點加入同步→驗證不變式。核心組件：Monitor 進出、volatile 欄位、Interlocked、Thread.MemoryBarrier。確保無資料撕裂與陳舊讀取。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q8, A-Q9, B-Q9, D-Q2

B-Q19: 鎖的成本與無鎖策略概觀？
- A簡: 鎖有競爭與上下文切換成本；可用原子操作、不可變物件與無鎖容器降低鎖壓。
- A詳: 原理說明：鎖引入等待與排他，競爭下效能下降。無鎖以 CAS（Compare-And-Swap）與原子原語維持一致性。流程：選取共享熱點→評估鎖成本→改為分區、批次或無鎖結構。核心組件：Interlocked、ConcurrentQueue/Dictionary、不可變集合。權衡複雜度與安全性。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q9, B-Q10, C-Q6, D-Q8

B-Q20: 何時平行化不划算？如何判斷？
- A簡: 當計算/同步比低或序列瓶頸大；以量測比較序列與平行路徑的真實時間。
- A詳: 原理說明：平行化有固定開銷與潛在競爭。判斷流程：建立序列基線→平行化熱點→量測總時間與 CPU 利用→分析競爭與長尾→回退或調整粒度。核心組件：計時器、分析器、Partitioner。以 Amdahl 定律評估上限，避免過度工程。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, A-Q27, B-Q5, D-Q1

### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何將序列 for 迴圈改為 Parallel.For？
- A簡: 以 Parallel.For 包裹迴圈範圍，將每次迭代封裝為委派並行處理，避免共享狀態。
- A詳: 步驟：1) 引入 System.Threading.Tasks；2) 確認每次迭代獨立；3) 用 Parallel.For 取代 for；4) 量測效能。程式碼片段:
  ```csharp
  Parallel.For(0, n, i => { a[i] = a[i] * a[i]; });
  ```
  注意事項：避免迴圈內寫入共享變數；必要時用本地累加後再合併；用 Partition 優化粒度。最佳實踐：先建立序列基線，再平行化並驗證結果一致。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, B-Q2, D-Q1, D-Q7

C-Q2: 如何用 Parallel.ForEach 平行處理集合？
- A簡: 使用 Parallel.ForEach 對集合項目並行執行委派，適合可獨立處理的資料集。
- A詳: 步驟：1) 確認項目間無共享依賴；2) 呼叫 Parallel.ForEach；3) 視需要設定 ParallelOptions。程式碼:
  ```csharp
  Parallel.ForEach(items, item => Process(item));
  ```
  注意事項：I/O 密集可限制平行度；避免在迭代內鎖定全域資源。最佳實踐：以本地緩衝或批次寫入降低競爭，使用 Concurrent 集合安全收集結果。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q19, B-Q2, B-Q12, D-Q8

C-Q3: 如何建立 Task 並等待完成？
- A簡: 以 Task.Run 建立任務，使用 Wait/Result 或 await 等待；注意例外會聚合拋出。
- A詳: 步驟：1) 建立任務；2) 啟動並回傳 Task；3) 等待或續延。程式碼:
  ```csharp
  var t = Task.Run(() => Work());
  t.Wait(); // 或 var r = await Task.Run(F);
  ```
  注意事項：避免同步 Wait 阻塞 UI 執行緒；處理 AggregateException。最佳實踐：以 async/await 撰寫非阻塞等待，使用 CancellationToken 支援取消。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q3, B-Q7, D-Q7, A-Q17

C-Q4: 如何在任務完成時執行續延與匯流？
- A簡: 使用 ContinueWith/WhenAll 組合任務依賴，於全部完成後合併結果或觸發後續。
- A詳: 步驟：1) 建立多個任務；2) 使用 Task.WhenAll 匯流；3) 建立續延處理結果。程式碼:
  ```csharp
  var tasks = list.Select(x => Task.Run(() => F(x)));
  var all = Task.WhenAll(tasks);
  var cont = all.ContinueWith(t => Aggregate(t.Result));
  ```
  注意事項：處理匯流例外；避免在續延中阻塞。最佳實踐：以 OnlyOnFaulted/RunContinuationsAsynchronously 精確控制時機。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, B-Q13, D-Q7, B-Q16

C-Q5: 如何控制最大平行度與避免過度競爭？
- A簡: 設定 ParallelOptions.MaxDegreeOfParallelism 或自訂排程器，使平行度與資源相符。
- A詳: 步驟：1) 檢視 ProcessorCount 與工作型態；2) 設 ParallelOptions；3) 測試調整。程式碼:
  ```csharp
  var opt = new ParallelOptions { MaxDegreeOfParallelism =  Environment.ProcessorCount };
  Parallel.ForEach(items, opt, item => DoWork(item));
  ```
  注意事項：I/O 密集時平行度可略大於核心數；CPU 密集則相近或等於核心數。最佳實踐：以量測驅動設定，避免硬編碼固定值。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q24, B-Q4, B-Q15, D-Q10

C-Q6: 如何保護臨界區並降低鎖競爭？
- A簡: 以 lock/ReaderWriterLockSlim 保護共享狀態，並縮小鎖粒度與改用局部累積合併。
- A詳: 步驟：1) 辨識共享熱點；2) 以 lock 包覆；3) 改良為細粒度鎖或讀寫鎖。程式碼:
  ```csharp
  private readonly object _gate = new object();
  lock(_gate) { shared[x]++; }
  ```
  注意事項：避免在鎖內做 I/O 或長時間運算；考慮 Concurrent 集合或 Interlocked。最佳實踐：採用「複製-修改-交換」或分區化減少衝突。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q10, B-Q9, D-Q3

C-Q7: 如何避免平行迴圈中的共享狀態副作用？
- A簡: 使用本地變數與 ThreadLocal/LocalInit，最後以安全方式匯總結果，避免交錯寫入。
- A詳: 步驟：1) 將每次迭代的累積改用區域儲存；2) 在迴圈結束時合併。程式碼:
  ```csharp
  int sum = 0;
  Parallel.For(0, n,
    () => 0,
    (i, s, local) => local + a[i],
    local => Interlocked.Add(ref sum, local));
  ```
  注意事項：使用 Interlocked/lock 合併；避免在迭代內更新全域計數器。最佳實踐：先設計純函數式操作，再決定安全匯流點。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q2, B-Q10, D-Q2, D-Q7

C-Q8: 如何為不均勻工作量設計自訂分區？
- A簡: 以 Partitioner.Create 產生動態分塊，讓長任務可被切分並改善負載平衡。
- A詳: 步驟：1) 分析工作時間分布；2) 使用 Partitioner.Create(range, true)；3) 以 Parallel.ForEach 搭配。程式碼:
  ```csharp
  var part = Partitioner.Create(0, n, rangeSize: 100);
  Parallel.ForEach(part, range => { for (int i=range.Item1; i<range.Item2; i++) Do(i); });
  ```
  注意事項：調整區塊大小；避免過細。最佳實踐：以量測調參，並搭配續延分拆長尾工作。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q2, B-Q5, B-Q17, D-Q8

C-Q9: 在多進程中用具名管道交換資料怎麼做？
- A簡: 使用 NamedPipeServerStream/ClientStream 建立連線，序列化資料傳送與接收。
- A詳: 步驟：1) 伺服器端建立 NamedPipeServerStream；2) 等候連線並讀寫；3) 客戶端連線。程式碼:
  ```csharp
  using var srv = new NamedPipeServerStream("mypipe");
  srv.WaitForConnection();
  new StreamWriter(srv).WriteLine(msg);
  ```
  注意事項：定義協定與長度前綴；處理逾時與中斷。最佳實踐：以二進位序列化與批次傳輸減少開銷。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q11, B-Q11, D-Q1, D-Q7

C-Q10: 如何用 Intel TBB 的 parallel_for 改寫迴圈？
- A簡: 在 C++ 以 tbb::parallel_for 將迭代域並行化，依 TBB 排程器自動分塊與負載平衡。
- A詳: 步驟：1) 初始化 tbb；2) 使用 parallel_for；3) 確保迭代獨立。程式碼:
  ```cpp
  tbb::parallel_for(0, n, [&](int i){ a[i] = a[i]*a[i]; });
  ```
  注意事項：避免共享狀態與全域寫入；必要時用 concurrent 容器。最佳實踐：以 blocked_range 與自訂分割器調整粒度，量測優化。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q29, B-Q14, D-Q8, A-Q21

### Q&A 類別 D: 問題解決類（10題）

D-Q1: 平行迴圈效能不升反降怎麼辦？
- A簡: 檢查任務粒度、共享狀態與 I/O；調整分塊與平行度，以量測導向優化或回退序列。
- A詳: 症狀：CPU 未滿載、時間更長。可能原因：任務過小排程成本高、鎖競爭、I/O 阻塞、序列瓶頸。解決步驟：1) 建立序列基線；2) 加大粒度/動態分塊；3) 降低共享狀態；4) 限制平行度；5) 分離 I/O。預防：先以微基準測試估算計算/同步比，迭代量測調參。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q2, B-Q5, A-Q22, A-Q27

D-Q2: 平行處理結果偶發錯誤，可能是競賽嗎？
- A簡: 是。檢查共享變數與未同步存取，改用鎖、原子操作或不可變資料並增加測試。
- A詳: 症狀：偶發錯誤、難重現。原因：共享狀態未同步、記憶體可見性問題。解決：1) 盤點共享變數；2) 對寫入加鎖或用 Interlocked；3) 使用 ThreadLocal；4) 加入壓力/隨機化測試。預防：以不可變資料與純函數減少共享，採工具偵測競賽。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q10, C-Q7, B-Q18

D-Q3: 遇到死鎖該如何診斷與修復？
- A簡: 透過轉儲與執行緒堆疊分析鎖順序，統一鎖順序或改為細粒度/無鎖結構解決。
- A詳: 症狀：程式卡住、CPU 低。原因：循環等待、鎖順序不一致。解決：1) 取得 dump 分析鎖；2) 強制一致鎖順序；3) 缩小臨界區；4) 用超時或嘗試鎖；5) 考慮無鎖替代。預防：設計時定義鎖階層，避免在鎖內進行 I/O 或長任務。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q8, A-Q10, B-Q9, C-Q6

D-Q4: ThreadPool 耗盡或執行緒飢餓怎麼辦？
- A簡: 避免長時間同步阻塞，改用非同步 I/O，限制工作數並拆分長任務。
- A詳: 症狀：任務排隊延遲、UI 卡頓。原因：ThreadPool 執行緒被阻塞、過量同步等待。解決：1) 以 async/await 改寫 I/O；2) 將 CPU 任務分批；3) 限制平行度；4) 避免在執行緒集區上同步 Wait。預防：使用非阻塞設計與可觀測度指標監控佇列長度。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, B-Q6, C-Q5, C-Q3

D-Q5: 平行處理導致快取失誤與記憶體爭用怎麼辦？
- A簡: 降低共享與假共享，對齊/填充結構，提升區域性並用分區化策略。
- A詳: 症狀：CPU 高但吞吐差，隨核心數擴展不佳。原因：共享熱點、假共享造成快取線抖動。解決：1) 以分區資料結構減少共享；2) 對齊/填充避免多執行緒寫同一快取線；3) 批次處理提升區域性。預防：以分析器檢視快取行為，設計就地運算。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q17, B-Q19, C-Q6, A-Q28

D-Q6: 非決定性行為（結果順序不固定）如何處理？
- A簡: 接受無序性或在必要處明確排序/同步，避免依賴平行執行順序。
- A詳: 症狀：輸出順序浮動。原因：任務完成時間不同。解決：1) 若不需排序，改為收集後再整體處理；2) 若需穩定性，收集包含索引並最後排序；3) 對需一致性的副作用加鎖。預防：設計上避免依賴迭代順序，將排序作為明確後處理步驟。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, C-Q2, C-Q7, A-Q3

D-Q7: 平行任務的例外要怎麼正確處理？
- A簡: 於 await/Wait/WhenAll 處攔截 AggregateException，分辨個別例外並記錄回報。
- A詳: 症狀：平行任務失敗但錯誤不易發現。原因：例外封裝延遲拋出。解決：1) 在匯流點捕捉 AggregateException；2) 逐一處理 InnerExceptions；3) 在 ContinueWith(OnlyOnFaulted) 記錄與補償。預防：統一錯誤策略與監控，避免吞掉例外。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q13, B-Q7, C-Q4, C-Q3

D-Q8: 平行度過高導致系統抖動如何診斷？
- A簡: 觀察 CPU/佇列長度/上下文切換，降低平行度並改善分塊與共享熱點。
- A詳: 症狀：高抖動、吞吐波動。原因：過度平行化造成排程競爭、上下文切換與鎖衝突。解決：1) 設定 MaxDegreeOfParallelism；2) 使用動態分塊；3) 降低共享；4) 微調任務粒度。預防：以容量測試找最佳平行度曲線，設定上限保護。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q17, C-Q5, C-Q8, B-Q5

D-Q9: I/O 密集任務平行化後效果不佳怎麼辦？
- A簡: 改用非同步 I/O 與併發數限制，避免用 CPU 平行度掩蓋 I/O 延遲。
- A詳: 症狀：CPU 低、延遲高。原因：I/O 等待主導，平行度提升無效。解決：1) 用 async I/O；2) 設定連線/檔案併發上限；3) 批次與流水線處理；4) 隔離 CPU 與 I/O 階段。預防：區分 CPU/I/O 型任務，採不同策略管理併發。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, C-Q5, C-Q2, B-Q20

D-Q10: 為何在多核心機器上看不到線性擴展？
- A簡: 受序列部分、同步與通訊成本、假共享與 OS 競爭影響；需設計與量測調整。
- A詳: 症狀：核心增加但效能提升有限。原因：Amdahl 限制、鎖競爭、通訊開銷、固定執行緒、外部負載。解決：1) 找序列熱點重構；2) 降低共享與鎖；3) 自適應平行度；4) 分離 I/O；5) 使用分析器定位瓶頸。預防：可伸縮架構與量測導向開發。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q26, A-Q24, B-Q15, B-Q20

### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是平行處理？
    - A-Q2: 為何多核心需要專為多核心設計的軟體？
    - A-Q3: 並行與平行的差異？
    - A-Q4: 多核心的核心價值是什麼？
    - A-Q5: 何謂「專為多核心設計」的軟體？
    - A-Q6: 為何單一流程不適合現代多核心？
    - A-Q13: 執行緒與程序差異？
    - A-Q14: Java 對多執行緒帶來什麼改變？
    - A-Q15: 什麼是 TPL（Task Parallel Library）？
    - A-Q16: Parallel.For 是什麼？有何好處？
    - A-Q19: 什麼是資料並行與任務並行？
    - C-Q1: 如何將序列 for 迴圈改為 Parallel.For？
    - C-Q2: 如何用 Parallel.ForEach 平行處理集合？
    - C-Q3: 如何建立 Task 並等待完成？
    - D-Q6: 非決定性行為如何處理？

- 中級者：建議學習哪 20 題
    - A-Q7: 平行處理的主要困難有哪些？
    - A-Q8: 什麼是臨界區？
    - A-Q9: 什麼是競賽條件？
    - A-Q10: 什麼是資料鎖？
    - A-Q18: 什麼是 Task Scheduler？
    - A-Q20: 為何優先用函式庫或編譯器？
    - A-Q21: 為什麼從迴圈平行化開始？
    - B-Q1: TPL 的運作原理是什麼？
    - B-Q2: Parallel.For 的執行流程？
    - B-Q3: Task 與委派的關係？
    - B-Q4: TPL 如何利用多核心？
    - B-Q6: TPL 與 Thread Pool 的關係？
    - B-Q7: 任務完成通知與匯流機制
    - B-Q9: 臨界區保護與同步原語
    - B-Q13: 例外在平行中的傳播
    - C-Q4: 續延與匯流的實作
    - C-Q5: 控制最大平行度
    - C-Q6: 保護臨界區並降鎖競爭
    - D-Q1: 平行迴圈效能不升反降
    - D-Q7: 平行任務的例外處理

- 高級者：建議關注哪 15 題
    - A-Q22: 何時不建議平行化？
    - A-Q24: 硬編碼固定執行緒數的風險？
    - A-Q25: 什麼是工作竊取？
    - A-Q26: 什麼是可伸縮性？
    - A-Q27: Amdahl 定律啟示
    - A-Q28: 為何通訊成本常是瓶頸？
    - A-Q29: 什麼是 Intel TBB？
    - B-Q5: 任務分割與粒度設計
    - B-Q16: 任務依賴（DAG）與排程
    - B-Q17: 負載平衡與分配策略
    - B-Q18: 記憶體一致性與平行安全
    - B-Q19: 鎖成本與無鎖策略
    - C-Q7: 避免共享狀態副作用
    - C-Q8: 自訂分區處理不均勻工作
    - D-Q10: 多核心未線性擴展的診斷