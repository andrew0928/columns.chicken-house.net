# 架構面試題 #3, RDBMS 處理樹狀結構的技巧

# 問答集 (FAQ, frequently asked questions and answers)

## Q: RDBMS 中常見用來儲存並操作樹狀資料的三種典型方案是什麼？
1. 方案 1：在節點表內存 `PARENT_ID`，以 self-join 或 CTE 做遞迴查詢。  
2. 方案 2：預先為每一階層開一欄 (ID1‥IDn) 儲存父節點路徑。  
3. 方案 3：Nested Set Model（又稱 Modified Pre-order Traversal），為每個節點維護 `LEFT_INDEX` / `RIGHT_INDEX` 範圍。

## Q: 方案 1（self-join / CTE）最大的優勢與缺點分別是什麼？
優勢：  
• 結構與課本上的 Tree 定義一致，對「搬移、刪除、建立」等節點異動直覺且簡單。  

缺點：  
• 查詢子樹須遞迴 self-join，或仰賴 CTE／CONNECT BY 等專有語法，效能差且易受 DBMS 限制。  
• 在大型資料集（文中 110 萬檔案）中，遞迴搜尋花費秒級甚至數秒以上時間，遠慢於其他方案。

## Q: 方案 2（一層一欄）的強項與限制是什麼？
強項：  
• 任何深度的查詢都能直接用索引比對，速度最快，本例搜尋 110 萬檔案只要 0.067 sec。  

限制：  
• 資料表必須事先決定最大深度，超出就得改 schema 與 SQL。  
• INSERT / MOVE 必須同時維護 20 個欄位，SQL 難寫、難維護；易產生動態 SQL 與 SQL Injection 風險。  
• 不適合階層變動頻繁的場景。

## Q: 方案 3（Nested Set Model）的核心原理是什麼？
透過 Depth-First Traversal 走訪整棵樹，為每個節點標記連續的 `LEFT_INDEX` 與 `RIGHT_INDEX`。  
父節點區間必定完全包覆所有子節點，因此：  
• 查詢整個子樹只需 `WHERE LEFT BETWEEN parent.LEFT AND parent.RIGHT`，不需遞迴。  
• 子節點數可用 `(RIGHT-LEFT-1)/2` 直接計算。  
• 異動（插入、搬移、刪除）時，須批次平移受影響的 index 以保持連續性。

## Q: 在作者的實測（22 萬目錄、110 萬檔案）中，哪一方案的整體表現最佳？為什麼？
方案 3。  
它兼具方案 1 的結構彈性與方案 2 的搜尋效率：  
• 大量遞迴查詢速度與方案 2 同級 (≈0.5 sec)。  
• 大量刪除亦快於方案 1、方案 2（約 9 sec）。  
• SQL 可寫成固定且可維護的腳本，無最大深度限制。

## Q: 若系統幾乎只有查詢、很少發生目錄搬移，是否仍需選擇 Nested Set Model？
可視情況採用方案 2。  
若能保證樹的最大深度、接受 schema 固定，且極度重視查詢極致速度，方案 2 的純查詢效能最高。  
否則建議使用方案 3 取得速度與可維護性的平衡。

## Q: CTE 在方案 1 中扮演什麼角色？能解決效能問題嗎？
CTE (Common Table Expression) 讓開發者用遞迴寫法簡化 SQL，但底層仍需逐層 self-join，  
僅改善「可讀性」，對大資料量的效能提升有限，文中測試依舊落後其他方案 1–2 個數量級。

## Q: 作者撰寫本文的主要動機與結論是什麼？
動機：透過一個「怎麼在 RDBMS 儲存 / 操作樹狀結構」的面試題，提醒開發者：  
• 工具再新穎，也需建立在紮實的資料結構與資料庫基礎知識上。  
• 先把資料整理成最容易查詢的型態，願意在「寫入／異動」時多花力氣維護索引，長期效益遠高於事後補救。  

結論：面對大型樹狀資料，Nested Set Model 往往是查詢、維護、可移植性三者最均衡的做法；  
而真正關鍵的並非特定 DB 的「黑科技」，而是開發者對資料結構與關聯式模型的深度理解。