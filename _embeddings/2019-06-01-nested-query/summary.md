# 架構面試題 #3, RDBMS 處理樹狀結構的技巧

## 摘要提示
- Tree in RDBMS: 關聯式資料庫天生不適合遞迴樹狀結構，需靠設計補強。
- 方案一(Self-Join): 以 Parent_ID 表示父子關係，寫法直覺但遞迴查詢效能差。
- CTE 遞迴: SQL2005 之後支援，用以簡化多層 Self-Join，但計算成本仍高。
- 方案二(欄位展平): 為每層預留欄位(PATH1~PATH20)，查詢快但結構僵化、維護複雜。
- 方案三(Nested Set): 以 Left/Right 範圍索引記錄覆蓋關係，兼具效率與語法簡潔。
- 建立/搬移/刪除: 三方案在目錄新增、搬移、遞迴刪除上的操作難易度與效能差異大。
- 數據量測: 22 萬目錄、110 萬檔案實測，方案三在大型遞迴搜尋與批次刪除最均衡。
- 索引維護: 將額外索引維護放到應用層執行，可換取查詢時效能。
- 技術選擇: 先理解資料特性再挑工具，基礎知識決定架構品質。
- 延伸閱讀: CTE、CONNECT BY、HierarchyID、Nested Set 與範例程式庫。

## 全文重點
本文討論在只能使用傳統 RDBMS 的前提下，如何高效處理樹狀資料，並以 Windows 檔案系統 22 萬目錄、110 萬檔案為範例，實測三種典型 Schema 設計。  
方案一以 Parent_ID 自關聯搭配 CTE 完成遞迴，程式碼直觀、搬移簡單，但深層查詢需多次 Self-Join，對 CPU 與 I/O 皆不利；在模擬搜尋 *.dll 時耗時 8 秒。  
方案二預先將每層節點 ID 攤平成多個欄位(PATH1~PATH20)，任何遞迴查詢均可改寫成單次條件篩選，速度可達 0.07 秒；然而階層上限被欄位數綁死，搬移需「整排 shift」，SQL 注入與維護成本高。  
方案三採 Nested Set Model，於節點加 Left/Right 兩索引記錄覆蓋範圍，所有「取子樹」僅靠 Between 比對完成，查詢效能與方案二相當，且不受階層限制；新增/搬移需同步調整大量索引，但仍在秒級內完成。  
綜合比較，在 Web 或雲端大量讀取少量搬移的場景下，Nested Set 為最平衡選項；若搬移極少且層級固定，可選展平成欄位；若需頻繁結構異動才考慮 Self-Join＋CTE。作者強調，真正決定效果的是對資料與演算法的理解，而非單一 DB 功能，並分享用 .NET 於匯入階段一次產生三組索引的實務經驗，呼籲開發者夯實基礎、靈活選擇工具。

## 段落重點
### 開始前的準備
以 File System 為例鎖定三大操作：遞迴搜尋、目錄搬移、目錄刪除；撰寫工具將 C:\ 22 萬目錄與 110 萬檔案匯入 SQL，作為後續效能基準，並列出五項測試指令。

### 方案 1：紀錄上一層目錄 ID
建立 DIRINFO with (ID, PARENT_ID)，FILEINFO 以 DIR_ID 關聯；利用 Self-Join 與 CTE 完成遞迴查詢，新增/搬移僅需單次 Insert/Update，惟深層搜尋需多次 Join，模擬 *.dll 搜尋耗 8 秒，刪除整棵子樹亦超過 22 秒。

### 方案 2：開欄位記錄每層目錄 ID
在 DIRINFO 中預留 PATH1~PATH20 儲存各層 ID，任何層級查詢皆可直接以 PATHn 篩選，*.dll 搜尋僅 0.07 秒；缺點為階層上限固定、SQL 動態性差，搬移需大量欄位 shift update，語法冗長且易出錯。

### 方案 3：標記涵蓋範圍 (Nested Set)
對每節點計算 Left/Right，父節點範圍完全包覆子節點；透過 Between 就能取子樹，*.dll 搜尋 0.54 秒；新增目錄需批量右移索引，搬移則分三步：節點暫存、騰空區間、回填暫存；整體仍在半秒完成，大量刪除含回收索引約 9 秒。

### 小結：三種方案比較
統整五項測試執行時間，方案一在遞迴查詢最慢被淘汰；方案二最快但可維護性差；方案三搜尋接近方案二、更新複雜度又低於方案二，是大型讀多寫少系統的折衷首選。選型應依業務操作頻率、階層深度及維護成本權衡。

### 寫在最後：寫這篇文章的動機
作者以自身架構師經驗強調「基礎知識比工具重要」，唯有掌握資料結構與演算法，才能在限制條件下做出最佳折衷；同時分享將索引計算前移到應用層的實務做法，鼓勵開發者累積核心概念、靈活運用各種技術。