# [設計案例] 授權碼 如何實作? #2 ‑ 序列化

## 摘要提示
- 序列化策略: 以 JSON/BSON 將授權資料轉為位元組陣列，確保格式簡單且易於擴充。
- 兩大核心類別: TokenData 定義授權資料結構，TokenHelper 負責建立、序列化、簽章與驗證流程。
- 多型驗證: 透過覆寫 TokenData.IsValidate()，可針對不同授權邏輯自訂驗證規則。
- 自訂授權範例: SiteLicenseToken 展示網站授權內容與時效判斷實作。
- 產生流程: CreateToken → 填值 → EncodeToken，最後得到可傳遞的授權字串。
- 驗證流程: DecodeToken 同時執行反序列化、簽章驗證與自訂邏輯檢查。
- BASE64 打包: 以「|」分隔資料與簽章，確保授權碼僅含 65 個 BASE64 字元以外的分隔符。
- 金鑰依賴: 產生簽章需私鑰，驗證簽章需公鑰，藉由 Init 設定 KeyStore 管理。
- 工廠模式: 使用靜態 TokenHelper 取代 new，集中生成與前置設定，降低耦合。
- 安全與擴充: 授權內容可公開，真正保護點在來源驗證與簽章不可偽造。

## 全文重點
本文說明在 .NET/C# 環境中如何設計一套「離線授權碼」機制，使軟體即使不連網也能透過一段字串即判斷功能啟用及版本授權，同時確保授權無法被偽造。作者將需求拆為「資料封裝」和「安全驗證」兩大面向，本篇聚焦於資料序列化與架構設計。  
核心架構由 TokenData 與 TokenHelper 兩個類別構成：TokenData 為抽象基底，所有授權資料結構皆繼承之，並可覆寫 IsValidate() 進行個別授權邏輯判斷；TokenHelper 為靜態工廠，統一負責授權物件的建立、序列化、簽章與驗證，封裝了 JSON→BSON 的轉換、RSA 簽章及公私鑰存取。  
授權字串由「序列化資料」與「數位簽章」兩段組成，以「|」分隔並全部轉成 Base64 字元，既保證資料完整又易於在各種通訊載體傳遞。產生流程依序為 CreateToken 取得空白物件、填入授權內容、EncodeToken 打包；驗證流程則為 DecodeToken，一次完成反序列化、簽章驗證與自訂邏輯檢查。  
文章示範 SiteLicenseToken，包含站點名稱、API 開啟與授權起迄日等欄位，並於 IsValidate() 檢查時效。所有安全性最終仍繫於私鑰保護，未持有私鑰即無法產生合法簽章；公鑰則藉由 KeyStore 供驗證使用。下一篇將深入說明數位簽章與金鑰管理。

## 段落重點
### 資料的封裝：序列化
作者首先界定需求：授權碼須含「設定資訊」與「數位簽章」，且資訊可公開、來源需被驗證。為滿足易於產生與維護的目標，採用 JSON（實際以 BSON 實作）作為序列化格式，再透過 RSA 簽章確保完整性。架構上依照工廠模式將建立與轉換職責置於靜態 TokenHelper，讓 TokenData 僅專注描述資料與驗證邏輯。如此一來，擴充新授權型別只需繼承 TokenData 並覆寫驗證，即可自動享有既有序列化與安全機制。

### 自訂 TokenData：SiteLicenseToken
為展示擴充簡易性，作者實作 SiteLicenseToken，加入 SiteTitle、EnableAPI、LicenseStartDate、LicenseEndDate 等欄位並標注 [JsonProperty] 以列入序列化，再於 IsValidate() 檢查當前時間是否落於授權期間。建立步驟僅三點：繼承 TokenData、加上欄位、覆寫驗證。倚賴 Newtonsoft.Json，序列化及反序列化皆自動處理，開發者無需關心底層格式。

### 驗證授權碼（解碼 + 驗證）
使用方首先透過 TokenHelper.Init 指定金鑰存放路徑及本機 SiteID，接著呼叫 DecodeToken。函式流程：1) 以「|」分割授權字串，解出資料與簽章；2) 反序列化還原為具體 TokenData；3) 執行 TokenData.IsValidate() 做授權邏輯檢查；4) 以公鑰驗證 RSA 簽章，確保資料未被竄改且確實來自原廠。任何一步失敗皆拋出例外，呼叫側判定授權無效。成功時則可直接讀取 SiteID、功能旗標與期限等欄位供系統使用。

### 產生授權碼（編碼 + 簽章）
對原廠端而言，流程與驗證相反：1) TokenHelper.CreateToken 生成空白 TokenData 且自動帶入 SiteID 與 TypeName；2) 外部程式碼填入實際授權內容；3) TokenHelper.EncodeToken 先將資料序列化為 BSON，再呼叫私鑰進行 RSA 簽章，最後以 Base64 將資料與簽章分別編碼並以「|」串接。由於簽章過程需私鑰，若開發者未持有私鑰即無法造出合法授權，這也是防偽的核心。作者並說明選擇「|」為分隔符的理由：不在 Base64 編碼 65 字元內，可避免與內容混淆。下一篇將進一步討論金鑰保護與簽章細節。

