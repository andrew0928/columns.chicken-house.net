# Thread Pipeline：生產線模式的多執行緒應用

## 摘要提示
- 多核心運用: 當工作具有先後依賴時，可用「生產線 Pipeline」模式取代傳統平行切割。  
- 範例場景: 將大量 JPG 先轉縮圖後再壓成單一 ZIP，縮圖與壓縮互相依賴。  
- 生產線概念: 以工廠輸送帶為靈感，把整體流程拆成多個連續階段，各由獨立執行緒負責。  
- 佇列＋事件: 透過 Queue 當輸送帶、ManualResetEvent 做跨階段同步喚醒。  
- 首版效能: 兩階段各一執行緒，執行時間 251→164 秒，CPU 利用率 27→43%。  
- 瓶頸偵測: Stage2 每次閒置約 400 ms，顯示縮圖階段產能不足。  
- 人力調整: Stage1 增至 2 條執行緒、加入 lock 保證 Thread-Safe。  
- 優化成果: 完整流程降至 98.8 秒，CPU 使用率提升至 75% 以上。  
- 均衡原則: 若過度新增執行緒、或各階段耗時差異過大，反而會拉低整體效能。  
- 成本考量: 階段切越細啟動/收尾成本越高，且 CPU 核心不足時會因排程競爭失效益。  

## 全文重點
一般多執行緒技巧多以「水平切割」為主：將大量彼此獨立的小任務交給多核心同時運算。然而實務上許多流程必須嚴格依序才能完成，單純分割無法並行。本篇以工廠生產線為比喻，提出「Thread Pipeline」垂直切割法：把整個工作流程拆成數個連續階段（Stage），各階段以專屬執行緒處理，利用佇列作為“輸送帶”傳遞半成品，並用 ManualResetEvent 同步喚醒下一階段。  
範例是「大量圖片批次縮圖後壓成 ZIP」：縮圖與壓縮皆耗 CPU，但壓縮必須等待縮圖產生檔案才能開始。若用單執行緒依序處理，四核心 CPU 僅 27% 使用率；改採兩階段 Pipeline 後，雖仍需依序，但縮圖、壓縮可以在時間軸上重疊，整體時間由 251 秒降為 164 秒，CPU 利用率升至 43%。  
進一步以 Stopwatch 量測發現第二階段長時間 Idle，說明瓶頸在縮圖階段。透過再加一條縮圖執行緒並採 lock 保護共享資源，使產能平衡，最終完成時間縮短至 98.8 秒，CPU 占用 75% 以上，效能近原始版 2.5 倍。  
作者並提醒：  
1. 階段愈多，啟動與收尾期間會有大量執行緒處於閒置，必須用足夠的「產品量」攤平成本。  
2. 若盲目增加執行緒而 CPU 核心不足，排程開銷反而拖慢整體速度。  
3. 應持續監控各階段產能，動態調整執行緒數量，使輸送帶保持流暢、不塞車。  
透過 Pipeline 模式，可在「具依賴性」的長流程中發揮多核心威力，為開發者提供不同於 ThreadPool 的另一種效能優化思路。  

## 段落重點
### 生產線模式的動機與概念
傳統多執行緒需把工作切成獨立單元，但許多流程先後相依，無法直接平行。作者借用福特汽車生產線概念，說明將完整流程拆成連續步驟，每步由專屬工人（執行緒）處理，只要整線持續運作，就能在不同階段上形成時間重疊、提高吞吐量。理論上步驟愈細，週期愈短，效率愈高，但亦伴隨啟動與同步成本。  

### 實戰案例：縮圖＋ZIP 的兩階段 Pipeline
示範需求為：批次把 JPG 轉 1600×1600 PNG 縮圖後，再把所有 PNG 壓成單一 ZIP。兩步驟皆重 CPU，且壓縮必須等縮圖完成才能動作。未用 Pipeline 時 CPU 利用低落；改以兩執行緒、一前一後方式，兩步驟時間可局部重疊，立即帶來 1.5 倍效能提升。  

### 程式結構與核心類別
工作單位以 MakeThumbPipeWorkItem 表示，內含 Stage1(縮圖) 與 Stage2(壓縮) 兩方法；PipeWorkRunner 內部準備兩條 Thread，加上 _stage1_queue/_stage2_queue 做為輸送帶，ManualResetEvent 控制喚醒。Stage1 完成後把物件推入下一佇列並 Set 事件，Stage2 執行緒被喚醒後取出物件進行壓縮。整體邏輯直覺簡單，可快速驗證 Pipeline 思路。  

### 效能分析與瓶頸偵測
透過 Stopwatch 量測 Stage2 Idle 時間，發現平均 400 ms 空檔，說明 Stage1 產能不足。Pipeline 效率受到最慢階段限制；若某步過慢，其餘階段將閒置。找出瓶頸後，必須提升該階段或降低其他階段產能，才能讓整線流暢。  

### 優化策略：增加縮圖執行緒
採用雙執行緒同時處理 Stage1，每條 Thread 從共用 Queue 取任務，利用 lock 確保執行緒安全；Stage2 維持單執行緒。調整後 Stage2 閒置大幅減少，整體時間縮至 98.8 秒，CPU 使用率 75% 以上，顯示產能達到相對平衡。作者同時提醒，若貿然切入 ThreadPool 或開太多 Thread，可能因核心不足導致排程衝突，增加反而有害。  

### 實務考量與限制
1. 階段切得愈細，啟動/收尾空轉區段愈長，需要足夠作業量才能攤平。  
2. CPU 核心數與每階段執行緒數必須對齊，否則會因競爭而降速。  
3. 階段間資料量過大亦會佔用記憶體，須定期監控 Queue 長度與資源使用。  

### 結論
Thread Pipeline 透過「垂直切割」讓具有依賴關係的流程仍可充分利用多核心，與傳統水平工作分配互補。開發者可依流程特性調整階段與執行緒數量，並藉監控動態平衡產能，達成 CPU 使用率最大化。這種思路適用於圖像處理、檔案轉換、資料 ETL 等長鏈式任務，是多執行緒設計的實用武器。