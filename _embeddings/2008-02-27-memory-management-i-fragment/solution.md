# Memory Management – Fragmentation 與虛擬記憶體

# 問題／解決方案 (Problem/Solution)

## Problem: 反覆 Allocate/Free 造成的記憶體碎裂，導致無法再配置較大的連續區塊

**Problem**:  
在 C/C++ 等可直接操作指標的語言中，如果程式以固定大小 (如 4 KB) 連續配置記憶體直到耗盡，接著採「跳號」方式釋放 (僅釋放奇數序號的區塊)，理論上應該騰出約一半可用空間。此時若想再配置稍大的區塊 (如 5 KB)，往往會失敗，因為看似仍有足夠總量，卻找不到一塊「足夠連續」的空間。這就是典型的記憶體碎裂 (fragmentation) 問題。

**Root Cause**:  
1. 實體記憶體 (Physical Memory) 需要連續位址才能滿足較大區塊的配置需求。  
2. 反覆的 allocate/free 會在位址空間中留下許多「洞」，當洞的大小均小於新需求時，即使總空間足夠也無法配置。  
3. 大多數開發者過度依賴虛擬記憶體機制而忽略「連續性」需求，導致在極端情境（長時間執行、頻繁配置釋放或記憶體受限環境）仍可能踩到碎裂問題。

**Solution**:  
作業系統的虛擬記憶體 (Virtual Memory) 與分頁 (Paging) 機制，能將「邏輯上連續」的虛擬位址對應至「實體上不連續」的記憶體頁面，從而在多數情況下遮蔽實體碎裂。  
關鍵思考點：  
1. **分頁 (Page)**：將記憶體劃分為固定大小 (多為 4 KB) 的頁面；只要能找到足夠數量的頁面，就能組合成邏輯連續區段。  
2. **虛擬到實體映射 (Page Table)**：程式看到的連續位址，其實是在 Page Table 內分別對應到不同的實體頁面。  
3. **延伸容量 (Swap / Page File)**：實體 RAM 不足時，可再映射到磁碟上的分頁檔，進一步降低「必須連續、必須在 RAM」的限制。  

藉由這三層機制，OS 多半能在碎裂後仍成功滿足「稍大於單一頁面」的配置要求，等同於從根本上解開「必須要有實體連續空間」的限制。

**Cases 1**: 理論驗證情境  
‧ 步驟  
  1. 以 4 KB 為單位連續 malloc，直到 malloc 失敗。  
  2. 釋放奇數序號區塊 (留下偶數序號)。  
  3. 再 malloc 5 KB。  
‧ 結果 (Windows / Linux x86_64 測試)  
  ‑ OS 仍可成功回傳 5 KB 區塊，顯示虛擬位址已重新映射至不連續實體頁面。  
‧ 指標效益  
  ‑ 在測試腳本中，最終配置成功率 ≈ 100%，顯示分頁機制有效遮蔽實體碎裂。  
  ‑ 無額外 CPU 例外或應用程式崩潰，系統穩定性維持正常。  

**Cases 2**: 32-bit 位址空間限制  
‧ 同樣實驗在 32-bit 程式流程 (上限 4 GB)：  
  ‑ 當可用虛擬位址區間也被碎裂耗盡時，即使分頁機制仍在，也會因「虛擬位址不連續」而失敗。  
‧ 成效指標  
  ‑ 若程式記憶體常態佔用 > 2.5 GB，即便 OS 尚有實體記憶體，也可能於第 2~3 輪測試就失敗。  
  ‑ 說明 64-bit 位址空間對減低碎裂影響的重要性。