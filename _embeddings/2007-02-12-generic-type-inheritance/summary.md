# Generic Type 的繼承…

## 摘要提示
- Generic Base Class: 透過「泛型基底類別 + 明確實型」的手法，可在衍生時消除泛型參數，使子類別成為一般型別。  
- ASP.NET Control: 在 Web 專案中，常需要為多種資料型別提供輸入元件，若硬寫各式 User Control 將導致程式碼分散且難以維護。  
- Editor<T>: 建立具泛型參數值屬性的 UserControl 基底類別，統一所有輸入元件的介面。  
- DateEditor 範例: 於衍生類別直接指定 DateTime，示範如何將 Calendar 控制項包成具型別安全的日期編輯器。  
- 型別安全: 透過泛型避免以 object 傳值，編譯期即可偵測型別錯誤，提升可靠度。  
- DRY 原則: 共同基底讓「記住上次輸入值」「統一 OnChange 事件」等邏輯只需寫一次即可重用。  
- Reflection 應用: 有了同一基底，可在執行期以反射掃描物件屬性，動態產生對應的編輯畫面並完成雙向繫結。  
- 擴充性: 未來如需支援新資料型別，只要繼承 Editor<T> 並實作 Value 屬性即可。  
- 框架化: 透過此設計可為專案打下可維護、可測試的 UI 元件基礎。  
- 心得: 作者強調此技巧雖少見於教材，但實務上能大幅降低重複程式碼並提升開發效率。

## 全文重點
作者承接先前「泛型 + Singleton」文章，再次介紹一種相對冷門但實用的技巧──以「泛型基底類別」作為繼承階層的根，並在衍生時直接填入具體型別，使衍生類別本身不再具有泛型參數。文中情境來自 ASP.NET 專案：系統需為 string、int、bool、DateTime 甚至自訂 MemberInfo、RoleInfo…等多種資料型別提供輸入介面。傳統做法是為每種型別各自撰寫 User Control，但於物件導向的角度觀之，這些元件存在大量共通行為，卻因「Value 型別各異」而難以抽出共用基底；若勉強以 object 處理，又會喪失型別安全與可讀性。

作者提出的解法是宣告  

public class Editor<T> : UserControl {  
    public abstract T Value { get; set; }  
}  

將「具有 Value 屬性且可設定的輸入元件」的概念抽象化，並以泛型參數 T 表示真正的資料型別。當要實作日期輸入器時，只需：

public class DateEditor : Editor<DateTime> {  
    public override DateTime Value { … }  
}

如此一來，DateEditor 成為一般（非泛型）類別，可在 .aspx 中以 `<chicken:DateEditor … />` 直接使用；同時享有編譯期型別檢查及 IntelliSense。

更關鍵的是：所有以 Editor<T> 為基底的元件自然擁有一致介面，後續若欲在 Value 設值處插入「記住上次輸入值」的邏輯、統一提供 OnChange 事件，或透過 Reflection 搭配 Attribute 動態產生物件編輯畫面，都能一次實作、處處套用，徹底貫徹 DRY 原則與多型精神。作者雖未附完整範例，但強調此設計在實務專案中已帶來高重用度與可維護性，並鼓勵讀者勇於嘗試，把傳統程式碼「亂配」成更優雅的架構。

## 段落重點
### 1. 簡介與動機
作者回顧自己在 Singleton 文章中使用的「泛型基底」技巧，指出雖然書籍少見，但可解決多型別共通行為抽象化的痛點。新的案例來自 ASP.NET 專案：系統需支援多種資料型別的輸入介面；若為每個型別分別寫 User Control，不僅程式碼雜亂，也無法共享邏輯，違反物件導向精神。問題關鍵在於「各輸入元件的 Value 屬性型別不同」。

### 2. Generic Base Class 設計
解決方案是宣告 Editor<T> 作為抽象泛型基底類別，僅定義一個抽象屬性 Value 以代表待編輯資料，並由現有的 UserControl 繼承。如此即可在維持編譯期型別安全的同時，為所有輸入元件建立統一介面。透過此設計，衍生類別在指定實際型別後便不再泛型，方便於 ASPX 標記中直接引用。

### 3. DateEditor 範例
作者示範以 Calendar 控制項包裝成 DateEditor 的作法，衍生時將 T 指定為 DateTime，並於 get/set 中存取 SelectedDate。使用者在頁面上僅需 `<chicken:DateEditor value="2000/01/01" />` 即可取得具有完整 IntelliSense 與型別檢查的日期輸入器。此範例證明：泛型基底可大幅簡化具體元件開發流程。

### 4. 共用基底帶來的好處
一旦所有輸入元件都繼承 Editor<T>，即可：
1) 在 Value 設值處統一寫入「記錄上次輸入」邏輯；  
2) 提供一致的 OnChange 事件；  
3) 搭配 Reflection 及 Attribute，於執行期掃描任意物件屬性，動態產生對應的 Editor 並自動完成值回寫；  
4) 往後若需擴充功能，只要改動 Editor<T> 即可全站受益。  
作者強調，沒有共通基底，以上多型與 DRY 的優勢根本無從談起。

### 5. 結語
作者坦言完整範例牽涉專案細節暫無法提供，但仍建議讀者嘗試此「泛型基底 + 消除泛型參數」的模式。它雖少見於教材，卻能在真實專案中大幅降低重複程式碼、提升型別安全與可維護性，並為日後功能擴充奠定穩固基礎；最後更以「寫起來比較爽」收尾，凸顯工程師追求優雅架構的樂趣。