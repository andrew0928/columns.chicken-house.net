# 架構面試題 #1, 線上交易的正確性

## 摘要提示
- 微服務團隊: 後端工程師的基礎實力決定微服務導入成敗。  
- 應用題面試: 以抽象化「交易正確性」情境，觀察應試者思考流程。  
- 金錢守恆: 任何交易必須滿足「錢不憑空產生也不會消失」的守恆原則。  
- Race Condition: 單機情境需使用 lock 建立 Critical Section 避免競爭。  
- SQL Transaction: 多主機環境可藉由資料庫 ACID 特性確保一致性。  
- 分散式鎖定: NoSQL 架構下透過 Redis Redlock 等機制實作 distributed lock。  
- 單元測試: 以 N×M 次並行存款驗證餘額與交易紀錄正確。  
- 職級對應: Junior→lock、Senior→DB transaction、Architect→distributed lock。  
- 技術與溝通: 關鍵字能說清原因比背標準答案更重要。  
- 面試建議: 題目可看思維深度，亦鼓勵求職者平時打底以應對不同規模挑戰。  

## 全文重點
作者以「線上交易的正確性」作為白板面試題，目的是快速評估後端工程師在並行處理與資料一致性上的掌握程度，進而判斷其是否能勝任微服務環境。題目核心在於「金錢守恆」──保證交易兩端同時完成且總額不變。  
文章先定義一個簡化的 C# 帳務抽象類別並設計多執行緒單元測試：N 個 thread、每 thread 執行 M 次、每次匯入 1 元；測試結束時，期望餘額必須等於原額度 + N×M。接著作者依系統規模提出三種解法及對應職級：  
1. 單機版（Junior）：利用語言層級 lock 或 Interlocked，將「寫入交易紀錄＋更新餘額」包成 Critical Section，防止 Race Condition。  
2. 多主機＋關聯式資料庫（Senior）：把兩步操作包在同一個 SQL Transaction 中，藉由 DBMS 的 ACID 特性自動維護一致性與回復能力。  
3. 大型分散式＋NoSQL（Architect）：當系統需水平擴充且改用無交易的儲存體（如 MongoDB）時，需先用 Redis Redlock 等快速共享媒介打造「分散式鎖」，確保同一筆帳戶更新在多節點間序列化，再分別寫入帳戶表與交易表。  
作者以程式碼、測試結果與 Docker 環境說明，證實三種方案皆能通過驗證，但效能、複雜度與適用範圍各有差異。最後提醒：沒有「最完美」架構，只有「最合適」架構。面試官應藉此觀察應試者能否隨需求與規模調整設計；求職者則應強化基礎、熟悉鎖定與交易原理，才能在雲端與微服務時代脫穎而出。

## 段落重點
### 前言 & 導讀
作者欲確認團隊後端工程師是否具備微服務所需能力，決定用白板題取代標準制式題庫，以考「思考過程」而非「死背解答」。面試題從交易正確性、演算法、資料處理到 API 設計等五大面向出發，核心在衡量應試者如何面對不同規模與技術限制時仍能找出「最合適」的實作，而非僅套用單一模板。  

### 考題: 線上交易的正確性
題目要求設計一個帳務 Engine，保證任何交易都不會因系統並行或失誤造成金額誤差。實作前先假設「ROLLBACK 與 Crash」不在討論範圍，只關注正常流程下的防護。並使用 N×M 單元測試驗證匯款結果，若期望值與實際餘額不符即失敗。  

### 解法1. 單機運作（Lock）
在單一主機內，問題是典型的 Race Condition。只要在「寫交易紀錄＋更新餘額」外層加 lock，即能將這段邏輯視為 Critical Section，確保同時間只有一條執行緒操作，避免資料被覆寫。作者展示有 lock 與無 lock 的對照，無鎖版本立刻出現 20% 金額遺失，證明鎖的重要性。關鍵字：Lock、Critical Section、Racing Condition。  

### 解法2. 搭配 SQL Transaction
當服務需橫跨 10 台以上主機並使用關聯式資料庫時，可將兩步操作包在同一個 DB Transaction。SQL Server 透過 ACID 保證一致性與原子性，使應用程式不必自行加鎖即可確保正確。作者以 Dapper 實作範例與測試結果，說明此方法簡潔但受限於單一 DB 的連線與擴充性；當資料量或服務種類持續增長，RDBMS 可能成為瓶頸，必須考慮 Partition、Sharding 或改採 NoSQL。  

### 解法3. 搭配不支援交易的儲存體（分散式鎖定）
若改用 MongoDB 這類無交易的 NoSQL，而且系統需擴充到 100+ 節點，則必須先解決「分散式鎖」問題。作者選用 Redis 作為高效共享儲存，搭配 RedLock.NET 套件，在讀取餘額前取得鎖、更新完後釋放鎖，並設定等待、重試與過期時間防止死鎖。實測 10 個 Process × 20 Thread 并行處理 20 萬筆交易仍零誤差，但效能僅 490 tps，顯示分散式鎖雖可靠卻需付出複雜度與效能代價。此段也強調作業系統課程中「Compare-and-Swap」等底層原理的重要性。  

### 總結
作者重申：面試題重點在於觀察應試者面對不同規模時如何抽象化問題並提出合適解，而非套公式。求職者若能熟悉鎖定、交易、分散式一致性等基礎，必能在面試與實務中表現出色；面試官則須量力提問，避免問得太深卻無法跟進。文章最後提供完整範例程式碼與 Docker 指令，鼓勵讀者自行實驗，也為後續「微服務 × 招募」系列鋪路。