# 該如何學好 "寫程式" #5. 善用 TRACE / ASSERT

## 摘要提示
- TRACE/ASSERT 定義: TRACE 用於輸出除錯訊息便於統一關閉；ASSERT 以布林條件在偵錯期強制警示或中止，確保狀態如預期
- 雙版本思維: 以同一套程式碼維護 DEBUG/RELEASE 兩種行為，讓錯誤在 DEBUG 模式自動浮現
- 前置條件檢查: 在函式入口用 ASSERT 保證參數不為空且結構合理，先擋掉不應存在的狀態
- 後置條件檢查: 在回傳前用 ASSERT 檢查結果落在合理範圍，避免錯誤值外洩
- BUG 與執行期錯誤分野: ASSERT 用來抓程式設計瑕疵，不是拿來取代使用者輸入驗證與錯誤處理
- 針對性部署: RELEASE 關閉 TRACE/ASSERT 供使用者；需要重現難抓問題時再用 DEBUG/ASSERT 版本
- 驗算策略: 以「安全但慢」與「最佳化但快」兩實作同算一次並比對，異常即暴露
- 與單元測試的連結: ASSERT 的精神延伸為單元測試，從被動偵測轉為主動全面回歸
- 煞車比喻: 測試與 ASSERT 像煞車，讓你能更有信心地「開更快」而不是拖慢進度
- 心態與方法論: 可靠程式碼先於漂亮架構；以 ASSERT/TRACE 養成防錯思維是邁向優秀工程師的第一步

## 全文重點
本文延續前一篇，聚焦如何用 TRACE 與 ASSERT 提升程式可靠度。作者先界定兩者角色：TRACE 是除錯訊息通道，方便集中開關與導向工具視窗或記錄檔；ASSERT 則用來在偵錯過程中強制檢查條件，條件不符即中斷或警示，目的是讓程式在不合理狀態出現時「大聲」提醒開發者。這種做法對應 Writing Solid Code 所提倡的一套程式碼維護 DEBUG/RELEASE 兩版本：DEBUG 讓錯誤自動浮出，RELEASE 則平順運作不打擾使用者。

作者以 C# 計分範例說明在三個時機使用 ASSERT：入口前置條件（參數不得為空、結構一致）、過程不變量與邏輯守門（迴圈、對應元素、推導假設）、出口後置條件（回傳分數介於 0 與滿分之間）。這些 ASSERT 像是程式碼內部的宣告與護欄，能在開發測試時第一時間攔截不該發生的狀態，讓工程師直接定位 bug。作者強調，ASSERT 是抓「程式的錯」，不是處理「執行期的錯」：例如使用者漏填或輸入格式錯誤，必須以正常的錯誤處理流程與輸入驗證來處理，而非丟 ASSERT。

部署層面上，ASSERT 必須在對的時機出現：給使用者的版本要關閉 TRACE/ASSERT 或用 RELEASE 編譯，避免在使用過程中因觸發 ASSERT 而強制終止、影響工作流程。當使用者回報難以重現的問題時，再提供包含 ASSERT 的 DEBUG 版協助定位，前提是開發期間已勤於布設 ASSERT 眼線。

進一步，作者引述 Steve Maguire 在 Excel 開發的實務：用兩種實作（安全但慢 vs. 最佳化但快）對同一資料進行「驗算」，只要結果不一致便立即暴露問題。這種策略雖有成本，但可只在 DEBUG/測試過程啟用，讓黑箱測試也能抓到需白箱知識才找得到的錯誤。作者在自己的計分程式中亦採此策略，雖不會加速撰寫功能，但能加速發現與排除錯誤。

最後，作者把 ASSERT 的精神與單元測試連結起來：兩者觀念一脈相承，只是單元測試將零散的 ASSERT 系統化為測試案例，從被動檢查變為主動回歸。以「煞車讓車開更快」的比喻說明：測試與 ASSERT 並非拖慢進度，而是提供安全網，讓工程師能更有信心地快速前進。文章結尾拋出自我檢核題，鼓勵讀者以此心態與方法論做為通往優秀工程師的第一步；下一篇將轉向如何把程式「寫漂亮」，探討結構與設計。

## 段落重點
### TRACE / ASSERT 的目的與雙版本思維
作者回顧 TRACE 與 ASSERT 的由來與用途：TRACE 為除錯訊息通道，方便集中管理；ASSERT 在條件為假時立即中止或警示，讓不合理狀態無所遁形。核心理念是以單一程式碼維護 DEBUG 與 RELEASE 兩種運行樣貌：DEBUG 期間用 ASSERT 讓錯誤自動現形；RELEASE 面向使用者則關閉這些機制，避免干擾。關鍵不在技巧細節，而是工程師是否時時以「降低 bug」為目標，並規劃對策。

### 範例：在前置與後置條件中善用 ASSERT
以計分函式示範三處 ASSERT：入口確保參數非空且子節點數一致；處理過程中維持邏輯假設；回傳前確認總分在合理範圍。這些 ASSERT 如同在程式中放置宣告與關卡，一旦偏離預期即在 DEBUG 期中止，強迫工程師面對問題。作者強調，參數錯誤若源於使用者輸入，應由錯誤處理流程處理；若 API 規格已禁止 NULL，卻收到非法值，這是設計或呼叫端的 bug，應用 ASSERT 抓出並修正。

### ASSERT 不等於錯誤處理；正確部署與釋出策略
ASSERT 的角色是內部品質保證，並非向使用者回報錯誤的 UX 機制。將包含 ASSERT 的版本交到使用者手上會導致在日常使用中斷程式、影響生產力。因此釋出時應使用 RELEASE 或關閉 ASSERT/TRACE。當遇到難以重現的問題，可再提供 DEBUG 版本或啟用 ASSERT 以協助定位；這倚賴開發時已廣設 ASSERT 監測點。

### 驗算策略：雙實作比對讓最佳化更安全
引用 Excel 的實務：在追求極致效能的同時，以「安全但慢」與「最佳化但快」兩版本對同筆資料進行計算並比對結果，任何差異皆觸發調查。此策略成本較高，適合用於關鍵子系統，且只在 DEBUG／測試時啟用以降低效能負擔。作者在自己的計分功能也同樣實作兩套演算法，以 ASSERT 搭配驗算加速尋找與解決 bug，雖不會讓寫功能更快，卻能讓除錯更快。

### 與單元測試的關聯與「煞車」比喻
ASSERT 的理念延伸為單元測試：將零散條件化檢查提煉成系統化、可重複的測試案例，從被動等待執行時觸發，走向主動執行回歸測試。作者借用 XP 中「煞車讓車開更快」的比喻：測試與 ASSERT 提供安全網，提升信心與開發速度，而非拖慢進度。文章以自我提問總結，鼓勵讀者檢視是否採納這些做法、是否因此更有信心、是否更認同單元測試。最後預告下一篇將從可靠走向「漂亮」—探討如何設計良好結構與架構。

## 資訊整理

### 知識架構圖
1. 前置知識
- 了解程式中的錯誤種類：程式缺陷（BUG）vs 執行期錯誤（使用者輸入或外部環境造成）
- 例外處理與錯誤回報的基本觀念
- 開發流程中的 DEBUG/RELEASE 版本差異與建置設定
- 基本語言/平台支援的 Trace/Assert 機制（如 .NET 的 System.Diagnostics）

2. 核心概念
- TRACE：以可集中關閉/導向的方式輸出除錯訊息，和一般訊息分流
- ASSERT：以布林條件守門，違反即在 DEBUG 中斷或警告，用來抓「程式中的 BUG」
- 雙版本維護：同一份程式碼同時能有 DEBUG（開 ASSERT/TRACE）與 RELEASE（關閉）兩種行為
- 設計契約思維：以前置條件、後置條件、內部不變式來「宣告」正確性
- 驗算/參考實作：以安全（慢）的版本對照最佳化（快）的版本，差異即顯示潛在 BUG

3. 技術依賴
- 語言與標準庫：提供 Trace/Debug/Assert（例：.NET System.Diagnostics）
- 編譯器與建置系統：支援條件式編譯與組態（DEBUG/RELEASE）
- IDE/除錯器：能接收 TRACE 輸出與遇 ASSERT 停在呼叫點
- 測試框架：延伸 ASSERT 思維到單元測試（TestCase）、自動化執行
- 記錄與監控：將 TRACE 輸出導向檔案/監控系統以便分析

4. 應用場景
- 函式/模組 API 契約防線（防止錯誤參數在內部擴散）
- 演算法最佳化時的正確性保證（安全版 vs 最佳化版比對）
- 難以重現的缺陷診斷（在 QA/客戶環境啟用 DEBUG/斷言定位）
- 黑箱測試與白箱保證的結合（測試時開啟驗算機制與 ASSERT）
- 高可靠度領域（財務計算、成績/配分、資料一致性檢查）

### 學習路徑建議
1. 入門者路徑
- 分清 BUG 與執行期錯誤，理解為何 ASSERT 只抓 BUG、不取代錯誤處理
- 寫一個小函式，加入基本的參數前置條件與回傳值後置條件的 Trace.Assert
- 在 IDE 中觀察 TRACE 輸出與遇 ASSERT 的行為；切換 DEBUG/RELEASE 比較差異
- 將使用者輸入錯誤改用例外/回傳碼/驗證訊息處理，而非 ASSERT

2. 進階者路徑
- 系統性套用「設計契約」：為重要模組列出前置/後置/不變式並以 ASSERT 表達
- 使用條件式屬性或編譯常數（如 Conditional("DEBUG")）控制 TRACE/ASSERT 生效範圍
- 為關鍵演算法寫「參考實作」，在 DEBUG 啟用驗算，比對結果差異
- 將 ASSERT 思維延伸到單元測試（編寫對應 TestCase）、加入 CI 流程

3. 實戰路徑
- 為現有專案挑選高風險區域，加上關鍵 ASSERT 與 TRACE 標記
- 建立兩種發佈管線：DEBUG（開 ASSERT/TRACE）供內部與 QA；RELEASE 給用戶
- 針對難解 BUG 制定「重現策略」：提供 DEBUG 版或特製開關以擷取 TRACE 與觸發 ASSERT
- 在最佳化工作前先完成安全版，持續以驗算守護正確性；最終以測試覆蓋與斷言收斂風險

### 關鍵要點清單
- ASSERT 用途邊界: ASSERT 用來抓程式缺陷（違反契約），不取代使用者輸入驗證或例外處理 (優先級: 高)
- TRACE 與一般輸出分離: 除錯訊息用 TRACE 集中管理、可導向/關閉，避免汙染正式輸出 (優先級: 高)
- 前置條件（Preconditions）: 以 ASSERT 檢查輸入參數合法性（如非空、結構相符）以阻斷錯誤擴散 (優先級: 高)
- 後置條件（Postconditions）: 在回傳前以 ASSERT 檢查結果範圍與關係，確保輸出正確性 (優先級: 高)
- 內部不變式: 在關鍵運算段以 ASSERT 維持資料結構與狀態一致性 (優先級: 中)
- DEBUG/RELEASE 雙版本策略: 同一份碼兩種行為；DEBUG 啟用 ASSERT/TRACE，RELEASE 關閉以免干擾用戶 (優先級: 高)
- 驗算（參考實作對照）: 用安全但較慢的實作與最佳化版本比對，差異即提示潛在 BUG (優先級: 高)
- 黑箱與白箱結合: 測試時開啟驗算與 ASSERT，讓黑箱測試也能捕捉白箱層級的錯誤 (優先級: 中)
- 斷言驅動的思維: 以「宣告」方式寫碼，先想清楚應該成立的條件再實作 (優先級: 中)
- 不將 ASSERT 暴露給用戶: 正式發佈關閉 ASSERT/TRACE，避免因斷言中止造成使用者資料/體驗損失 (優先級: 高)
- 快速定位缺陷: 在難重現情況下用 DEBUG 版與 TRACE 記錄，觸發點即為問題線索 (優先級: 高)
- 與單元測試的關聯: ASSERT 的觀念延伸為 TestCase；主動執行測試以系統化保障正確性 (優先級: 中)
- 效能與正確性的取捨: 在開發/測試階段可接受較慢以換取更高偵錯能力，上線再關閉 (優先級: 中)
- API 契約文件化: 將 ASSERT 所代表的契約同步寫入文件，約束呼叫者行為 (優先級: 中)
- 工具鏈整合: 使用條件式編譯、IDE 除錯視窗、日志/監控導向，形成可操作的工程流程 (優先級: 中)