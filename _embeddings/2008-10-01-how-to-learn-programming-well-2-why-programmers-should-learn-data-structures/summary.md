# 該如何學好「寫程式」#2：為什麼 Programmer 該學資料結構？

## 摘要提示
- 內功心法: 程式設計的核心能力在於正確運用資料結構與演算法，而不只是熟悉語言語法。
- 三項檢核: 排序、搜尋、大圖問題是衡量程式基礎能力的經典測試題。
- List 盲點: 多數人直覺使用 List 儲存大量資料，卻忽略其 O(n) 搜尋成本。
- Dictionary 優缺: HashTable 架構帶來 O(1) 精準查詢，但無法處理範圍搜尋與排序。
- 時間複雜度: 透過 O(n)、O(log n) 等級別的比較，量化不同演算法的效能差距。
- SortedList 解法: 將資料索引化並維持排序，可同時兼顧快速查詢與範圍檢索。
- MSDN 助攻: 官方文件標示的 Time Complexity 是選擇 .NET Collection 的重要依據。
- 百萬 vs. 億級: 當資料量擴增 100 倍時，演算法差異將放大到數千倍效能落差。
- 基礎課本: 大學資料結構、作業系統所教內容，在職場開發仍具決定性影響。
- 持續精進: 熟讀範例並動手實作，方能真正掌握「好程式」與「快程式」的核心思維。

## 全文重點
作者延續前篇談「程式內功」，指出要成為合格的程式設計師，光熟悉語言與框架並不足夠，真正的關鍵在於「資料結構與演算法」的運用能力。文中以「百萬筆通訊錄搜尋」做示範，首先展示多數人慣用的 `List<ContactData>` 加迴圈搜尋，雖寫法簡潔但搜尋時間為 O(n)，資料量放大後效能將災難性下降。接著改用 `Dictionary` 加快精確比對，但因 HashTable 先天限制，重複鍵值、範圍查詢與排序皆無法滿足需求。作者透過 MSDN 文件中標註的 Time Complexity，導出 `SortedList` 或 `SortedDictionary` 才是滿足「快速定位＋排序」的適用結構；在百萬筆資料下，`List` 搜尋需 3,131,861 ticks，而 `SortedList` 只要 39,294 ticks，差距達 80 倍；若資料成長至一億筆，理論差距更可達 6,000 倍。文章並重申求學時習得的 Big-O、Binary Search、HashTable 等基礎觀念，正是日後解決實務瓶頸的關鍵。最後鼓勵讀者多翻課本、查 MSDN、親手寫程式，透過演算法與資料結構的正確選擇，才能打造穩定、高效且具擴充性的程式碼。

## 段落重點
### 寫程式的「內功」與工具運用
作者先指出程式設計不只是「會用工具」，而是要能把規格快速且穩定地寫成程式碼；真正的主角是資料結構與演算法，這才是運用語言工具的內功。

### 基礎能力三問：排序、搜尋、路徑
提出三個情境測試：撲克牌排序、百萬筆通訊錄搜尋以及高速公路路徑規畫，用以檢視程式邏輯與資料結構應用的熟練度。

### List 的直覺實作與效能瓶頸
示範多數人採用 `List` 加 Lambda `Find` 搜尋的寫法，雖易寫但在百萬資料時搜尋需數秒、記憶體近 300MB，揭示 O(n) 搜尋的先天限制。

### Dictionary 的改良與侷限
再以 `Dictionary` 增設姓名索引，精確查詢瞬間完成，但建表耗時與記憶體增加，同時無法處理模糊查詢與排序，說明 HashTable 的 unique key 與無序特性。

### SortedList 與正確資料結構選擇
引用 MSDN Time Complexity 資訊，選擇 `SortedList` 同時滿足排序與 O(log n) Binary Search；比較顯示百萬筆資料速度提升 80 倍，並推算億級資料仍能保持可接受效能。

### 時間複雜度觀念與實務衝擊
透過 O(n) 對 O(log n) 的數學推導，展現資料量翻百倍後效能差距可達數千倍，強調演算法選擇遠勝於零碎最佳化。

### 結語與學習建議
作者總結：學校課本中的資料結構、作業系統仍是職場解題基石；鼓勵讀者閱讀 MSDN、回頭翻課本並動手實作，以紮實基礎突破程式瓶頸，並預告後續多執行緒與其他主題文章。