---
source_file: "_posts/2023/2023-10-01-reorder.md"
generated_date: "2025-01-03 17:00:00 +0800"
version: "1.1"
tools:
  - github_copilot
  - claude_sonnet_3_5
model: "claude-3-5-sonnet-20241022"
---

# 架構面試題 #5: Re-Order Messages - 生成內容

## Metadata

### 原始 Metadata
```yaml
layout: post
title: "架構面試題 #5: Re-Order Messages"
categories:
- "系列文章: 架構師的修練"
tags: ["系列文章", "架構師的修練", "架構師觀點", "刻意練習", "抽象化"]
published: true
comments_disqus: false
comments_facebook: false
comments_gitalk: true
redirect_from:
logo: /wp-content/images/2023-10-01-reorder/2023-10-21-22-13-16.png
```

### 自動識別關鍵字
keywords:
  primary:
    - Message Reordering
    - 分散式系統
    - 緩衝區設計
    - 訊息排序
    - 系統架構
    - Buffer
  secondary:
    - TCP
    - UDP
    - Queue
    - SLO
    - DevOps
    - 演算法
    - 容錯設計
    - 系統監控
    - POC
    - SortedSet

### 技術堆疊分析
tech_stack:
  languages:
    - C#
  frameworks:
    - .NET
  tools:
    - Visual Studio
    - Git
  platforms:
    - Windows
  concepts:
    - Distributed Systems
    - Message Queue
    - Buffer Management
    - State Machine
    - Algorithm Design
    - System Monitoring

### 參考資源
references:
  internal_links:
    - /2018/06/10/microservice10-throttle/
    - /2022/05/29/datetime-mock/
    - /2019/08/30/scheduling-practices/
  external_links:
    - https://www.geeksforgeeks.org/event-ordering-in-distributed-system/
    - https://www.geeksforgeeks.org/causal-ordering-of-messages-in-distributed-system/
    - https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE
    - https://redis.io/commands/getset/
    - https://github.com/andrew0928/Andrew.ReOrderDemo
  mentioned_tools:
    - TCP
    - UDP
    - Message Queue
    - Redis
    - SortedSet
    - Excel
    - CSV

### 內容特性
content_metrics:
  word_count: 18000
  reading_time: "60 分鐘"
  difficulty_level: "進階"
  content_type: "教學"

## 摘要 (Summaries)

### 文章摘要 (Article Summary)

作者透過一個實際的架構面試題來深入探討分散式系統中訊息重新排序的問題。文章從一個常見的場景出發：如何在大量 API Request 的情況下保證訊息按照順序處理。作者首先分析了問題的本質，指出這不是一個簡單的排序問題，而是需要在串流環境下處理亂序訊息的挑戰。文章詳細介紹了訊息排序的基本觀念，包括訊息標示順序的方法、緩衝時間和空間的考量等。作者設計了一個完整的模型來解決這個問題，包含 Command Source、ReOrder Buffer、Command Handler 和監控機制四個核心組件。透過大量的單元測試和模擬實驗，作者展示了不同 Buffer Size 對系統性能的影響，並提供了詳細的 Metrics 分析。整篇文章不僅提供了技術解決方案，更重要的是展示了架構師如何透過建立模型、設計實驗來驗證解決方案的可行性，體現了 DevOps 中開發與維運一體化的思維。

### 關鍵要點 (Key Points)

- 訊息重新排序是分散式系統中的常見問題，需要系統性的解決方案
- 解決方案的核心是設計合適的緩衝區機制來暫存亂序訊息
- Buffer Size 的選擇需要在延遲時間和訊息完整性之間取得平衡
- 系統設計必須考慮監控機制，通過 Metrics 來評估和優化性能
- POC 和模擬測試是驗證架構設計可行性的重要方法
- 架構師需要具備建立模型和驗證解決方案的能力
- DevOps 思維要求在設計階段就考慮維運需求

### 練習前的思考: 我需要了解這些機制嗎？

作者在開始技術討論前，先提出了一個重要的哲學問題：是否需要重新發明輪子。作者認為雖然不需要重新發明每個輪子，但要具備重新建立必要輪子的能力。這種能力對架構師角色特別重要，因為架構師經常需要面對複雜且需要高度整合的系統。作者建議的最佳平衡點是做好必要的練習，一方面投入不算多，另一方面可以得到保障。作者強調需要有能力了解原理但不用真的去開發，然後才能判斷要不要自己開發。這種思維對於判斷技術選擇時特別有幫助，能夠立刻做出技術決策。作者指出這些練習雖然不大花時間，但將來在判斷技術選擇時就能發揮關鍵作用。

### 1. 訊息排序的基本觀念

作者詳細解釋了訊息重新排序的核心概念，指出這與一般的排序不同，因為無法等到資料收齊再一次性排序。系統必須一個一個收到不一定正確順序的訊息，並且盡快按順序處理。作者提出了處理的基本流程：如果收到的訊息順序正確就馬上處理，如果不對就暫時存放等待補齊，或是放棄某個訊息繼續往下。這個過程需要在等待時間和放棄訊息數量之間取捨。作者參考了 TCP 處理封包順序的機制，提出了三個關鍵設計要點：訊息必須能標示順序、必須界定處理範圍的緩衝時間、必須界定處理範圍的緩衝空間。作者建立了一個包含四個組件的處理模型：訊息來源、緩衝機制、訊息處理器和監控體系，並設計了完整的介面規格來實現這個系統。

### 2. 環境模擬

作者設計了完整的模擬環境來測試訊息重新排序的機制。模擬環境包含網路傳輸延遲的隨機模擬，透過調整 period 和 noise 參數來控制訊息產生的週期和隨機延遲範圍。作者也模擬了網路傳輸丟失請求的情況，設定一定機率的 Command 會憑空消失。整個模擬系統使用 DateTime Mock 技術來控制時間軸，避免真實時間對測試的影響。作者特別設計了監控機制，使用 CSV 格式輸出 Metrics 數據，包括每秒的 Push、Send、Drop、Skip 等統計指標。這種監控設計讓開發者能夠在 POC 階段就思考需要觀察的指標，並模擬真實系統上線後的 dashboard 效果。作者強調這種做法能夠把整套系統的設計思路控制在 500 行程式碼內，在單機就能重複模擬執行的複雜度內，大大降低了驗證成本。

### 3. Reordering Buffer 的設計

作者詳細介紹了 ReOrder Buffer 的核心設計，包括介面定義、資料結構、核心邏輯和監控機制。Buffer 使用 SortedSet 來自動排序和去重複，並透過 _current_next_index 來追蹤下一個預期的 Command Position。核心的 Push 方法實現了完整的訊息處理邏輯：直接丟棄過期訊息、立即處理順序正確的訊息、暫存需要等待的訊息、以及當 Buffer 滿時的處理策略。作者設計了六個監控指標來追蹤系統運作狀況，包括 push、send、drop、skip 的計數以及 buffer 使用量和延遲時間。整個設計採用事件驅動的架構，透過三個事件（CommandIsReadyToSend、CommandWasDroped、CommandWasSkipped）來通知外部系統。作者特別強調了 Adapter 模式的使用，將核心邏輯與事件機制分離，提高了程式碼的可維護性和可測試性。

### 4. 模擬與監控

作者通過大量的模擬測試來驗證設計的可行性和優化參數設定。測試包括不同的網路環境（調整 command_noise）和不同的 Buffer Size 設定。作者發現 Buffer Size 並非越大越好，過大的 Buffer 在訊息丟失的情況下會導致不必要的延遲。透過系統性的實驗，作者展示了 Buffer Size 從 10 降到 5 時延遲時間的改善，以及繼續降低 Buffer Size 時 Drop Rate 的上升。作者設計了完整的監控 dashboard，能夠實時觀察系統的運作狀況，包括延遲分佈、Buffer 使用率等關鍵指標。這些監控數據不僅用於性能優化，也為制定 SLO（Service Level Objective）提供了基礎。作者特別強調了監控在 POC 階段的重要性，認為能夠在開發初期就建立完整的監控體系對架構師來說是必要的能力。

### 5, 總結

作者在總結中將整個訊息重新排序的實作過程與 DevOps 理念結合，強調架構師需要具備從概念建立模型到驗證可行性的完整能力。作者指出架構師面對的通常都是困難的問題，如果提出錯誤的方案需要半年後才能驗證，那架構師的存在意義就消失了。因此，發展出能夠早期驗證解決方案可行性的流程至關重要。這個流程包括從概念建立可評估的模型，將其變成可執行的 MVP，並且同時驗證開發和維運等各個層面。作者強調現代的架構師不應該僅止於開發的規劃設計，維運的設計也應該包含在內。文章的前半部分（概念和實作）代表 Dev 的部分，後半部分（模擬和監控）則代表 Ops 的部分，綜合驗證後才真正交由相關團隊實際開發，這體現了完整的 DevOps 思維。

## 問答集 (Q&A Pairs)

### Q1: 為什麼需要訊息重新排序機制？
Q: 在什麼情況下需要實作訊息重新排序的機制？這個問題的本質是什麼？
A: 當系統透過 API 短時間收到大量 Request 時，由於網路傳輸的不確定性，訊息可能不會按照發送順序到達。這與一般排序不同，因為無法等資料收齊再排序，必須一個一個處理不一定正確順序的訊息。核心挑戰是在等待時間和訊息完整性之間取得平衡。

### Q2: 如何設計訊息的順序標示機制？
Q: 要實現訊息重新排序，訊息本身需要包含哪些資訊？
A: 訊息必須要能標示順序，包括：1) 能判斷任意兩個訊息的先後順序，2) 能判斷中間是否有遺漏的訊息。常見做法是使用來源標記的 timestamp 來判斷先後，或使用來源標記的 sequence number 來判斷是否掉號碼。

### Q3: Buffer Size 的大小如何選擇？
Q: ReOrder Buffer 的大小設定有什麼原則？是否越大越好？
A: Buffer Size 並非越大越好。過大的 Buffer 在訊息丟失時會導致不必要的延遲，因為系統會持續等待永遠不會到達的訊息。過小的 Buffer 則會增加 Drop Rate。需要透過實際測試找出在特定網路環境下，能夠平衡延遲時間和訊息完整性的最佳值。

### Q4: 如何處理訊息丟失的情況？
Q: 當某個訊息在網路傳輸中完全丟失時，系統應該如何應對？
A: 系統需要設定緩衝時間和空間的限制。當 Buffer 滿了還沒收到預期的訊息，就必須決定是否放棄等待（SKIP）。策略是優先保留已收到的訊息，放棄可能永遠不會到達的訊息，避免連鎖效應導致更多訊息被延遲。

### Q5: 監控機制應該追蹤哪些指標？
Q: 在訊息重新排序系統中，需要監控哪些關鍵指標來評估系統性能？
A: 主要監控指標包括：Push（每秒收到的訊息數）、Send（每秒成功處理的訊息數）、Drop（被丟棄的訊息數）、Skip（被跳過的訊息數）、Buffer Usage（緩衝區使用量）、以及 Buffer Delay（因緩衝處理造成的延遲時間）。這些指標能夠幫助優化系統性能和制定 SLO。

### Q6: 如何驗證訊息重新排序設計的可行性？
Q: 架構師應該如何驗證訊息重新排序解決方案在上線前的可行性？
A: 透過建立模擬環境和 POC 來驗證。包括：1) 設計完整的單元測試案例，2) 建立網路延遲和丟失的模擬環境，3) 設計監控和 Metrics 收集機制，4) 透過大量模擬測試來調整參數，5) 分析不同條件下的系統表現。這種方法能在投入大量資源前就確認設計的正確性。

### Q7: 為什麼需要事件驅動的設計？
Q: 在 ReOrder Buffer 的設計中，為什麼要使用事件機制而不是直接的方法調用？
A: 事件驅動設計提供了更好的解耦和擴展性。透過 CommandIsReadyToSend、CommandWasDroped、CommandWasSkipped 三個事件，外部系統可以靈活地處理不同的情況，例如將處理過的訊息轉發到支援 FIFO 的 Message Queue，或觸發相應的補償機制。

### Q8: 這種設計如何體現 DevOps 的思維？
Q: 訊息重新排序的設計過程如何展現開發與維運一體化的概念？
A: 設計過程同時考慮了 Dev 和 Ops 兩個面向：Dev 部分包括演算法設計、介面定義、單元測試；Ops 部分包括監控指標設計、性能調優、故障處理機制。架構師需要在設計階段就考慮維運需求，確保系統不僅能正確運作，還能被有效監控和維護。

## 解決方案 (Solutions)

### P1: 如何設計訊息重新排序的核心演算法
Problem: 在分散式系統中，訊息可能因為網路延遲而亂序到達，需要重新排序後再處理
Root Cause: 網路傳輸的不確定性導致訊息無法按照發送順序到達，而系統又必須保證處理順序的正確性
Solution:
- 為每個訊息標記連續的 sequence number 來標示順序
- 使用 SortedSet 作為緩衝區來暫存亂序訊息
- 實作三種處理策略：直接轉發（PASSTHRU）、緩衝處理（BUFFERED）、丟棄處理（DROP/SKIP）
- 設定 _current_next_index 來追蹤下一個預期的訊息編號
- 當收到預期的訊息時，連同緩衝區中連續的後續訊息一起處理

Example:
```csharp
if (data.Position == this._current_next_index)
{
    this.Send(data, CommandProcessReasonEnum.SEND_PASSTHRU);
    this._current_next_index = data.Position + 1;
    
    // 處理緩衝區中連續的訊息
    while (this._buffer.Count > 0 && this._current_next_index == this._buffer.Min.Position)
    {
        var m = this._buffer.Min;
        this._buffer.Remove(m);
        this.Send(m, CommandProcessReasonEnum.SEND_BUFFERED);
        this._current_next_index++;
    }
}
```

### P2: 如何處理緩衝區滿載的情況
Problem: 當緩衝區空間不足時，系統必須決定是繼續等待遺失的訊息還是放棄等待
Root Cause: 網路品質不穩定導致某些訊息可能永遠不會到達，而無限等待會耗盡緩衝區資源
Solution:
- 設定緩衝區大小限制來控制資源使用
- 優先保留已收到的訊息，放棄等待可能永遠不會到達的訊息
- 實作強制跳過機制（SKIP）來避免系統卡死
- 透過監控指標來平衡 Drop Rate 和延遲時間
- 考慮實作基於時間的超時機制

Example:
```csharp
if (this._buffer.Count > this._buffer_size && this._current_next_index < this._buffer.Min.Position)
{
    // 強制跳過等待中的訊息
    this.Skip(this._current_next_index, CommandProcessReasonEnum.SKIP_BUFFERFULL);
    this._current_next_index++;
}
```

### P3: 如何建立有效的監控和指標系統
Problem: 需要即時監控系統運作狀況，但缺乏適當的指標和監控機制
Root Cause: 沒有在設計階段就考慮監控需求，導致系統上線後無法有效觀察和調優
Solution:
- 設計六個核心指標：Push、Send、Drop、Skip、Buffer Usage、Delay
- 實作 ResetMetrics 方法來提供定期的指標快照
- 使用 CSV 格式輸出指標數據，便於後續分析
- 設計每秒觸發的監控事件來收集即時數據
- 建立視覺化的 dashboard 來觀察系統趨勢

Example:
```csharp
DateTimeUtil.Instance.RaiseSecondPassEvent += (sender, args) =>
{
    var metrics = (ro as ReOrderBuffer).ResetMetrics();
    double avg_latency = metrics.send > 0 ? metrics.delay / metrics.send : 0;
    Console.Error.WriteLine($"{_log_sequence},{metrics.push},{metrics.send},{metrics.drop},{metrics.skip},{metrics.buffer_max},{avg_latency}");
};
```

### P4: 如何建立模擬測試環境
Problem: 需要驗證設計在各種網路條件下的可行性，但無法在真實環境中重複測試
Root Cause: 真實網路環境的不可控性和測試成本過高，需要可重複的模擬環境
Solution:
- 使用 DateTime Mock 來控制時間軸，避免真實時間的影響
- 模擬網路延遲的隨機分佈（command_noise 參數）
- 模擬訊息丟失的情況（lost_rate 參數）
- 設計參數化的測試框架，便於批次執行不同條件的測試
- 建立完整的測試案例覆蓋各種邊界條件

Example:
```csharp
// 模擬網路延遲
var order = new OrderedCommand()
{
    Position = i,
    Origin = start + cmd_period * i,
    OccurAt = start + cmd_period * i + TimeSpan.FromMilliseconds(rnd.Next(cmd_noise)),
    Message = $"CMD-{i:#00000}"
};
```

### P5: 如何最佳化 Buffer Size 的選擇
Problem: Buffer Size 的選擇需要在延遲時間和訊息完整性之間找到最佳平衡點
Root Cause: 不同的網路環境和業務需求對 Buffer Size 有不同的最佳值，需要系統性的調優方法
Solution:
- 透過大量模擬測試來找出不同條件下的最佳值
- 監控 Drop Rate 和 Max Delay 兩個關鍵指標
- 建立 Buffer Size 與性能指標的對應關係表
- 考慮業務的 SLO 要求來設定可接受的範圍
- 實作動態調整機制來適應不同的負載情況

Example:
測試結果顯示在 command_noise = 500 的環境下：
- Buffer Size = 10: Drop Rate = 0%, Max Delay = 1237ms
- Buffer Size = 5: Drop Rate = 0%, Max Delay = 777ms  
- Buffer Size = 3: Drop Rate = 0.2%, Max Delay = 636ms
最佳選擇是 Buffer Size = 5，既保證了完整性又最小化了延遲。

## 版本異動紀錄

### v1.1 (2025-01-03)
- 修正摘要格式，改用第三人稱敘述，加入生成工具資訊
- 完善關鍵字分類和技術堆疊分析
- 優化問答對和解決方案的結構

### v1.0 (2025-01-03)
- 初始版本
