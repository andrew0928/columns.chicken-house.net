# [設計案例] 授權碼 如何實作? #3 ─ 數位簽章

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 為什麼不能自己發明「土炮」加密，而應採用公開演算法配合私有金鑰?
公開演算法經過長期的密碼學研究與社群審視，可確保其安全性；真正的機密只剩「金鑰」。  
若把安全性建立在「別人不知道我怎麼寫程式」之上，一旦程式碼需要開放（團隊 Review、Open Source…）安全性就瞬間瓦解。  
因此「公開演算法 + 只有自己才擁有的金鑰」才是可靠做法。

## Q: 軟體如何確認某份授權碼確實由原廠發出，而不是第三者偽造?
將序列化後的授權資料先做雜湊 (Hash)，再使用原廠私鑰將 Hash 加密形成「數位簽章」，並與原始資料一起發送。  
收到端用原廠公開金鑰解開簽章取得 Hash'，同時對原始資料再次計算 Hash。若兩者一致，即可確定  
1) 資料確實出自持有私鑰的原廠，2) 資料在傳輸過程中未被竄改。

## Q: 數位簽章的基本原理是什麼?
1. 先對原始資料計算雜湊值。  
2. 用私鑰加密該雜湊值得到「簽章」。  
3. 發送者將資料與簽章一併提供。  
4. 驗證者重新計算資料雜湊，同時用公開金鑰解密簽章取回雜湊'。兩者相同即驗證成功。

## Q: 對稱式與非對稱式加密有何差別？為何本文選擇 RSA?
‧ 對稱式：加解密使用同一把金鑰，適合雙方已安全交換好金鑰的情境。  
‧ 非對稱式：有一對公鑰/私鑰；私鑰保密，公鑰可公開。RSA 就是典型非對稱式演算法。  
授權碼驗簽需要「任何人都能驗證，但只有原廠能簽名」，因此必須使用非對稱式的 RSA。

## Q: 在不安全的通道中，要與單一對象進行安全通訊可以怎麼做?
讓發送端用「自己的私鑰 + 對方的公鑰」加密訊息；  
接收端再用「自己的私鑰 + 對方的公鑰」解密。整個過程中外露的只有密文及雙方公鑰，私鑰始終不離身，即可防止旁人竊聽或冒充。

## Q: 為什麼私鑰洩漏就代表系統被全面破解?
擁有私鑰者即可：  
1) 代替原廠簽發任何授權碼或文件；  
2) 解開本應僅供原廠查看的加密資料。  
使用者無從分辨真偽，整個信任鏈立即失效，所以私鑰必須受到嚴格保護。

## Q: 直接把金鑰存成 XML 檔有什麼風險？正式環境應如何管理金鑰?
XML 檔只是純文字，若存放目錄被複製或入侵者取得檔案，私鑰即告外流。  
正式環境應使用作業系統提供的 Key Container、HSM 或透過 CA 進行受控的金鑰產生與散佈，以確保私鑰永不落地。

## Q: 在 .NET 中要如何產生與驗證 RSA 數位簽章?
1. 透過 `RSACryptoServiceProvider` 匯入含私鑰的 XML (`FromXmlString`)。  
2. 使用 `SignData(原始資料, HashAlgorithm)` 取得簽章。  
3. 驗證端匯入僅含公鑰的 XML，呼叫 `VerifyData(原始資料, HashAlgorithm, 簽章)`，回傳 `true` 即驗證成功。

## Q: 範例程式的 `TokenHelper.Init` 做了什麼事?
‧ 讀取各站台的公鑰/私鑰 XML，建立 `Dictionary<string, RSACryptoServiceProvider>` 做快取。  
‧ 將目前網站的 SiteID 與私鑰載入，以便後續簽章。  
‧ 將其他站台的公鑰載入，以便後續驗章。  
(實務建議改用 Key Container 管理金鑰)

## Q: ASP.NET MVC5 如何在啟動時利用授權碼與數位簽章保護網站?
1. 在 `appsettings.json` 加入 `License` 區段：SiteID、私鑰、授權 Token 及各站台公鑰。  
2. 在 `Startup.Configure()` 先呼叫 `TokenHelper.Init(...)`，再以 `TokenHelper.DecodeToken()` 驗證授權。  
3. 驗證不通過即丟出 `TokenNotSecureException` / `TokenNotValidateException`，網站啟動立即中斷，防止未授權或被竄改的部署。