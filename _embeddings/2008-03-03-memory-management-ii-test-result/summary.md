# Memory Management (II) ‑ Test Result

## 摘要提示
- 記憶體碎片: 實驗證實 32 bit 程式在位址空間被碎片化後，可能在仍有可用 RAM 的情況下配置失敗。  
- 位址空間大小: 64 bit 原生程式幾乎不會因虛擬位址用盡而失敗，除非總配置量逼近實體+分頁檔容量。  
- WOW64 限制: 32 bit 程式即使跑在 64 bit OS 上，預設仍只握有 2 GB 位址空間。  
- LARGEADDRESSAWARE: 重新編譯並加上此旗標可讓 32 bit 應用在 64 bit OS 取得 4 GB 位址空間。  
- 測試腳本: 以 C 實作，先大量配置 64 MB 區塊再釋放其中一半，最後嘗試配置 72 MB 區塊驗證碎片化影響。  
- 結果對照: x86／x86+LAA 均只能再配置 2 個 72 MB 區塊；x64 原生程式則可配置 27 個。  
- OS 無法 Defrag: 對能直接操作 pointer 的語言，作業系統無法在執行期間重新安排記憶體位置。  
- 虛擬 vs 實體: 問題核心不在實體記憶體多寡，而在「可定址空間是否被耗盡」。  
- 伺服器風險: 長時間執行的 32 bit 服務程式較易撞到此瓶頸，即便沒有 Memory Leak。  
- 後續主題: 下一篇將討論 .NET / Java 的 GC 機制對此問題的影響。

## 全文重點
作者為重現上一篇討論的「記憶體碎片導致配置失敗」議題，於 Windows 2003 x64 上撰寫 C 測試程式，分別在三種環境執行︰(1) 純 x86 編譯、(2) x86 + /LARGEADDRESSAWARE、(3) 原生 x64 編譯。程式流程是先盡量配置 64 MB 區塊，再釋放其中一半，最後嘗試配置較大的 72 MB 區塊。測試顯示︰在預設 x86 情況下，可定址空間僅 2 GB，因此只成功配置兩塊 72 MB；加上 /LAA 後雖擴充到 4 GB，但碎片仍使可用連續位址不足，結果仍僅兩塊；原生 x64 因理論位址空間高達 8 TB，遠大於 6 GB 的實體+分頁容量，故可一次成功配置 27 塊 72 MB 區塊。由此證明影響關鍵是「連續虛擬位址是否已被破碎佔滿」，而非剩餘實體記憶體量。文章進一步解釋 /3GB 與 /LAA 的來源、OS 為何無法替 C/C++ 程式進行記憶體重組，以及提供完整測試原始碼供讀者在其他作業系統重試。作者提醒，現代伺服器記憶體動輒超過 4 GB，長時運行的 32 bit 服務在沒有記憶體洩漏的情況下仍可能遭遇 Out Of Memory，並預告下一篇將探討 GC 語言是否能避免此困境。

## 段落重點
### 引言與動機
作者回顧先前理論討論後，決定在現代硬體與作業系統上實測記憶體碎片問題，於是重拾久未使用的 C/C++ 撰寫測試程式，並順勢研究 x64 編譯流程。測試鎖定 Windows 平台，原因是人力有限且欲先驗證問題的核心：可用位址空間是否被耗盡。

### 測試環境與方法
共比較三組環境：Win32 x86、Win32 x86+LAA、Win64 x64。機器裝有 2 GB RAM 與 4 GB 分頁檔。程式先連續配置 64 MB 區塊，形成碎片，再釋放間隔區塊，最後嘗試配置更大的 72 MB 區塊以檢測是否因碎片而失敗。原始碼與專案檔亦一併公開。

### 實驗結果整理
以螢幕截圖與表格呈現：x86 只能使用 2 GB 位址空間，最終僅能配置兩塊 72 MB；x86+LAA 雖可達 4 GB，但因碎片分散，結果同樣僅兩塊；x64 原生程式則順利配置 27 塊。整理出「執行環境 / Build 選項 / 理論位址空間 / 成功配置數量」四欄，直觀展示差異。

### 結果分析與討論
碎片化確實造成 32 bit 程式在有剩餘實體記憶體時仍配置失敗；64 bit 因位址空間極大，短期內幾乎不會遇到此瓶頸。作者提醒不要誤將此現象與 Memory Leak 混淆，它發生於記憶體被正確釋放但位址仍零散。若程式需求逼近總可用記憶體，64 bit 最終亦可能受影響。

### /LARGEADDRESSAWARE 與 /3GB 說明
32 bit Windows 將 4 GB 位址空間硬分為 2 GB Kernel 與 2 GB User；/3GB 開關可調為 1 GB:3 GB，而程式端則需編譯時加入 /LAA 才能識別高於 2 GB 的位址。即使在 x64 OS 執行，未加 /LAA 的 32 bit 應用仍只能用 2 GB。

### OS 為何無法 Defrag 記憶體
C/C++ 允許程式直接持有 pointer，若 OS 任意搬動已配置區塊，所有 pointer 立即失效，因此作業系統無法在程式執行期間替這類語言做記憶體重組。高階語言若採間接參照或 GC，則可透過移動與更新參考來實作 Compact，但 C/C++ 無此機制。

### 測試程式碼與延伸實驗
最後提供修改後的 C 原始碼：將區塊大小調至 64 MB 與 72 MB 以縮短執行時間並減少輸出。作者歡迎讀者移植到 Linux 或其他作業系統測試，並預告下篇文章將分析 .NET／Java 的 GC 在此議題上的表現。