# [設計案例] 生命遊戲 #5, 中場休息

## 摘要提示
- 系列目標: 將「生命遊戲」擴充成可長期運作、具時間驅動的 Matrix 架構。
- 效能與多執行緒: 為了讓大量生物同時存活與互動，必須先解決效能與執行緒問題。
- 時間驅動模型: 放棄回合制，改用連續時間機制以提升世界的擬真度。
- 抽象化介面: 透過介面與多型，定義生物與世界、以及生物彼此間的互動規格。
- 動態載入: 新生命型態需在不停止 GameHost 的情況下，以 Assembly hot-load 方式加入。
- 參與機制: 期待讀者撰寫各自的「生物」並放入同一世界中彼此競逐。
- 演化概念: 世界會自動生成資源（如草），生物需掠食並演化才能延續族群。
- 程式重構: 重新整理並統一命名，為後續教學避免 #1~#4 版本的雜亂。
- 後續藍圖: 完成基礎後，將公布競賽規則並觀察不同「品種」優勝劣敗。
- 檔案下載: 提供重構後的程式碼（BLOG #5.zip）供讀者研究與實驗。

## 全文重點
本文是「生命遊戲」系列第五篇，作者在正式深化技術細節之前，先交代整體藍圖與階段目標。最終他想把目前僅能回合運算的簡易 Game of Life，打造為一個可長期運行的虛擬世界 (Matrix)。此世界必須以時間驅動而非回合制運作，並能同時容納大量生物，故效能與多執行緒處理為首要課題。接下來作者將透過抽象化介面與多型，規範生物與世界、以及生物間互動的 API，讓不同開發者能各自撰寫各式生命體並置入同一宿主程式 (GameHost)。為支援「世界不中斷」的更新需求，GameHost 還需具備動態載入新 Assembly 的能力，使新生命型別能即時注入並開始活動。作者期望最終的玩法是：世界會隨機長出資源（如草），開發者設計的生物（例如羊）必須覓食、生存、繁衍，經過長時間執行後，看看誰的演算法能讓族群留存下來。因前四篇程式日益凌亂，作者已先行重構程式碼並統一命名；功能雖與 #4 相同，但架構更乾淨，方便後續示範物件導向技巧。文末亦附上最新程式碼下載，並預告下一篇將進入「抽象化 / 多型」的核心主題。

## 段落重點
### 中場定位與未來願景
作者說明前四篇僅屬暖身，真正目標是把 Game of Life 進化成能長時間運轉的 Matrix。此世界需模擬真實時間流動，而非簡單回合切換，並能承載大量自治生物，是接下來所有設計的基底。

### 技術挑戰：效能、多執行緒與時間驅動
為支援「持續在線」的世界，程式必須從效能最優化與執行緒管理著手；同時改為時間驅動模型，使世界狀態連續演進，擺脫傳統一步一格的回合侷限。

### 抽象化、多型與生命接口
讓社群共同開發生物的前提，是先訂出生命體的抽象化介面，以及其與世界/其他生物互動的契約。完成接口後，開發者可用繼承與多型衍生多樣生命型態，放到同一宿主中競逐。

### 動態載入與不中斷擴充
現實世界不會因新生命誕生而「重開機」，GameHost 亦須能熱插拔新 Assembly。作者將於後續文章示範如何在不終止主程式的情況下，動態載入並啟動新生命類別。

### 社群競技與演化構想
作者計畫設定土地資源生成規則，例如草的生長機率，並邀請讀者將自己的「羊」放入世界。在資源有限、競爭殘酷的環境下，觀察哪些演算法的生物能繁衍至最後，形成一場演化競賽。

### 程式碼重構與下載
因早期範例程式碼零散且命名雜亂，作者已將功能相同的 #4 版本全面重整，方便後續解說不被歷史包袱干擾。新版程式碼已附於文末（BLOG #5.zip）供有興趣者下載試玩。

### 結語與預告
作者自嘲專案「好玩卻不實用」，但仍樂於挑戰腦力激盪的程式設計。本文僅為中場休息，下一篇將正式切入「抽象化 / 多型」的實作，敬請期待。