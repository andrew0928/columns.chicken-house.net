# 不只是 TDD #2：兩個版本自我驗證 + 執行期驗證

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 什麼是作者口中的「保守版本」，為什麼要先寫出這個版本？
「保守版本」指的是最容易實作、以正確性為唯一目標而不追求最佳效能的第一版程式碼。先寫出這支程式的目的，是讓它成為一個「可敬的對手」(Oracle)：之後所有改良版的輸出都必須與它完全一致，如此才能在安全無虞的前提下專心優化演算法。

## Q: 要如何利用「兩個版本自我驗證」來確保新演算法的正確性？
做法是：
1. 保留第一版保守解 (BasicSolution) 當作參考實作。
2. 撰寫新版高效演算法 (Solution)。
3. 透過程式大量產生隨機或極端測試資料，讓兩個版本同時執行。
4. 以單元測試 Assert.AreEqual() 比對兩邊輸出，只要有任何不一致，新版就被視為有誤。  
如此便能在不額外撰寫「正解」的情況下，對新版進行大規模覆蓋率的驗證。

## Q: 如果測試資料是隨機產生的，expected result 要從哪裡來？
直接把隨機輸入餵給「保守版本」計算，將其輸出視為 expected result，再拿來比對新版輸出即可。這就是「先有一個可靠但慢的版本，替我們驗算」的概念。

## Q: 除了開發階段的單元測試，作者還建議在執行階段做哪些驗證？
作者主張在正式程式碼中大量埋設 ASSERT（維護巨集），利用條件式編譯 (#if LOCAL_DEBUG … #endif) 只在除錯版本啟用。這些 ASSERT 會於 Runtime 檢查關鍵不變數，例如統計量與實際資料是否一致，一旦觸發就立即 Fail-Fast 以便迅速找到問題根源。

## Q: Unit Test 與執行期 ASSERT 有何差別？
• Unit Test：在 Dev/Build 階段執行，屬於黑箱測試；  
• ASSERT：編譯進程式內，於 Runtime 持續監控內部狀態，屬於白箱檢查；可偵測到只有執行期才會出現的異常，並以 Fail-Fast 方式立即中斷。

## Q: 為何「Fail Fast」的重要性被特別強調？
越早發現錯誤，修正成本越低；若程式在異常發生當下就中斷並指出違反的不變數，開發者能在最小搜尋空間內定位問題，避免錯誤被帶到更晚期甚至正式環境才爆發。

## Q: 作者示範如何自動產生大量隨機測試案例？
範例程式 GenRandomText() 每次產生最多 10,000 筆、長度不超過 100 的隨機字串（以 a~z 組成），再於單元測試中逐筆比較保守版與新版結果。這樣即可在數秒內完成數萬筆案例的驗證。

## Q: 在將單體系統重構為微服務時，如何套用同一套「新舊版本自我驗證」思維？
先讓新微服務在 Runtime 仍呼叫舊系統或重用舊邏輯計算結果，並即時比對兩邊輸出；待比對完全一致且覆蓋率足夠後，再逐步移除舊邏輯。這種方式能在不中斷服務的情況下，確保重構過程不改變對外可見行為。