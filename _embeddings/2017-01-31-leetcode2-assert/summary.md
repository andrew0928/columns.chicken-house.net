# 不只是 TDD #2：兩個版本自我驗證 + 執行期驗證

## 摘要提示
- 保守版本: 先寫「容易、保守」的第一版演算法，作為往後驗證的基準與對手。
- 雙版本對照: 以「舊版對照新版」的方式，大量自動比對輸出，確保改良後結果一致。
- 動態產生測試: 透過程式隨機產生大量測試資料，提高涵蓋率並暴露隱藏錯誤。
- 靜態極端案例: 人工挑選長度、內容極端的輸入，補足隨機測試的不足。
- Runtime 驗證: 在程式執行階段插入 ASSERT，及早偵測不可預期的狀況 (Fail-Fast)。
- 條件式編譯: 使用自訂巨集 (#define LOCAL_DEBUG) 隔離除錯碼，避免影響正式效能。
- ToString 輔助除錯: 覆寫 ToString() 搭配偵錯器，即時觀察物件狀態。
- 測試自動化投資: 一次撰寫驗證機制，後續重構或最佳化都可零人工復用。
- 微服務重構: 相同概念可應用於單體→微服務拆分，確保新舊服務行為一致。
- 基礎觀念: 工具日新月異，唯有測試思維與軟體設計基礎才是長久競爭力。

## 全文重點
作者以 LeetCode 題目「Shortest Palindrome」為例，說明 TDD 不應只停留在開發期的單元測試，而應延伸到「雙版本自我驗證」與「執行期驗證」。首先撰寫一個容易但效能普通的保守版本，確保可正確求解；接著在改寫效率更佳的新版本時，把兩個版本同時餵入大量測試資料，比對輸出是否完全一致，如此即可用舊版自動驗證新版的邏輯正確性。測試資料來源分為兩類：1) 靜態測試，由人工挑選最容易出錯的極端輸入；2) 動態測試，程式隨機產生數以萬計的字串，涵蓋各種長度與組合。  
為進一步捕捉僅在執行期才會浮現的問題，作者建議在程式內部布滿 ASSERT 與輔助除錯碼 (例如 ToString、統計檢查)，並利用條件式編譯只在 DEBUG 或自訂的 `LOCAL_DEBUG` 模式下啟動，既不影響正式效能，也能在開發時即時 Fail-Fast。這種「用慢版本驗證快版本、用執行期斷言守護內部狀態」的做法，不僅適用演算法優化，亦能套用在大型系統重構、單體拆分微服務等情境，成為降低風險、提升品質的關鍵手段。最後作者強調：工具會變，但測試觀念與軟體基礎才是工程師長期價值所在。

## 段落重點
### 前言：TDD 不只是單元測試
文章承接前一篇，指出若目標僅是「解題」，簡單單元測試已足夠；但在真實專案還需考量正確性、效能與可維護性，因此必須把 TDD 思維擴大到執行期及未知情境。

### 第二步：雖然可恥卻有用—先寫保守版本
面對未知問題，先實作最容易、時間複雜度較高的「保守演算法」(如 Bubble Sort 對 Quick Sort)。以 Shortest Palindrome 為例，作者提供 O(n²) 思路的 BasicSolution，作為往後驗證的「可敬對手」。

### 第三步：如何可靠地改良演算法
目標是寫出與保守版輸出完全相同、但效率更佳的新版本。方法是：
1. 靜態加入手選極端測試。
2. 動態隨機產生上萬組輸入，以程式比對兩版結果。
借助 NUnit/ MSTest 程式碼範例顯示如何在測試初始化中同時建立新舊物件，並用 `Assert.AreEqual` 檢查結果一致。

### 第四步：在主程式中插入維護 (ASSERT) 程式碼
黑箱式單元測試仍可能漏掉執行期錯誤，因此需在程式內部插入 ASSERT。作者示範在另一題 Zuma Game 中：
1. 覆寫 ToString() 方便偵錯。
2. 以 `#define LOCAL_DEBUG` 包裝 ToString 與 ASSERT 區塊，確保提交時剔除。
3. 在關鍵邏輯前後呼叫 `AssertStatisticData()`，即時比對統計值與實際資料，發現矛盾立即拋例外。

### 結論
雙版本驗證與執行期 ASSERT 的概念，與作者九年前「如何學好寫程式」系列一脈相承；今日工具更豐富，卻仍以同樣基礎知識驅動高品質軟體。此方法對演算法優化、微服務重構皆大有助益，工程師應專注於累積這些不隨時代變動的核心觀念。