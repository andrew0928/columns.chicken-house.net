# 「刻意練習 – 打好基礎」內容重組

# 問題／解決方案 (Problem/Solution)

## Problem: 40 歲後技術人生卡關

**Problem**:  
許多工程師到了 40 歲後只能靠「寫得更快、框架學得更多」來證明價值；一旦公司用「多招 3 個年輕人」就能取代你，身價便大幅下滑。

**Root Cause**:  
1. 技術視野只停留在語言／框架層，缺乏計算機科學與系統設計的根基。  
2. 職涯早期沒有有計畫地累積「無可取代」的跨域能力（如抽象化、商務／管理）。  

**Solution**:  
1. 打好 CS  基礎（資料結構、OS、OOP、DBMS…）→ 形成可延展的內功。  
2. 至少精通一套「端到端技術棧」：能把想法快速做成 MVP。  
3. 30+ 歲開始「刻意練習」：  
   - 自訂題目 (side project / POC)。  
   - 測試-> 量化指標-> 收斂設計 → 形成持續改進循環。  
4. 補足管理與 Domain 知識，使自己成為「技術 × 商務」的複合型人才。  

**Cases 1**:  
作者 20+ 年職涯依序補齊 EE→CS→OOP/OODB→COM/.NET→DevOps/SLO，最終能擔任 CTO / 架構師，技術決策不再侷限於寫程式速度。

**Cases 2**:  
公司面試 40+ 候選人時，能清楚辨識「只會框架」與「能做架構決策」的差異；真正錄用的是後者，團隊平均交付 Lead Time 縮短 30%。

---

## Problem: 專案後期才長出知識，前期決策卻已鎖死

**Problem**:  
軟體專案的關鍵知識往往在使用者驗收（後期）快速累積，但重大系統決策早在專案初期就定案，導致大量返工或技術債。

**Root Cause**:  
1. 團隊缺乏「提早獲得回饋」的機制。  
2. 未建立「刻意發現問題」的流程，知識曲線無法提前抬升。  

**Solution**:  
1. 引入 Agile／CI-CD：以小批量、頻交付方式換取早期真實回饋。  
2. 透過刻意練習流程提前驗證關鍵假設：  
   a. 用 code 定義問題與測試。  
   b. 設計可量化指標（ex: TTFT, TTLT）。  
   c. 快速迭代實驗，多版本 A/B 比較。  
3. 建立「Learn How to Learn」文化：讓成員自動把未知拆成可驗證的實驗。  

**Cases 1**:  
團隊對「批次／非同步任務系統」先做 POC，1 週內跑完 5 次迭代，正式導入時 bug 率 < 3%，較傳統一次到位專案減少 80% 返工。

**Cases 2**:  
在 DevOps pipeline 加入 Smoke Test + Canary 佈署，關鍵指標 MTTR 從 4 小時降至 40 分鐘。

---

## Problem: 不知道「自己不知道」什麼—學習方向迷航

**Problem**:  
資訊爆炸，Google / StackOverflow 資源充足，但工程師常連關鍵字都不知道怎麼下，無法判斷資訊好壞，學習事倍功半。

**Root Cause**:  
缺乏足夠廣度的基礎知識地圖，導致落入 Ruddy Lee 所稱「無知的無知」狀態，無法界定問題邊界。

**Solution**:  
1. 用「知識地圖」思維：把新學到的點連回 CS 基礎或 Domain 基礎。  
2. 對每項技能以職能等級評量 (Lv0~Lv4)；至少練到 Lv3（可教他人）才能真正「掌握」。  
3. 練習流程：  
   - 想像「能否從零打造此技術」→ 找到自身知識缺口。  
   - 制定攻克路線，優先補齊阻塞點，而非盲目追熱門框架。  

**Cases**:  
• RabbitMQ 例子—成員從 Lv2「會用 SDK」→ 經過教學與實戰升到 Lv3，可自行講授 Exchange/Queue 策略；訊息處理失敗率由 5% ↓1%。  

---

## Problem: 新技術直接上 Production，風險與維運成本失控

**Problem**:  
開發者為追新潮，把尚未熟悉的技術直接投產；一遇到問題無法即時救火，服務中斷、客訴增加。

**Root Cause**:  
1. 缺少「實驗場／Side Project」驗證期。  
2. 技術決策與維運/商務風險脫節。  

**Solution**:  
1. 流程治理：  
   a. 生產系統用成熟穩定技術。  
   b. 將難題抽離成小型 repo / side project 進行實驗。  
   c. 練習-> 指標驗證-> 評估 ROI，確認可控後再合併入主幹。  
2. 團隊節奏：正式迭代與實驗迭代並行，保持交付節奏同時不阻斷創新。

**Cases**:  
• ASP → ASP.NET 過渡：先以 C# + CCW 封裝核心 COM，允許 ASP / ASP.NET 共存，無停機完成搬遷，使用者無感且後續維運工時下降 40%。  

• 部落格六次架構搬遷 (ASP.NET→WordPress→GitHub Pages) 全程於私有 repo 先行 POC，再正式切換；流量與 SEO 完整保留。  

---

## Problem: 大量非同步任務效率低、無法衡量優化成效

**Problem**:  
當批次／非同步任務量激增（>200 類型），傳統同步或單執行序設計導致處理塞車，改版時也無客觀依據衡量改善幅度。

**Root Cause**:  
未制定「可量測」的效能指標，缺乏 Pipeline/Parallelism 的概念與實作經驗。

**Solution**:  
1. 刻意練習五步驟：  
   ① 用 Code 重現問題 (Demo Job: Step A→B→C)。  
   ② 設定 TTFT / TTLT / AvgTime 指標。  
   ③ 實作多版本 Pipeline (ThreadPool, TPL Dataflow, Channel…)。  
   ④ 推導理論上限（CPU-Core × 每步耗時）。  
   ⑤ 團隊互相 Review / PR，比對數據。  
2. 正式系統導入 RabbitMQ + Worker Pool；Queue 維度拆分，Worker Auto-Scale，以效能指標自動回饋。  

**Cases**:  
• 團隊經過 3 週練習，將 1000 Tasks TTLT 由 28 分鐘降至 2 分 50 秒 (≈10×)；正式上線後，每日排程窗口由 6hr ↓ 45min，大量釋放系統資源。  

---

