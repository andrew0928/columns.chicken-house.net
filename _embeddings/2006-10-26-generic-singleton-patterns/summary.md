# 泛型 + Singleton Patterns

## 摘要提示
- Singleton模式: 說明在 .NET 中建置只能產生一個實體的類別常見寫法。
- 程式碼重覆: 每增加一個 Singleton 類別就得複製幾乎相同的靜態屬性與建構式。
- 型別侷限: static 屬性型別固定，造成共用基底類別時難以維持正確回傳型別。
- 繼承解法: 透過基底類別集中 Singleton 邏輯，並以 Hashtable 儲存各型別實體。
- 反射建立: 使用 Activator.CreateInstance 於執行階段動態產生物件。
- 呼叫醜陋: SingletonBase.Instance(typeof(Foo)) 的寫法缺乏可讀性與型別安全。
- 開發者潔癖: 作者無法接受「醜」程式碼存在於專案中。
- 泛型契機: 結合繼承與 generic，可望在語法與型別安全間取得平衡。
- 設計思路: 先集中重複邏輯，再用泛型讓 API 回歸簡潔易讀。
- 待續伏筆: 文章以「待續」收尾，暗示下一篇將給出最終、優雅的實作。

## 全文重點
作者以在 .NET 2.0 開始支援的泛型機制為引子，討論如何讓 Singleton 模式的實作既簡潔又可重用。首先回顧傳統 Singleton 寫法：在類別中宣告一個私有靜態欄位保存唯一實體，並透過公開的靜態屬性取得；建構式標為 private，防止外部建立新物件。問題隨即浮現──一旦專案中有多個類別都須採用 Singleton，勢必重覆撰寫近乎相同的程式碼，只差 static 屬性的回傳型別。  
為了消除重覆，作者嘗試將通用邏輯搬到基底類別 SingletonBase。此基底類別利用 Hashtable 作為儲存區，並在 Instance(Type seed) 方法中以反射動態產生對應型別的唯一實體。衍生類別只需空的建構式即可；然而，呼叫端必須寫下 SingletonBase.Instance(typeof(MyClass)) 這種冗長、不具型別安全的語法，且返回值只能是 SingletonBase，再以轉型取用。  
在作者看來，這種作法雖把重覆程式碼集中，但讓 API 變得醜陋、缺乏直觀性，不符合「優雅程式碼」的標準。於是他提出兩個優化方向：(1) 透過繼承集中重覆程式碼；(2) 善用泛型使同一套邏輯可套用到不同型別，同時保持介面簡潔。文章最後以「總算找出一個最得意的解法，待續」作結，預示接下來將介紹結合繼承與泛型的終極 Singleton 範例。

## 段落重點
### 需求與背景：Singleton 與 Generic 的聯想
作者起手引出 .NET 2.0 的泛型特色，思考能否與 Singleton 設計模式結合，以減少樣板碼並提升可讀性；說明雖然兩者看似無關，但實務上卻能相輔相成。

### 傳統 Singleton 範例與侷限
示範最典型的 Singleton 類別：私有靜態欄位、公開靜態屬性、私有建構式；但若另一個類別也要 Singleton，就得整段程式再寫一次，僅型別名稱不同，造成維護負擔。

### 多類別需求下的繼承嘗試
為抽離共通邏輯，作者撰寫 SingletonBase；使用 Hashtable 保存各型別實例並以 Activator.CreateInstance() 動態建立；衍生類別只需繼承即可共用機制，重覆碼大幅減少。

### 結果與不滿：呼叫端的醜陋
雖然邏輯集中，但呼叫端必須傳 Type 物件，且回傳型別不再精確，導致程式碼冗長又缺乏型別安全；作者以「處女座」自嘲，強調自己的完美主義無法忍受這種 API。

### 解題方向與伏筆
作者點出解決策略：仍以繼承集中共通程式，但再引入 generic 讓 API 回復簡潔且具型別檢查；宣告已找到「最得意」的實作方式，並留待下一篇文章揭曉。