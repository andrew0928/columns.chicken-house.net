# [設計案例] 生命遊戲#2, OOP版的範例程式

## 摘要提示
- OOP導入: 以封裝、繼承、多型等特性重新詮釋康威生命遊戲，展示物件導向實作優勢。  
- 類別劃分: 透過 Class Diagram，將系統拆成 World 與 Cell 兩大核心物件並定義互動關係。  
- 主程式流程: 30×30 世界、100 世代輪播，主迴圈負責世代推進與畫面更新。  
- World職責: 封裝二維陣列、提供 GetCell／ShowMaps 等 API，並管理細胞生命週期。  
- Cell職責: 內含存活狀態、鄰居搜尋與四條演化規則，集中處理所有狀態轉移邏輯。  
- 封裝優點: 將規則包進 Cell，主程式僅需呼叫介面，邏輯清晰且易於擴充。  
- 隨機初態: 以 0.2 機率決定細胞初始生死，模擬自然隨機分布。  
- 命名一致性: 採用 region 與內部欄位區隔公開、私有、保護成員，提升可讀性。  
- 圖形輸出: Console 以 ●○ 符號顯示生死，並透過 SetCursorPosition 即時刷新。  
- 未來擴充: 下一篇將改動規則驗證 OOP 架構可維持最小修改、快速適應變更。

## 全文重點
作者以康威生命遊戲為題，示範如何利用 C# 和物件導向設計（OOP）撰寫一個結構清晰、易於維護的範例程式。文章先指出多數網路範例欠缺 OOP 精神，於是決定自行動手重構，把教科書式的生命遊戲規則真正落實到封裝、抽象與介面分離。

設計流程從「先找物件」開始：生命遊戲中最核心的概念只有「世界」（World）與「細胞」（Cell）。World 提供一個固定大小的二維棋盤，負責放置、管理所有細胞，並提供座標查詢與畫面輸出功能；Cell 則代表單一生命個體，內含當前存活狀態、定位資訊與對外互動介面，其最重要的方法是 OnNextStateChange——依四條經典規則（孤單死亡、擁擠死亡、穩定存活、復活新生）決定下一世代的生死。

程式主體僅 20 行：初始化世界尺寸、迴圈控制世代數，於每回合呼叫 ShowMaps 繪製狀態，Sleep(1000) 營造動畫效果，再雙重迴圈遍歷所有座標，取出 Cell 執行 OnNextStateChange。如此設計令進化邏輯完全被 Cell 封裝，主程式毫無條件式判斷，顯示高內聚低耦合的 OOP 優勢。

World 內部僅是包裝 Cell[,] 二維陣列，外加邊界檢查、防呆與 PutOn 方法；ShowMaps 透過 Console 實時輸出，利用 ● 表示存活、○ 表示死亡，並調整窗口大小達到清晰畫面。Cell 則以 Random 決定初始生死，提供 FindNeighbors 列舉八個鄰居，並據此統計存活數以套用規則。所有私有欄位與世界互動均設為 internal 或 protected，避免外部直接改寫破壞一致性。

最後，作者強調目前雖看不出與傳統寫法差距，但隨著規則增修或加上更多細胞類型、能量值、基因突變等需求，這種物件導向架構可最小化修改面、維持程式可讀性。下一篇文章將透過改變規格來驗證此一設計的可維護性，並附上完整原始碼供讀者實際操作。

## 段落重點
### 設計動機與 OOP 觀點  
作者注意到網路上多數生命遊戲程式僅求算出結果，缺乏 OOP 思維，於是決定用 C# 實作一版真正物件導向的範例。OOP 所強調的封裝、繼承、多型與動態連結，在生命遊戲這類生命模擬問題中能一次派上用場，因此被視為「完美的練習題」。透過這篇文章，作者希望示範從需求出發，到物件分析，再到程式落地的完整過程，並期望讀者能感受到 OOP 帶來的結構化優勢。

### 類別分析與 UML 圖  
依功能拆分後，系統僅需 World 與 Cell 兩大類別。World 代表整個二維空間，負責建構固定尺寸的棋盤、存取 cell 陣列並提供畫面輸出；Cell 代表單一細胞實體，記錄座標與存活狀態，並擁有計算下一世代生命狀態的邏輯。利用 VS2008 產生的 Class Diagram，可以直觀看到兩者的關係：World 內含多個 Cell，且 Cell 需要透過 World 來查詢鄰居。這種明確的物件分工有助於後續維護與擴充。

### 主程式運作流程  
程式入口點 Main 僅做三件事：建構 World、顯示當前地圖、驅動每個 Cell 進行狀態轉移。世代迴圈以整數計數，透過 Sleep(1000) 讓使用者觀察到動畫效果。為了遍歷所有細胞，主程式以雙重 for 迴圈跑過每個座標，呼叫 World.GetCell 取得實體後執行 OnNextStateChange。由於所有演算法已封裝在 Cell 內，這段流程幾乎沒有分支判斷，邏輯簡單且易讀。

### World 類別細節  
World 內部封裝一個 Cell[,] _map，並保留 SizeX、SizeY 表示世界邊界。建構函式負責實例化陣列並把每個 Cell 產入地圖；GetCell 搭配邊界檢查避免 NullReference；PutOn 用於把已存在的 Cell 放上指定座標並同步更新其位置屬性；ShowMaps 則負責輸出畫面，透過 Console.Title、SetWindowSize 與 SetCursorPosition 秀出 ●、○ 符號形成棋盤。這些 API 讓外部程式僅需透過受保護的方法操作，不直接接觸底層陣列，強化封裝。

### Cell 類別細節與封裝  
Cell 具有 IsAlive 狀態、PosX/PosY 座標及 CurrentWorld 參考。建構過程以 0.2 機率決定初始存活，並透過 World.PutOn 將自己置入世界。FindNeighbors 以 yield return 列舉八方鄰居並濾除 Null；OnNextStateChange 則根據鄰居存活數套用四條規則更新自身狀態。所有邏輯皆收斂於此，使得主程式與其他類別不需要知道規則細節。如此高內聚設計方便日後替換規則或引入新型 Cell 子類別而不影響既有程式。

### OOP 優點與後續展望  
本文藉由精簡但完整的架構說明：1) 封裝讓邏輯聚焦，減少外部干涉；2) 若未來加入不同種類 Cell，可以利用繼承和多型覆寫 OnNextStateChange；3) 世界尺寸、初始機率、演算規則改變時，影響範圍受到最小化。作者亦指出，目前僅展示最基本功能，看不出與傳統做法差距，但隨著需求增加，OOP 架構的彈性將快速浮現。下一篇文章將透過「改變題目」實證此一優勢，並已將完整原始碼上傳 GitHub，方便讀者試玩與深入研究。