# 《設計案例》生命遊戲#2 – OOP 版的範例程式

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 這一版「生命遊戲」程式的主要目的是什麼？
這一版的目的是把「生命遊戲」完整實作出來，同時盡量套用物件導向 (OOP) 的設計理念，不只算出結果，而是把程式架構設計得符合封裝、繼承、多型等 OOP 特性。

## Q: 在作者的 OOP 實作中，核心使用了哪些類別？它們各自的角色是什麼？
核心有兩個類別：
1. World：負責描述整個二維世界 (MxN 棋盤)，並提供對外介面如 GetCell 取得指定座標的 Cell，以及 ShowMaps 輸出整個世界的狀態。
2. Cell：代表單一細胞，保存自己是否存活 (IsAlive) 的狀態，並透過 OnNextStateChange() 依照「生命遊戲」規則決定下一回合的生死。

## Q: World 類別對外公開了哪些主要方法？
World 對外主要公開兩個方法：
1. GetCell(int posX, int posY)：傳回指定座標上的 Cell 物件 (或 null)。
2. ShowMaps(string title)：以 Console 方式把目前整個世界的狀態印出來。

## Q: Cell 類別如何決定下一個世代的存活狀態？
Cell 先透過 FindNeighbors() 找出 8 個鄰居並統計活著的數量，再依「生命遊戲」四條規則決定：
1. 活細胞若鄰居少於 1 個 → 孤單而死。
2. 活細胞若鄰居大於 3 個 → 擁擠而死。
3. 活細胞若鄰居為 2 或 3 個 → 繼續存活。
4. 死細胞若鄰居恰為 3 個 → 復活成活細胞。

## Q: 為什麼作者認為「生命遊戲」非常適合拿來示範 OOP？
因為這類生命模擬程式天生需要：
• 封裝 (把細胞行為包在 Cell 內)  
• 可能的繼承與多型 (未來若要擴充不同生物或規則)  
• 物件之間的互動 (Cell 與 World 的關係)  
因此幾乎能同時示範 OOP 所強調的各種特性，屬於很理想的教學範例。

## Q: 作者接下來打算怎麼做？
作者打算在下一篇把題目做些變化與複雜化，觀察 OOP 架構在面對需求更動時的調整方式，再與本篇的基礎版作比較。