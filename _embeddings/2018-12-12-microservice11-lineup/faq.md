# 微服務基礎建設 - 線上購物排隊機制設計

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 什麼是本文所稱的「線上購物排隊機制」？
排隊機制指的是：當電商在結帳階段需要做大量驗證與計算時，為了確保系統資源足以完成任務，同一時間只允許固定人數進入結帳，其餘訪客必須先進入「排隊」狀態；一旦前方使用者完成結帳並釋放資源，隊伍中下一順位的使用者才可被允許進入結帳流程。

## Q: 排隊機制與流量管控（Throttle）在微服務架構中各自負責什麼角色？
1. 排隊機制：決定「哪些請求」可以被放行，控制的是進入服務的「順序」與「人數」。  
2. 流量管控：限制單位時間內後端可處理的「併發量/速度」（TPS）。  
兩者同時就位，才能兼顧服務的質（等待體驗）與量（交易速度），並避免只依賴最終手段──斷路器/熔斷。

## Q: 本文理想的排隊機制在使用者端需要滿足哪些要點？
a. 前端採輪詢(Polling)模式，使用者可能任意中斷或重連。  
b. 預期同時排隊上限約 10,000 人，狀態更新週期 1 秒。  
c. 必須公平，先到先服，禁止插隊。  
d. 排隊過程需回報當前狀態、順位，若能結合平均處理速度即可預估剩餘等待時間。

## Q: 維運人員對排隊機制提出了哪些需求？
1. 即時監控各狀態人數（排隊中、結帳中、已完成、已放棄…）。  
2. 可動態調整參數（排隊上限、同時結帳人數…）。  
3. 具備手動剔除使用者的能力（依 id、依隊伍、依閒置時間等）。

## Q: 演算法用哪四個指標維護一條隊伍的狀態？
1. 結帳起點 (FirstCheckOutPosition)  
2. 排隊起點 (LastCheckOutPosition)  
3. 排隊終點 (LastQueuePosition)  
4. 號碼牌發放機 (CurrentSeed)

## Q: 為何必須讓每位使用者查詢排隊狀態的運算複雜度降至 O(1)？
使用者採輪詢方式頻繁查詢順位；若隊伍有 N 人且每次查詢是 O(n)，整體就變成 O(n²) 且伴隨高 IOPS 成本。將查詢設計成 O(1) 可大幅減少 CPU 與儲存體存取，降低成本並提升可擴充性。

## Q: 如何偵測並移除中途離開或斷線的使用者？
系統在回覆查詢時同時記錄 token 的最後一次回報時間。週期性 recycle worker 會巡檢 [結帳起點 ~ 號碼機] 區段，找出超過設定 Timeout 的 token 並呼叫 Remove() 將其剔除，空出名額給其他排隊者。

## Q: 這套排隊演算法帶來的主要優點是什麼？
1. 公平先進先出。  
2. 查詢與計算皆為 O(1)，效能好、雲端成本低。  
3. 僅需少量資料（四個指標＋token 紀錄）即可運作，易於快取與分散式擴充。  
4. 方便產生監控指標，讓 Dev 與 Ops 在開發階段就能共同驗證與維運。

## Q: 為什麼 POC 實作時刻意減少外部框架與服務依賴？
目標在最短時間驗證核心演算法是否可行並讓團隊理解設計理念。過早導入眾多框架會模糊焦點、拖慢迭代速度，也增加日後交接難度。單機 Console + 幾百行 C# 程式即可證明設計並取得回饋。

## Q: 模擬與監控階段需要關注哪些關鍵 Metrics？
1. _queuing_count － 目前排隊人數  
2. _checking_count － 目前結帳人數  
3. _abort_queue_count － 累計放棄排隊人數  
4. _abort_checkin_count － 累計放棄結帳人數  
5. _no_entry_count － 因隊伍已滿無法進入排隊的人數  
6. _success_count － 成功完成交易的人數  
再加上四個指標（CurrentSeed, FirstCheckOutPosition, LastCheckOutPosition, LastQueuePosition），即可透過 Dashboard 或 Excel 圖表快速觀察系統運行情形。