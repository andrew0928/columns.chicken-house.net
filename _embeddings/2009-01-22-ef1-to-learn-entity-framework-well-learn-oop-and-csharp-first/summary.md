# EF#1. 要學好 Entity Framework? 請先學好 OOP 跟 C# ...

## 摘要提示
- 學習重心轉移: 學好 EF 之前，先補強 OOP 與 C#（含 LINQ）才能真正把 ORM 用好。
- 架構性比較缺口: 市面多實作教學，缺乏 EF、NHibernate、Linq to SQL 的本質與架構比較。
- 作者背景與脈絡: 作者長期涉獵 OOP/OODB/XML DB/自建 ORM，對 ORM 成功要素有深切體會。
- Typed DataSet 限制: 雖接近 ORM，但血統不純，物件氣味不足，EF 跨出實用一大步。
- 成功 ORM 要件: 映射機制、可擴充性、物件化查詢、真正的「物件感」、效能便利性、品牌影響。
- OOP 三特性關鍵: 封裝、繼承、多型是 ORM 能否超越「資料薄皮」的核心。
- 封裝困境與價值: DB 的安全/授權非封裝，若由 ORM 扛下封裝可取代傳統 DAL 並把關資料品質。
- 繼承對應難題: 繼承映射到 DB 很難，EF/NHibernate 提供三種策略，選擇本身就是學問。
- 多型落差: DB 層難以優雅表達多型邏輯，應移至應用層，ORM 因此更顯必要。
- C# 語言支援: Reflection/Attribute、Partial Class、Extension Methods、LINQ 讓 EF 的 Entity 更像真物件並解決查詢難題。

## 全文重點
文章出發點是作者在評估是否以 EF 作為五年期開發計畫的核心 ORM 時的觀察：要把 EF 用好，先要把 OOP 與 C#（尤其 LINQ）學好。作者指出市面資訊多半著墨於教學與範例，卻欠缺 EF、NHibernate、Linq to SQL 等技術在本質、優劣與未來性的架構性比較。基於自身從 OOP、OODB、XML Database 到自建 ORM 的長期實作經驗，他認為 ORM 能否成功，不僅取決於框架本身，也取決於其所寄生的語言與平台是否成熟。

他回顧 Typed DataSet 雖然提供接近 ORM 的能力，但「物件味」不足；EF 的價值在於整個 .NET 生態（特別是 C# 語言與 LINQ）已提供使 Entity 真正像物件運作的條件。從實作觀點，作者歸納出成功 ORM 的六大條件：良好的物件/關聯映射與工具、足夠的擴充與自訂能力、支援以物件觀點進行查詢、讓「物件」看起來像「物件」而不只是資料袋、在效能與便利上貼近直接存取 DB、以及（次要的）品牌影響力。

核心論證圍繞 OOP 三特性（封裝、繼承、多型）在資料存取領域的落地。DBMS 的安全/授權並非封裝，對資料的精細控制力有限，導致錯誤資料常能鑽入；若由 ORM 建立正確封裝並成為應用對 DB 的主要 API，便能取代傳統 DAL 並大幅提升資料品質。繼承在 DB 上的表達本就艱難，從 schema 到查詢都複雜且昂貴，EF/NHibernate雖提供三種繼承映射策略，但抉擇本身就需深厚理解。多型更難在 DB 中優雅實現，若硬塞進存儲過程只會充斥醜陋的條件分支，應將抽象與差異化行為拉回應用層，由 ORM 橋接物件世界與資料世界。

作者認為早期 ORM 的痛點是語言能力不足，讓實體物件用起來與一般物件落差大。今日的 C# 透過 Reflection/Attribute（宣告式映射、簡化樣板）、Partial Class（與代碼產生器協作）、Extension Methods（對既有型別無侵入擴充）、以及 LINQ（以型別安全與可組合方式表達查詢，涵蓋多數應用層查詢場景）等能力，使 EF 的 Entity 更貼近真正的物件並有效處理查詢問題。作者最後預告後續將示範打造專屬 Entity 的技巧，強調 EF 的價值在於語言與框架「魚幫水、水幫魚」的成熟配合，而不僅是 EF 本身功能。

## 段落重點
### 學 EF 先學 OOP 與 C#
作者指出學好 EF 的關鍵在於先掌握 OOP 與 C# 語法（含 LINQ）。探究 EF 時，大量精力其實花在 C# 特性與 LINQ 上；ORM 是否成功也高度仰賴其所運行的平台與語言成熟度。

### 缺乏架構性比較的痛點與評估問題
市面文章多偏向實作教學與步驟，卻少有 EF 與 NHibernate、Linq to SQL 的本質對比、優缺點與未來發展的討論。作者真正需要的是能決策是否把長期投資押在 EF 上的架構性資訊。

### 作者經驗與觀點來源
作者自大學深耕 OOP，研究所研究 OODB，職涯曾用 Tamino（XML DB）並在 SQL Server 上打造 Object↔XML↔Database 的類 ORM。這些背景讓他對 ORM 的可行性與難題有一手觀察。

### Typed DataSet 與 EF 的差異
Typed DataSet 在結構上與 EF 有相似之處（DataSet≈ObjectContext、DataTable≈EntitySet、DataRow≈Entity、Relation≈Navigation Property），但使用感受仍充滿 DataSet 的影子，未能呈現純正物件風格。EF 結合當代 .NET 技術已更接近實用。

### 成功 ORM 的六大要件
作者從實務歸納 ORM 成功關鍵：良好的映射機制與工具、可擴充與自訂、能以物件思維處理查詢、物件須有真正物件感、效能便利性接近直連 DB、品牌加持。Typed DataSet 雖解部分需求，但不足以成為完整解。

### OOP 三特性作為關鍵鏡頭
以封裝、繼承、多型檢視資料存取：若 ORM 只能把資料包一層就不夠，需讓對應出的 Entity 能實用地運用 OOP 特性，且框架能維持與 DB 的正確對應，避免三層式在資料層破功。

### 封裝：DB 的限制與 ORM 的位置
DBMS 的安全與授權不是封裝；其對資料的控制多停留在鍵、約束、關聯，難以表達更精細規則（如加解密、正規表示式等）。缺乏 ORM 時，這些責任分散在應用代碼且易失守。若 ORM 成為主要 API，能集中封裝與驗證，實質取代傳統 DAL。

### 繼承：從物件世界到資料世界的艱難映射
應用層以繼承抽象共通行為非常直覺，但映射到 DB 會牽涉複雜 schema 設計與查詢難度提升。EF 與 NHibernate 提供三種繼承映射策略，各有權衡，選型本身就是專題。

### 多型：DB 層難以優雅承載
多型建立在繼承之上，允許以父型別操作各子型別並保有差異化行為；若嘗試在存儲過程實現，往往淪為層層 if-else 的醜陋分支。多型邏輯宜回歸應用層，ORM 負責橋接與持久化。

### C# 語言進化為 EF 賦能
- Reflection/Attribute：以宣告式方式描述類別/屬性與表/欄位映射，減少樣板。
- Partial Class：利於與代碼產生器協作，保留手寫邏輯。
- Extension Methods：對既有類型非侵入擴充，補足框架型別能力。
- LINQ：以型別安全、可組合的查詢語言覆蓋多數應用層查詢；大型報表仍可回退 SQL。這些能力讓 EF 的 Entity 用起來更像真物件，縮小早期 ORM 與一般物件的落差。

### 結語與後續
總結 EF 的價值在於與 C#/.NET 生態的成熟互補，而非 EF 單點能力。作者將在後續文章示範打造專屬 Entity 的技巧，呼籲讀者耐心等待。

## 資訊整理

### 知識架構圖
1. 前置知識：學習本主題前需要掌握什麼？
   - 物件導向基礎：封裝、繼承、多型
   - C# 語言特性：reflection、attribute、partial class、extension methods
   - LINQ 基礎：查詢語法與延遲執行概念
   - 關聯式資料庫與 SQL 基礎：schema、constraint、FK、基本查詢
   - 三層式架構與 DAL 的角色

2. 核心概念：本文的 3-5 個核心概念及其關係
   - ORM 的成功要件：良好映射、可擴充性、查詢能力、物件一致性、效能/便利、社群與品牌
   - OOP 三特性與資料庫的張力：封裝/繼承/多型在 DB 層的不適配與在 ORM 層的實現
   - C# 與 EF 的互補：reflection/attribute、partial、extension、LINQ 使 ORM 真正像「物件」
   - 查詢抽象化：LINQ 解決 ORM 過去在查詢層的斷裂問題
   - 映射策略（尤其是繼承）：同一物件模型可有多種 DB 映射方式，需取捨

3. 技術依賴：相關技術之間的依賴關係
   - EF/NHibernate 等 ORM 依賴 .NET 執行環境與 C# 語言能力
   - LINQ Provider 作為查詢抽象化層，將 C# 查詢轉譯為 SQL
   - 映射機制依賴 metadata（attribute/外部模型）與 reflection
   - Code generator 與 partial class 搭配以分離自動產生碼與業務邏輯
   - 應用層透過 ORM 取代傳統 DAL，連接至 RDBMS

4. 應用場景：適用於哪些實際場景？
   - 一般企業應用的資料存取層替換與簡化（以 ORM 取代 DAL）
   - 嚴格資料驗證與業務規則封裝（防錯資料入庫）
   - 具繼承/多型的領域模型（如部落格文章/相片等異質內容）
   - 日常業務查詢以 LINQ 完成（報表等複雜查詢可保留 SQL）
   - 三層式架構中強化領域層的物件一致性與可維護性

### 學習路徑建議
1. 入門者路徑：零基礎如何開始？
   - 先補 OOP 基本觀念（封裝/繼承/多型）與 C# 基本語法
   - 熟悉 LINQ 語法與常見操作（Select/Where/Group/Join）
   - 了解 RDBMS 與基本 SQL（鍵、關聯、約束）
   - 以簡單專案體驗 EF：建立實體、基本 CRUD、簡單 LINQ 查詢

2. 進階者路徑：已有基礎如何深化？
   - 探索 EF 的實體映射與關聯、導覽屬性、變更追蹤
   - 練習繼承映射策略的取捨與實作
   - 運用 partial class 與 extension methods 組織業務邏輯
   - 研究效能與便利性的平衡：追蹤/非追蹤、查詢最佳化、SQL 落地分析
   - 理解 EF 的擴充點與自訂行為（攔截、驗證、轉換）

3. 實戰路徑：如何應用到實際專案？
   - 以「內容系統」為例建模（共同父類：Content；子類：Article/Photo）
   - 在實體中實作驗證與領域規則（封裝資料、不把驗證推給 DB）
   - 以 LINQ 完成 80% 業務查詢，對少數複雜報表改用原生 SQL
   - 建立測試資料與效能指標，驗證查詢與寫入的效能/便利性
   - 與現有 Typed DataSet 或手寫 DAL 比較維護成本與可讀性

### 關鍵要點清單
- ORM 成功要件總覽: 良好映射、擴充性、查詢能力、物件一致性、效能、品牌影響 (優先級: 高)
- OOP 三特性與資料庫落差: 封裝/繼承/多型在 DB 層難以體現，需由 ORM 承擔 (優先級: 高)
- EF 與 C# 的互補: reflection/attribute/partial/extension 讓實體更像真正物件 (優先級: 高)
- LINQ 的關鍵角色: 解決 ORM 查詢抽象化的痛點，避免頻繁落回 SQL (優先級: 高)
- 封裝與資料驗證: 以實體封裝規則，避免將驗證全壓在 DB 與 UI (優先級: 高)
- 繼承映射策略: 同一物件繼承可對應多種 DB 方案，需依情境選擇 (優先級: 中)
- 多型在應用層實現: 以父型操作異質子型，避免在 DB 層用 if-else 模擬 (優先級: 中)
- 取代或強化 DAL: 讓 ORM 成為主要存取 API，減少重複樣板碼 (優先級: 中)
- Typed DataSet vs EF: Typed DataSet 功能近似但「物件血統」不純，EF 體驗更一致 (優先級: 中)
- 效能與便利性平衡: ORM 的便利性不可遠落後於直連 DB 的效能 (優先級: 高)
- Partial class 與產碼協作: 分離自動產生碼與手寫邏輯，降低衝突 (優先級: 中)
- Extension methods 的加值: 對既有類型加能力、不破壞既有結構 (優先級: 低)
- Reflection/Attribute 的映射: 以標註驅動對應，減少樣板與硬編碼 (優先級: 中)
- 三層式架構的完整性: 有了 ORM 才能讓三層式不在 DB 層「破功」 (優先級: 中)
- 主流與生態因素: 技術成熟度與品牌社群會影響長期投資風險 (優先級: 低)