# [設計案例] 生命遊戲#3, 時序的控制

## 摘要提示
- 回合制盲點: 依序掃描格子會導致同一組初始狀態產生不同結果。  
- 即時制概念: 以 Final Fantasy 的「即時戰鬥」為例，引入倒數計時改寫生命遊戲。  
- 時序規則: 每一細胞每 1000 ms 進入下一狀態，並加入 ±10 % 誤差。  
- 多執行緒：為每顆細胞開一條 Thread，彼此獨立更新生命週期。  
- Cell 新增 WholeLife(): 迴圈呼叫 OnNextStateChange()，再隨機 Sleep。  
- Game Host 重構: 建立 thread 清單、定期刷新畫面、偵測所有執行緒結束。  
- 畫面效果: 不規則跳動更接近真實世界，避免枯燥的同步翻頁。  
- 性能成本: 濫用執行緒會增加 context switch 負載，需衡量代價。  
- 擴充方向: 下一篇將用繼承與多型，讓不同生命共存於同一世界。  
- 範例程式: 文章末附上 Multi-Thread Source Code 供參考。  

## 全文重點
作者延續「生命遊戲」系列，指出傳統範例採「回合制」掃描棋盤，依照陣列順序先後決定細胞生死。這種做法不僅與真實生命不同，也造成相同起始環境可能因掃描順序不同而出現不同結果。為貼近現實並提升可玩性，他改用「即時制」，讓每個細胞各自擁有一個計時器，時間一到便獨立更新自身狀態。具體規則為：每 1000 ms 進入下一世代 (generation)，並隨機加入 ±10 % 的誤差 (950–1050 ms)，以模擬自然界中沒有完全同步的生物節奏。  

技術上，他為 Cell 類別新增 WholeLife() 方法，接收目標世代數作為參數，在迴圈中重複呼叫 OnNextStateChange() 後 Sleep 隨機時間。Game Host 端則依世界大小 (30×30) 建立相對應的 Thread，將每條執行緒指向各自的 Cell.WholeLife()，並在主緒中以 100 ms 週期重新繪製地圖。當所有執行緒 ThreadState 皆為 Stopped 時，主緒才呼叫 Join() 收尾。  

改版後的模擬呈現出類似電視的閃動畫面：細胞依自身節奏不規則跳動，令人感覺世界更「活」。作者同時提醒：大量 Thread 會帶來高 context switch 開銷，雖能快速完成作業，但在真正的線上遊戲或大型系統仍需謹慎設計。文章最後預告下一篇將加入繼承與多型，讓不同型態的生命在同一個世界中互動，並附上完整範例碼供讀者下載研究。

## 段落重點
### 回合制的盲點
傳統生命遊戲一次只處理一顆細胞，先後順序被程式掃描方式決定；因此即使起始圖形、規則相同，也可能因掃描方向不同而出現不同結果，反映回合制的不真實與不可預期。

### 引入即時觀念
作者借用 Final Fantasy 從回合制到即時制的演進，比喻將每顆細胞配置「倒數碼錶」。計時歸零時即可執行下一步，達成類似真實世界中「同時進行但不完全同步」的效果。

### 新時序規則
設定每顆細胞的週期為 1000 ms，並施加 10 % 隨機誤差；其他生存、死亡與增生規則維持不變，僅改動時間層面。

### 程式架構調整
保留原有 Cell 類別，僅新增 WholeLife()；世界中所有 Cell 都以獨立 Thread 執行，彼此互不干擾，並由 Game Host 統一刷新畫面與監控執行緒狀態。

### Cell.WholeLife() 實作
方法接受 generation 數，使用 for 迴圈重複 OnNextStateChange(); 每次迴圈結束 Sleep 隨機 950–1050 ms，以達到非同步時序。

### Game Host 改寫
Main() 中先建立 World，再雙迴圈產生 Cell 取出並建立 Thread；每條 Thread.Start() 傳入最大世代。主緒持續每 100 ms 呼叫 ShowMaps()，並檢查 IsAllThreadStopped()；最後逐一 Join()。

### 執行結果觀察
新的即時制讓畫面類似動態卡通，細胞跳動頻率各異；上帝視角也難以預測下一刻狀態，模擬世界更具生命力。

### 性能與代價
雖可透過濫用執行緒達成效果，但大量 context switch 會消耗系統資源；實務上仍需依目標平台與規模評估是否採用 Thread 或其他併發模型。

### 擴充與預告
下一篇將在多執行緒基礎上加入物件導向技巧：以繼承多型打造多種生命型態共存環境，並提供下載範例程式碼讓讀者持續探索。