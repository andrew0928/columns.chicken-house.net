# [設計案例] 生命遊戲#3, 時序的控制

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 為什麼在同樣的起始狀態與相同規則下，程式卻可能得到不同的生命遊戲結果？
因為舊版程式屬於「回合制」(turn-based) 模式，必須按照程式的掃描 (SCAN) 順序逐格更新細胞。誰先被更新、誰後被更新會直接影響下一回合的盤面，導致最終結果不唯一。

## Q: 什麼是作者提出的「即時制」(real-time) 解決方案？
改為讓每一個細胞都擁有自己的執行緒，彼此獨立地進行狀態更新；每隔 1000ms 進入下一狀態，並加入 ±10% 的隨機誤差 (950 ms ~ 1050 ms)，如此就不再受到掃描順序的影響，而更接近真實世界的非同步行為。

## Q: Cell 類別為了支援即時制，多新增了哪個方法？其功能是什麼？
新增 `WholeLife(object state)` 方法。它會在迴圈中：
1. 依序呼叫 `OnNextStateChange()` 更新細胞狀態。  
2. 以 `Thread.Sleep(_rnd.Next(950, 1050))` 休眠隨機時間。  
重覆執行直到指定的世代數 (generation) 結束為止。

## Q: Game Host (主程式) 為了管理多執行緒版本，做了哪些主要調整？
1. 針對世界裡的每一個 Cell 建立一支專屬 `Thread`，並以 `t.Start(maxGenerationCount)` 啟動。  
2. 以迴圈持續呼叫 `realworld.ShowMaps("")` 來重繪畫面，同時 `Thread.Sleep(100)` 控制刷新頻率。  
3. 透過 `IsAllThreadStopped()` 檢查所有細胞執行緒是否結束，最後以 `t.Join()` 等待全數結束。

## Q: 為何作者不建議「手動」實作類似的時間切換機制，而是直接使用多執行緒？
若自行在單執行緒環境裡寫迴圈輪流更新並模擬時間延遲，就必須手動做 context switch，開發複雜度高且效能差；讓 OS 與執行緒排程器負責切換可直接省去這些成本。

## Q: 文章最後預告下一篇將加入哪些新元素？
作者打算在下一篇中透過「繼承」與「多型」讓不同型態的生命可以在同一個世界裡共同生存，進一步擴充生命遊戲的規則。