# LINQ to Object #2, Indexes for Objects — FAQ

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是 LINQ to Objects？
- A簡: LINQ to Objects 是在 .NET 中以 LINQ 對 IEnumerable<T> 記憶體集合進行查詢的技術，支援過濾、投影、排序等操作。
- A詳: LINQ to Objects 讓開發者以宣告式語法（查詢運算式或方法鏈）對任何實作 IEnumerable<T> 的記憶體集合進行查詢，如 List<T>、陣列等。它提供 Where、Select、OrderBy 等運算子，預設採延遲執行，直到列舉結果或轉材（如 ToList）才實際運算。未建立索引時，多數查詢是線性掃描 O(n)。本文示範在 List<Foo> 上使用 where x.Text == "888365" 的查詢，並比較未索引與建立索引後的效能差異。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q14, B-Q9, C-Q3

A-Q2: 什麼是 i4o（Indexes for Objects）？
- A簡: i4o 是為物件集合建立索引的 .NET 函式庫，透過 IndexableCollection<T> 與 CreateIndexFor 加速 LINQ 等值查詢。
- A詳: i4o（indexes for objects）是一套讓記憶體集合能「像資料庫一樣」擁有索引的函式庫。它提供 ToIndexableCollection<T>() 將既有集合包裝為可索引集合，並以 CreateIndexFor(i => i.Property) 建立欄位級索引。當 LINQ 的 Where 條件使用等值比較且命中已建立索引的屬性時，i4o 會改以索引查找，避免全表掃描，明顯縮短查詢時間。本文範例在 Foo.Text 與 Foo.Number 建立索引，展示查詢加速的效果。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q10, B-Q1, C-Q1

A-Q3: 為什麼在記憶體集合需要索引？
- A簡: 大量資料時，未索引查詢為 O(n)。索引能把等值查詢降為近 O(1)，對頻繁查詢場景顯著加速。
- A詳: 當集合規模上百萬筆時（如本文 1,000,000 筆 Foo），未索引的 Where 過濾會線性掃描整個集合，具有高延遲與 CPU 消耗。若查詢模式穩定且重複，先支付一次性建立索引成本（O(n)），後續等值查詢可直接以雜湊或樹結構定位，時間近似 O(1) 或 O(log n)。因此在「讀多於寫」「相同條件反覆查」的情境，索引能大幅提升整體吞吐與回應時間。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, B-Q4, C-Q4

A-Q4: 索引與 Dictionary 有何差異？
- A簡: Dictionary 是單一鍵值快速存取的容器；索引是對現有集合的加速結構，可建立多索引並與 LINQ 整合。
- A詳: Dictionary<TKey,TValue> 天生以鍵存取資料，適合「以鍵直接取值」。索引則是附掛在一般集合上的輔助結構，用於加速某些屬性的查詢。索引可同時存在多個（如對 Text 與 Number 各建索引），可保留原集合語義並與 LINQ 無縫整合。此差異讓索引能在不改變資料模型的前提下，針對常見查詢鍵優化；而 Dictionary 則要求以鍵作為主訪問途徑。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, B-Q8, C-Q6

A-Q5: i4o 與自訂 IndexedList 的差異？
- A簡: 自訂 IndexedList 以 Dictionary 實作且僅支援等值；i4o 提供泛用 API、索引管理與 LINQ 整合，使用更簡潔。
- A詳: 文中自訂 IndexedList 針對 Foo.Text 與 Foo.Number 以字典建立索引，且 Query 僅支援 ==。它需要手動 ReIndex 維護。i4o 則提供 ToIndexableCollection 與 CreateIndexFor 等標準 API，將索引生命週期與 LINQ 查詢整合，建立索引後以 where x.Prop == value 自動命中。i4o 使用體驗更一致、可鏈式建立多索引，並保有原 IEnumerable<T> 的操作便利。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q1, C-Q8

A-Q6: List<T>、IndexableCollection<T> 與自訂 IndexedList 的比較？
- A簡: List<T> 通用但無索引；自訂 IndexedList 需自行維護；IndexableCollection<T> 由 i4o 管理索引並與 LINQ 整合佳。
- A詳: List<T> 適用各種情境，但查詢為線性掃描。自訂 IndexedList 可針對特定屬性建索引、等值查詢快，但功能有限且要自管 ReIndex。i4o 的 IndexableCollection<T> 透過標準 API 建多個索引，與 LINQ 自動互通，保留原集合行為並提升等值查詢效能。選擇依需求：若查詢頻繁且模式穩定，i4o 省時省心；臨時或小資料則 List<T> 足矣。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q3, B-Q2, C-Q1

A-Q7: 建立索引的代價是什麼？
- A簡: 需要一次性建構時間與額外記憶體。若查詢次數少或資料常變動，收益可能不足以抵銷成本。
- A詳: 建索引需掃描集合並計算鍵值，時間為 O(n)。每個索引都需維護鍵到項目的映射，消耗額外記憶體（常見為數倍於鍵值本身）。若資料經常新增刪除，索引需同步更新或重建，也帶來額外成本。因此是否建索引應基於查詢頻率、資料變動比例、可用記憶體與響應時間目標綜合評估。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q6, B-Q12, D-Q2

A-Q8: 未索引 LINQ 查詢的時間複雜度為何？
- A簡: 一般為 O(n) 線性掃描，資料量越大查詢時間越長。
- A詳: 對 IEnumerable<T> 的 Where 會遍歷序列的每個元素並測試條件，屬於 O(n)。若集合規模達百萬筆，單次查詢將消耗顯著時間與 CPU 週期。本文中未索引的 List<Foo> 對 Text 等值查詢需全掃描；引入索引後可將查詢改以鍵查找，避免逐筆比較，明顯縮短時間。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q4, C-Q4

A-Q9: i4o 主要最佳化哪些查詢條件？
- A簡: 以 where 針對已建索引屬性的等值比較（==）為主，其餘條件通常回退為線性掃描。
- A詳: i4o 的核心價值在於將 Where 子句中的等值比較（如 x.Text == "888365"）對應到預先建立的索引，直接以鍵取回候選集合。若條件為範圍比較（>、<）或複雜述句不符合索引規則，通常會回退到一般 LINQ 的序列掃描。實務上可針對最常見的等值查詢欄位建立索引，取得最大效益。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, C-Q9, D-Q5

A-Q10: CreateIndexFor 的用途是什麼？
- A簡: 指定某屬性作為索引鍵，建立對應索引結構，供後續 LINQ 等值查詢使用。
- A詳: CreateIndexFor(i => i.Property) 接受屬性選擇器，為該屬性建立索引。可鏈式呼叫多次建立多個索引，如 CreateIndexFor(i => i.Text).CreateIndexFor(i => i.Number)。建立後，當 Where 使用等值比較且目標屬性已被索引，i4o 會改用索引查詢，顯著加速。此 API 是 i4o 使用體驗的核心。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, B-Q3, C-Q2

A-Q11: ToIndexableCollection<T> 作用為何？
- A簡: 將既有 IEnumerable<T>/List<T> 包裝成可索引集合，使其能建立索引並被 i4o 最佳化。
- A詳: 既有的 List<T>、IEnumerable<T> 無索引能力。透過 ToIndexableCollection<T>()，可轉為 IndexableCollection<T>，保留原有列舉能力並新增索引功能。轉換後即可呼叫 CreateIndexFor 建立索引，並直接使用 LINQ 語法進行查詢。這讓既有程式最小改動即可受益於索引加速。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, B-Q1, B-Q2

A-Q12: 什麼是 ReIndex？何時需要？
- A簡: ReIndex 是自訂 IndexedList 的重建索引動作；當資料變更且索引不同步時需重建。
- A詳: 文中自訂 IndexedList 需手動呼叫 ReIndex() 以重建索引，通常在大量新增/刪除或批次更新後執行，確保鍵到項目的映射正確。注意：這是自訂型別的維護方法，非 i4o 通用 API。使用 i4o 時，索引維護策略視套件實作而定，可能提供自動同步或需重新建立索引。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, B-Q7, C-Q8

A-Q13: 選擇 Foo.Text 與 Foo.Number 作為索引鍵的考量？
- A簡: 應考慮查詢頻率、基數分佈、唯一性與等值查詢比例，常查且分佈均勻者優先。
- A詳: 適合建索引的屬性通常具高查詢頻率、值分佈均勻（避免熱點）、等值查詢為主且選擇性佳（能快速縮小候選集）。文中 Text 與 Number 常被等值查詢，且作為鍵值直觀，故建索引能帶來顯著加速。若屬性低選擇性或多為範圍查詢，索引效益會下降。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q6, B-Q12, D-Q7

A-Q14: 什麼是延遲執行？ToList 又扮演什麼角色？
- A簡: LINQ 查詢預設延遲，直到列舉才執行；ToList 會強制即時執行並實際產生結果集。
- A詳: 多數 LINQ 運算子（如 Where、Select）會建立查詢描述但不立即執行，稱為延遲執行。當進行 foreach、Count、ToList 等操作時才真正評估。本文用 ToList<string>() 觸發查詢，以便精準量測查詢實際耗時。若未強制執行，Stopwatch 量到的可能只是建構查詢的成本而非查詢本身。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, C-Q4, D-Q8

A-Q15: 查詢運算式與方法語法的差異？
- A簡: 兩者功能等價，編譯器會將查詢運算式轉為方法鏈，效能上無本質差異。
- A詳: C# 的查詢運算式（from/where/select）在編譯時會轉換為對 Enumerable 擴充方法的呼叫（方法語法）。因此在 LINQ to Objects 下，兩種寫法在可讀性與風格不同，但效能等價。本文示範使用查詢運算式，最終仍會轉為 Enumerable.Where/Select 形式。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q9, C-Q3, D-Q8

A-Q16: 如何用 Stopwatch 正確量測效能？
- A簡: 使用 Restart/Stop，分別量測「建索引」與「查詢」階段，並以 ToList 觸發查詢執行。
- A詳: 建議在每段待測程式前呼叫 timer.Restart()，完成後以 timer.Elapsed 讀取耗時。將「索引建立」與「查詢」拆開量測，避免混淆。為避免 JIT 影響，先做一次預熱或忽略首輪結果；為避免延遲執行，對查詢使用 ToList() 或 Count() 觸發運算。多次取樣並取平均更能反映穩定表現。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q4, D-Q8, A-Q14

A-Q17: 為何等值查詢特別適合用索引加速？
- A簡: 等值查詢可直接映射到雜湊或樹索引鍵查找，時間近 O(1)/O(log n)，避免全域掃描。
- A詳: 索引的本質是以鍵定位記錄。等值比較（==）可將查詢鍵直接套用到索引結構（如 Dictionary 或 B-Tree），快速鎖定候選。相比之下，範圍、模糊或複合條件較難直接利用雜湊鍵，常需回退掃描或較複雜結構。因而在讀多且等值查詢常見的場景，建立等值索引能獲得最大化的效能改善。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, A-Q9, C-Q3

A-Q18: 索引如何在資料更新時維護（概念）？
- A簡: 可選即時更新或批次重建。即時維持一致性；批次重建省成本但短期可能不同步。
- A詳: 當集合變動（新增、刪除、修改索引鍵）時，索引需同步更新。策略一是即時更新：每次變動即調整索引，查詢永遠正確；策略二是批次重建：累積多次變更後重建索引，降低維護成本，但在重建前查詢可能不一致。自訂 IndexedList 以 ReIndex 重建；i4o 的維護方式依套件實作，應參閱文件與使用情境選擇策略。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q7, C-Q5, D-Q4


### Q&A 類別 B: 技術原理類

B-Q1: i4o 的技術架構如何運作？
- A簡: 以 IndexableCollection 包裝集合，為屬性建立索引，攔截 LINQ 查詢表達式，將等值條件改用索引查找。
- A詳: i4o 透過 IndexableCollection<T> 管理「資料源 + 索引目錄」。使用 CreateIndexFor 會登錄屬性選擇器並建立鍵到項目清單的映射結構。當執行 LINQ 時，i4o 分析 Where 的表達式樹，若識別為已索引屬性的等值比較，則直接以索引定位候選，然後再套用後續運算子（如 Select）。否則回退到標準 Enumerable 實作。核心組件含：索引管理器、表達式分析器、索引結構（如字典）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q2, B-Q3, B-Q9

B-Q2: IndexableCollection<T> 內部包含哪些核心元件？
- A簡: 原始集合、索引註冊表、索引結構（鍵到項目清單映射）、查詢轉譯器。
- A詳: IndexableCollection<T> 是可列舉的包裝器，維持原集合參考與一組索引目錄。每個索引由鍵選擇器、鍵比較器、映射（Dictionary<TKey, List<T>> 或類似）構成。查詢時透過轉譯器分析 LINQ 條件，決定是否可使用索引。索引生命週期與集合綁定，可能提供建立、清除、列舉等管理介面。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q1, B-Q12

B-Q3: CreateIndexFor 如何從表達式建構索引？
- A簡: 接受屬性選擇器的表達式樹，編譯成委派取得鍵，掃描集合建立鍵到項目映射。
- A詳: CreateIndexFor(i => i.Prop) 取得一個 Lambda 表達式。i4o 可將其作為表達式樹保存以供查詢匹配，同時編譯為 Func<T, TKey> 以便在建索引時高效取鍵。建立過程掃描整個集合，將每個元素依鍵值插入對應的桶。後續查詢分析 Where 的表達式樹，若與已註冊選擇器語義匹配，則命中該索引。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q1, B-Q9

B-Q4: 為何等值查詢可達近 O(1)？
- A簡: 使用雜湊映射（Dictionary）將鍵直達項目清單，平均常數時間存取，避免線性掃描。
- A詳: 字典以雜湊表實作，將鍵經雜湊函式映射到桶位，平均情況下查找與插入皆為 O(1)。等值查詢能直接用鍵定位到候選集合（可能是一筆或多筆），大幅減少比較次數。極端碰撞或需串接其他過濾時，成本會上升，但相比 O(n) 掃描仍顯著降低。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q17, B-Q12

B-Q5: i4o 如何處理多欄位索引？
- A簡: 可為多個屬性分別建立單欄索引；查詢命中其中一個即利用對應索引。複合鍵依套件支援度。
- A詳: 以 CreateIndexFor 連續建立多個索引（Text、Number），i4o 可在查詢時選取最合適的單欄索引。若 Where 同時包含多條件，常見做法是先用其中一個索引拿到候選，再以其他條件過濾。是否支援複合鍵（如同時以 Text+Number 作索引）視套件版本與功能而定，採用前應查閱文件。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, C-Q2, D-Q7

B-Q6: 索引建立的流程與成本？
- A簡: 掃描集合 O(n)，對每筆計算鍵並插入映射；成本取決於資料量、索引數與鍵生成成本。
- A詳: 建立索引包含三步：初始化結構、掃描每筆資料以選擇器取出鍵、插入鍵到項目清單。每個索引皆需完整掃描一次，若建多索引則成本倍增。鍵為字串時可能涉及配置與比較器；為數值則較輕量。建立過程可併發優化但需注意同步與記憶體峰值。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, C-Q4, D-Q2

B-Q7: ReIndex 背後機制是什麼？
- A簡: 清除既有索引並重新掃描集合重建映射，確保索引與資料一致。
- A詳: 在自訂 IndexedList，ReIndex 會重設所有索引結構，重新遍歷資料，依鍵填充字典。此法簡單但成本為 O(n)，適合批次更新後一次性重建。若需求是高頻小改動，可考慮增量更新（新增/刪除即時調整），但實作更複雜。i4o 的索引維護機制則依其設計，可能不同於此。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, A-Q18, D-Q4

B-Q8: 自訂 IndexedList 為何只支援等值運算？
- A簡: 因其以 Dictionary 映射鍵到清單，設計即針對等值查找；範圍或模糊需其他結構。
- A詳: Dictionary 的強項在等值定位。若要支援範圍查詢（>、<）或模糊比對（Contains），需用排序結構（如平衡樹）或倒排索引等不同資料結構。為保持簡潔，自訂 IndexedList 只處理等值，其他條件回退掃描或不支援。i4o 亦以等值最佳化為主。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, A-Q9, C-Q9

B-Q9: i4o 如何把 LINQ Where 轉換為索引查詢？
- A簡: 分析 Where 的表達式樹，辨識「已索引屬性 + 等值」模式，改以索引取回候選，再應用後續運算子。
- A詳: LINQ 查詢在方法語法下以委派/表達式樹表示。i4o 讀取 Where 所接收的表達式樹，若比對到 CreateIndexFor 註冊的屬性且為二元等值比較，則繞過序列掃描，直接從索引映射取得值對應的項目集合。其餘運算子（Select、Take 等）仍交由 Enumerable 處理。若條件不匹配，則完全回退到標準 LINQ 執行。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q1, B-Q3, A-Q15

B-Q10: 記憶體索引與資料庫索引的異同？
- A簡: 兩者皆以額外結構換取查詢速度；記憶體索引在進程內、延遲低，資料庫索引持久化且功能更豐富。
- A詳: 相同點：皆以空間換時間，針對常查欄位建立輔助結構。不同點：記憶體索引只對進程內資料有效、重啟即失，適合暫態或快取；資料庫索引具持久性、可交易控制，支援更多類型（B-Tree、Hash、全文），可處理複雜查詢與大量資料。設計時可結合兩者：服務端以資料庫索引粗篩，進程內再以記憶體索引快取熱資料。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q3, B-Q12, D-Q3

B-Q11: 什麼是索引一致性與更新策略（即時 vs 延後）？
- A簡: 一致性指索引反映資料真實狀態。即時更新成本高但正確；延後重建成本低但短期可能不準。
- A詳: 若每次資料變更都同步更新索引，查詢永遠正確，但寫入成本上升。延後（lazy/batch）策略將多次更新合併，定期或事件觸發重建，降低總成本，但在窗口期內索引與資料可能不一致。選擇策略需考量讀寫比例、可容忍的一致性延遲與系統負載。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q18, B-Q7, D-Q4

B-Q12: 索引數量與記憶體用量的權衡？
- A簡: 索引越多，記憶體與建置成本越高；只替高收益欄位建索引是關鍵。
- A詳: 每新增一個索引，需為每筆資料保存至少「鍵 + 參考」的額外空間，並花費一次完整掃描時間。過多索引會放大記憶體佔用並延長啟動/重建時間。實務上應以查詢統計（頻率、延遲目標）挑選少數高價值鍵，並定期審視是否仍具效益。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, C-Q6, D-Q3


### Q&A 類別 C: 實作應用類

C-Q1: 如何把 List<Foo> 轉為可索引集合並建立索引？
- A簡: 以 ToIndexableCollection 包裝，再用 CreateIndexFor 對屬性建立索引即可。
- A詳: 步驟：1) 準備 List<Foo>。2) 轉為 IndexableCollection<Foo>。3) 對常查欄位建索引。程式碼： 
  - var list3 = list1.ToIndexableCollection<Foo>();
  - list3.CreateIndexFor(i => i.Text).CreateIndexFor(i => i.Number);
  注意：建立索引需時間與記憶體，建議只對高頻等值查詢的欄位建立。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q10, B-Q6

C-Q2: 如何針對多個屬性建立索引（例如 Text 與 Number）？
- A簡: 鏈式呼叫 CreateIndexFor，多次為不同屬性建索引。
- A詳: 實作步驟：1) 轉為 IndexableCollection。2) 連續呼叫 CreateIndexFor。程式碼：
  - var ix = list1.ToIndexableCollection<Foo>();
  - ix.CreateIndexFor(x => x.Text).CreateIndexFor(x => x.Number);
  最佳實踐：依查詢統計選擇欄位，避免過多索引；每次建立索引都會完整掃描，注意時間成本。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q5, A-Q7, B-Q12

C-Q3: 如何以 i4o 執行等值查詢並取回結果清單？
- A簡: 在已索引屬性上使用 where x.Prop == value，並以 ToList 觸發執行。
- A詳: 具體作法：1) 確保已對目標屬性建索引。2) 使用查詢運算式或方法語法撰寫條件。3) 以 ToList() 取得結果。程式碼：
  - var result = (from x in ix where x.Text == "888365" select x).ToList();
  注意：若條件未命中索引，將退回線性掃描；可先以小資料驗證正確性，再以 Stopwatch 量測效能。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, A-Q14, B-Q9

C-Q4: 如何量測「建索引」與「查詢」的時間？
- A簡: 用 Stopwatch 分段量測，ToList 觸發查詢執行，分開輸出時間。
- A詳: 步驟：1) timer.Restart(); 建索引；輸出 timer.Elapsed。2) timer.Restart(); 執行查詢並 ToList(); 輸出耗時。程式碼：
  - timer.Restart(); ix.CreateIndexFor(x=>x.Text); Console.WriteLine(timer.Elapsed.TotalMilliseconds);
  - timer.Restart(); (from x in ix where x.Text=="888365" select x).ToList(); Console.WriteLine(timer.Elapsed.TotalMilliseconds);
  注意：預熱一次排除 JIT；重複多次取平均。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, D-Q8, A-Q14

C-Q5: 新增/移除項目後如何維護索引？
- A簡: 自訂 IndexedList 以 ReIndex 重建；i4o 依實作可能自動同步或需重新建立索引。
- A詳: 若使用自訂 IndexedList，批次更新後呼叫 list2.ReIndex() 重建。i4o 的維護方式視版本而定：有的在集合變動時同步更新索引，有的需「重新建立」或提供清除/重建機制。建議批次更新完畢再重建索引，以降低成本；並以測試驗證查詢正確性與效能。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q7, D-Q4

C-Q6: 如何選擇應建立索引的欄位？
- A簡: 根據查詢頻率、等值比例、選擇性與值分佈挑選，常查且分佈均勻者優先。
- A詳: 實務指引：1) 以日誌或計量找出最常見的等值查詢欄位；2) 避免低選擇性（如布林）與熱點值過多的欄位；3) 控制索引數量與記憶體；4) 定期重估效益。程式碼無需變更，只需針對選定欄位呼叫 CreateIndexFor。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, B-Q12, D-Q3

C-Q7: 如何回退到未索引查詢以做對照測試？
- A簡: 對原始 List<T> 執行相同查詢，或以未建立索引的集合作基準。
- A詳: 維持一份原始集合 list1，對其執行相同 LINQ 查詢作為對照。程式碼：
  - var baseline = (from x in list1 where x.Text=="888365" select x).ToList();
  確保兩者結果一致，再比較時間。這是驗證最佳化是否改變語義與量測效益的基本步驟。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, C-Q4, D-Q8

C-Q8: 如何與自訂 IndexedList 比較與切換？
- A簡: 自訂 IndexedList 需 ReIndex；i4o 使用 CreateIndexFor。以相同查詢驗證正確與效能。
- A詳: 比較流程：1) list2.AddRange(list1); list2.ReIndex(); 執行查詢。2) list3 = list1.ToIndexableCollection(); list3.CreateIndexFor(...); 執行查詢。3) 比對結果與耗時。切換策略：若要快速上線且少維護，偏向 i4o；若需求極簡且可控，可用自訂 IndexedList。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q12, B-Q8

C-Q9: 面對不支援的運算子（例如 >、<、Contains）怎麼辦？
- A簡: 直接用 LINQ 執行，接受線性掃描成本；或改以等值可索引化的查詢模式。
- A詳: 當 Where 條件不屬於已索引屬性的等值比較，i4o 會回退為標準 LINQ 掃描。程式碼：
  - var r1 = ix.Where(x => x.Number > 100).ToList(); // 可能未用索引
  可行替代：1) 調整需求為等值（如以區間表或桶化等值鍵）。2) 自行實作其他索引（排序樹、倒排索引）。3) 接受掃描並優化其他環節（快取、分割集合）。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q9, B-Q8, D-Q5

C-Q10: 如何在專案中引入 i4o 套件？
- A簡: 透過 NuGet 搜尋並安裝 i4o（Indexes for Objects）套件，引用後即可使用擴充方法。
- A詳: 步驟：1) 在專案中開啟 NuGet 套件管理器。2) 搜尋「i4o」或「indexes for objects」。3) 安裝套件並確認命名空間引用。4) 對集合呼叫 ToIndexableCollection 與 CreateIndexFor。注意：不同版本 API 可能略有差異，安裝後參考 README/文件進行對照與測試。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, C-Q1, C-Q2


### Q&A 類別 D: 問題解決類

D-Q1: 查詢很慢怎麼辦（疑似未使用索引）？
- A簡: 確認已對目標屬性建立索引、條件為等值並正確觸發執行；以 Stopwatch 驗證。
- A詳: 症狀：Where 等值查詢仍需長時間。原因：未建索引、條件不匹配、未觸發執行。解法：1) CreateIndexFor 正確建立索引；2) 條件為 x.Prop == value；3) 使用 ToList/Count 觸發；4) 用小樣本驗證正確再量測。預防：為常用查詢欄位預先建索引，建立效能測試。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q1, C-Q3, C-Q4

D-Q2: 建立索引時間過長怎麼辦？
- A簡: 減少索引數量、挑選高收益欄位、於離峰批次建置，並考慮預熱或持久化快取。
- A詳: 症狀：CreateIndexFor 耗時明顯。原因：資料量大、索引太多、鍵生成昂貴。解法：1) 僅建立關鍵索引；2) 分批或背景建置；3) 降低鍵成本（避免昂貴計算/轉換）；4) 啟動時預熱一次。預防：依統計定期調整索引集，控制記憶體與啟動時間。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q6, B-Q12

D-Q3: 記憶體暴增或不足怎麼辦？
- A簡: 限制索引數量、針對高價值鍵建立、視需要釋放或重建索引，並監控記憶體。
- A詳: 症狀：建立索引後工作集飆升。原因：多索引、鍵為大型物件、資料量過大。解法：1) 只留關鍵索引；2) 使用較輕鍵（數字優於長字串）；3) 分片資料或採用外部儲存；4) 監控並在閒時釋放索引。預防：容量規劃、壓力測試、限制最大索引數。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q12, C-Q6, A-Q7

D-Q4: 查無資料但應該有（索引不同步）怎麼處理？
- A簡: 重建或同步索引；自訂 IndexedList 呼叫 ReIndex；驗證資料與索引一致性。
- A詳: 症狀：直接掃描可找到資料，但索引查詢返回空。原因：資料更新後未同步索引。解法：1) 自訂 IndexedList 執行 ReIndex(); 2) 若 i4o 提供重建機制，重新建立索引；3) 檢查更新流程是否遺漏同步。預防：建立更新策略（即時或批次）、在批次後自動重建索引。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, A-Q18, B-Q7

D-Q5: 條件不支援或效能不佳（>、<、Contains）？
- A簡: 接受回退掃描或改寫需求為可索引的等值查詢；必要時自建其他索引結構。
- A詳: 症狀：範圍/模糊查詢速度慢。原因：i4o 主要優化等值，其他運算未命中索引。解法：1) 直接用 LINQ 掃描；2) 改以等值桶化鍵；3) 自行引入排序樹或倒排索引。預防：事前評估查詢型態，對無法索引化的需求做快取或離線計算。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q9, C-Q9, B-Q8

D-Q6: ReIndex 後效能仍差？
- A簡: 檢查是否命中索引、是否建立過多索引、是否有額外過濾或投影造成成本。
- A詳: 症狀：重建索引後查詢仍慢。原因：查詢條件未用到索引、索引過多拖累建置、後續運算（如排序）主導成本。解法：1) 確認條件為等值且屬性已建索引；2) 簡化查詢與投影；3) 減少索引數量；4) 以 Profiling 找出瓶頸。預防：建立效能基線，逐步變更並量測。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q4, A-Q9, B-Q5

D-Q7: 多索引之間選擇錯誤或衝突怎麼辦？
- A簡: 觀察查詢模式，優先建立最常用且選擇性高的索引，避免冗餘與熱點。
- A詳: 症狀：建立多個索引卻未見加速或表現不穩。原因：索引未被使用、低選擇性、值分佈偏斜。解法：1) 以統計資料挑選索引；2) 移除低效索引；3) 若條件多個等值，先以選擇性最高的索引取候選。預防：定期審視查詢分佈與命中率。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, B-Q5, C-Q6

D-Q8: Stopwatch 測量結果不穩定怎麼辦？
- A簡: 進行預熱、重複多次取平均、隔離外部干擾，並確保用 ToList 觸發執行。
- A詳: 症狀：每次量測差異大。原因：JIT、GC、背景工作、延遲執行未觸發。解法：1) 預熱一次；2) 多次量測取平均與標準差；3) 在相同環境執行，關閉干擾；4) 使用 ToList/Count 觸發查詢。預防：建立簡單基準腳本，固定資料集與流程。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, A-Q14, C-Q4

D-Q9: 查詢回傳重複或遺漏資料？
- A簡: 檢查資料更新與索引同步、索引鍵選擇器是否正確，必要時重建索引。
- A詳: 症狀：結果與預期不符。原因：索引不同步、鍵選擇器錯誤（指向錯屬性或可變值）、資料相等比較器不當。解法：1) 驗證選擇器；2) 重建索引；3) 如需自訂比較器，正確提供 IEqualityComparer。預防：為索引鍵選擇不可變、穩定欄位，並加入資料與索引一致性測試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, B-Q3, C-Q5

D-Q10: 與多執行緒/PLINQ 一起使用的注意事項？
- A簡: 確保索引建立與更新在安全時機進行，查詢期間避免同時變異，必要時加鎖或使用快照。
- A詳: 症狀：並行查詢/更新導致例外或結果不一致。原因：索引非執行緒安全、讀寫競爭。解法：1) 在只讀快照上並行查詢；2) 更新時以鎖定或版本切換避免讀寫衝突；3) 索引重建採替換策略；4) 測試 PLINQ 與 i4o 相容性。預防：明確界定「建索引/更新」與「查詢」的生命週期，不同階段使用不同實例。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q18, B-Q11, C-Q5


### 學習路徑索引

- 初學者：建議先學習 15 題
  - A-Q1: 什麼是 LINQ to Objects？
  - A-Q2: 什麼是 i4o（Indexes for Objects）？
  - A-Q3: 為什麼在記憶體集合需要索引？
  - A-Q6: List<T>、IndexableCollection<T> 與自訂 IndexedList 的比較？
  - A-Q7: 建立索引的代價是什麼？
  - A-Q8: 未索引 LINQ 查詢的時間複雜度為何？
  - A-Q10: CreateIndexFor 的用途是什麼？
  - A-Q11: ToIndexableCollection<T> 作用為何？
  - A-Q14: 什麼是延遲執行？ToList 又扮演什麼角色？
  - A-Q16: 如何用 Stopwatch 正確量測效能？
  - C-Q1: 如何把 List<Foo> 轉為可索引集合並建立索引？
  - C-Q3: 如何以 i4o 執行等值查詢並取回結果清單？
  - C-Q4: 如何量測「建索引」與「查詢」的時間？
  - D-Q1: 查詢很慢怎麼辦（疑似未使用索引）？
  - D-Q8: Stopwatch 測量結果不穩定怎麼辦？

- 中級者：建議學習 20 題
  - A-Q5: i4o 與自訂 IndexedList 的差異？
  - A-Q9: i4o 主要最佳化哪些查詢條件？
  - A-Q13: 選擇 Foo.Text 與 Foo.Number 作為索引鍵的考量？
  - A-Q17: 為何等值查詢特別適合用索引加速？
  - A-Q18: 索引如何在資料更新時維護（概念）？
  - B-Q1: i4o 的技術架構如何運作？
  - B-Q2: IndexableCollection<T> 內部包含哪些核心元件？
  - B-Q3: CreateIndexFor 如何從表達式建構索引？
  - B-Q4: 為何等值查詢可達近 O(1)？
  - B-Q5: i4o 如何處理多欄位索引？
  - B-Q6: 索引建立的流程與成本？
  - B-Q8: 自訂 IndexedList 為何只支援等值運算？
  - B-Q12: 索引數量與記憶體用量的權衡？
  - C-Q2: 如何針對多個屬性建立索引（例如 Text 與 Number）？
  - C-Q5: 新增/移除項目後如何維護索引？
  - C-Q6: 如何選擇應建立索引的欄位？
  - C-Q7: 如何回退到未索引查詢以做對照測試？
  - C-Q8: 如何與自訂 IndexedList 比較與切換？
  - C-Q9: 面對不支援的運算子（例如 >、<、Contains）怎麼辦？
  - D-Q2: 建立索引時間過長怎麼辦？

- 高級者：建議關注 15 題
  - B-Q9: i4o 如何把 LINQ Where 轉換為索引查詢？
  - B-Q10: 記憶體索引與資料庫索引的異同？
  - B-Q11: 什麼是索引一致性與更新策略（即時 vs 延後）？
  - D-Q3: 記憶體暴增或不足怎麼辦？
  - D-Q4: 查無資料但應該有（索引不同步）怎麼處理？
  - D-Q5: 條件不支援或效能不佳（>、<、Contains）？
  - D-Q6: ReIndex 後效能仍差？
  - D-Q7: 多索引之間選擇錯誤或衝突怎麼辦？
  - D-Q9: 查詢回傳重複或遺漏資料？
  - D-Q10: 與多執行緒/PLINQ 一起使用的注意事項？
  - A-Q18: 索引如何在資料更新時維護（概念）？
  - A-Q15: 查詢運算式與方法語法的差異？
  - C-Q10: 如何在專案中引入 i4o 套件？
  - C-Q9: 面對不支援的運算子（例如 >、<、Contains）怎麼辦？
  - B-Q6: 索引建立的流程與成本？