# LINQ to Object #2, Indexes for Objects

## 摘要提示
- i4o 函式庫: 以外掛方式為記憶體物件集合建立索引，加速 LINQ to Object 查詢。
- 測試環境: 以 1,000,000 筆 `Foo` 物件做三種資料結構效能比較。
- List<Foo>: 無索引，純粹使用標準 LINQ，查詢時間最慢。
- 自製 IndexedList: 以 Dictionary 建索引，只支援「==」運算，需手動重建索引。
- IndexableCollection: 透過 i4o 一行 `CreateIndexFor` 指令即建索引，查詢效能最佳。
- 程式碼簡易: 將現有 `List<T>` 轉為 `ToIndexableCollection<T>()` 並指定索引欄位即可。
- 執行流程: 先建立集合，再分別量測「建立索引」與「查詢」所耗時間。
- 結果概觀: i4o 建索引速度與查詢速度皆大幅優於無索引方案。
- 適用場景: 在大量資料且重複查詢情境下，使用 i4o 可以大幅降低耗時。
- 前情提要: 延續上一篇示範，將查詢目標由 `string` 改為 `Foo` 類別。
- 簡化開發: i4o 免手寫雜湊表或樹狀結構，保留 LINQ 查詢的易讀性。

## 全文重點
作者在上一篇文章嘗試自行撰寫索引機制來加速 LINQ to Object 查詢，但做法不夠成熟。本篇遂正式介紹開源函式庫 i4o（Indexes for Objects）的使用方式與效能表現。範例以一百萬筆 `Foo` 類別物件為測試母體，分別使用三種資料結構：  
1. 傳統 `List<Foo>`，完全沒有索引；  
2. 作者先前自製的 `IndexedList`，以 `Dictionary` 建立欄位索引，但僅支援「==」條件，且需手動呼叫 `ReIndex()`；  
3. i4o 提供的 `IndexableCollection<Foo>`，可對任意屬性呼叫 `CreateIndexFor()` 自動建立索引。  

透過 `Stopwatch` 量測「建立索引」與「執行查詢」兩階段耗時後，結果顯示：  
• 無索引的 List 在 1,000,000 筆資料中搜尋單一值耗時最長。  
• 自製 `IndexedList` 查詢雖加速，但重建索引時間不容忽視，功能亦受限。  
• i4o 不僅索引建立迅速，查詢效能亦最佳，且 API 與原生 LINQ 幾乎一致，維護成本極低。  

因此，若專案需要對大量記憶體資料進行高頻率、條件單純（特別是相等比較）的查詢，導入 i4o 幾乎不需調整程式邏輯即可獲得顯著的效能提升。

## 段落重點
### 前言：從自製索引到 i4o
作者回顧前一篇文章中自行實作索引的侷限，點出需要更「上得了檯面」的解決方案，於是引入 i4o 函式庫。

### 測試設定與資料結構
改以 `Foo` 類別取代字串作為測試項目，並建立三個集合：未索引的 `List<Foo>`、自製 `IndexedList`、以及使用 i4o 的 `IndexableCollection<Foo>`，便於後續效能比較。

### 程式碼範例
展示完整 C# 程式碼：  
1. 產生隨機 `Foo` 資料並加入各集合。  
2. 對 `IndexedList` 呼叫 `ReIndex()`，對 `IndexableCollection` 分別對 `Text` 與 `Number` 建立索引。  
3. 透過 LINQ 查詢 `x.Text == "888365"` 並量測時間。

### 執行結果與分析
從輸出可見：無索引查詢最慢；自製索引在重建階段消耗時間；i4o 則在建立與查詢兩階段皆表現亮眼，證明其在實務上的可行性與優勢。

### 結論與適用場合
i4o 以最低的程式碼改動換取顯著的效能回報，適合大量資料與高頻率查詢場景。相較手動維護索引結構，i4o 讓開發者得以專注業務邏輯，同時保有 LINQ 語法的易讀性與彈性。