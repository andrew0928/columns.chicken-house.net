# 架構面試題 #5: Re-Order Messages  

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 短時間內透過 API 收到大量請求時，如何確保訊息最終依序被處理？
為每則訊息加入可判斷先後的序號（或時間戳），所有訊息先推入 Re-Order Buffer。  
‧ 若序號正好是下一筆待處理的值，立即送出執行。  
‧ 若序號落後或跳號，先暫存於 Buffer。  
‧ 之後當缺號補齊，或判定必須放棄時，再將 Buffer 內可連續的訊息依序送出；對於確認等不到的序號則發出 SKIP / DROP。如此即可在高併發、亂序甚至遺失的情況下仍保證處理順序正確。

## Q: 為什麼「了解」訊息排序機制比「從頭實作」更重要？
唯有理解 TCP 等協定背後的原理，才有能力判斷現成方案是否足夠、何時必須自行開發。當市面工具無法滿足關鍵需求時，你才具備動手重建「必要輪子」的能力；若需求單純則可直接採用現成元件，節省時間。

## Q: 設計 Re-Order Buffer 時必須考量哪些核心元素？
1. 序號或時間戳：能從訊息本身判斷先後並偵測缺號。  
2. 緩衝範圍：包含最大可等待時間及 Buffer 容量上限。  
3. 處理邏輯：  
   ‑ 正常順序立即執行 (SEND_PASSTHRU)。  
   ‑ 亂序暫存，待可連續時批次送出 (SEND_BUFFERED)。  
   ‑ 超時或超量時決定 SKIP（缺訊息）或 DROP（收到但丟棄）。

## Q: Buffer 大小是不是越大越好？
不是。Buffer 過大會讓因單筆遺失而等待的整串訊息停留過久，導致延遲暴增；過小則容易頻繁 SKIP/DROP。實務上須在「延遲」與「丟棄率」之間取得平衡，選擇能滿足 SLO 的最小 Buffer Size。

## Q: SKIP 與 DROP 的差別及適用時機？
• SKIP：預期應到但遲遲未收到的序號，推斷已遺失而直接略過。  
• DROP：訊息已收到但因順序過舊、Buffer 滿或其他限制被迫棄用。兩者都會通知下游，但 SKIP 沒有實際內容可傳遞。

## Q: 若完全依賴 Push 觸發重排，可能遇到什麼問題？
當長時間沒有新訊息進來時，就無法靠 Push 事件判定超時，造成 Buffer 內訊息無限等待。實務需再加一條由高精度 Timer 觸發的管道，定期檢查並主動 SKIP / DROP 逾時訊息，才能嚴守延遲 SLO。

## Q: 小型系統是否也需要實作這套機制？
大多數小規模專案不必。只有當你負責的路徑對順序高度敏感、對延遲有明確目標，或現成中介軟體無法滿足需求時，才值得投入實作 Re-Order Buffer。

## Q: 在運行過程中應監控哪些指標 (Metrics)？
常用指標包含：  
1. 每秒 Push / SEND / DROP / SKIP 次數  
2. Buffer 最大使用量  
3. 因 Buffer 造成的平均與最大延遲  
4. DROP 率 (%)  
透過這些數據可及時判斷延遲是否超標、Buffer 是否過大或過小，以及訊息完整性是否符合預期。

## Q: 相較於僅依賴 Message Queue 維持順序，Re-Order Buffer 有何優勢？
Message Queue 在寫入時即固定順序，若來源端已亂序便難以補救。Re-Order Buffer 位於消費端，能動態重排、部分捨棄或補位，不僅對亂序與遺失更具彈性，也能根據 SLO 在「延遲」與「完整性」間做出即時取捨。