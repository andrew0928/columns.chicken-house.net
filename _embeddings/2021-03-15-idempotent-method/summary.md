# [分散式系統 #1] Idempotency Key 的原理與實作 - 能安全 Retry 的 API 設計

## 摘要提示
- 分散式系統挑戰: 在不可靠網路環境下，如何確保遠端呼叫「只執行一次」是設計重點  
- Retry 機制: 連線中斷時，客戶端是否該再次呼叫 API 是常見兩難  
- Idempotent 定義: 相同請求重複執行，對系統狀態影響僅發生一次  
- Idempotency Key: 透過唯一鍵識別每次業務請求，伺服端避免重複執行  
- 業務重要度: 金流、訂單等高價值操作特別需要 Idempotent 防護  
- API 設計原則: 於協定層面就支援安全重試，優於事後補救  
- Server-side Cache: 利用暫存或資料庫鎖定記錄執行結果，快速判斷重複呼叫  
- 客戶端實作: 為每次商業動作產生 GUID，並在重試時沿用相同 Idempotency Key  
- 風險與限制: Key 保存期限、儲存成本、邊界條件需事先評估  
- 微服務經驗談: API 化後的「簡單事」變複雜，本質是分散式系統的坑

## 全文重點
本文討論在分散式系統或微服務架構中，於不可靠網路環境下進行遠端呼叫時，如何確保一次且僅一次的執行結果。作者以「呼叫扣款 100 元 API」為例，說明當連線中斷、客戶端無法得知結果時是否應重新呼叫的困境。核心概念是「冪等性（Idempotent）」，意指同一請求無論被執行多少次，對系統狀態影響僅計一次。為實作冪等操作，最常見方法是引用「Idempotency Key」：客戶端在每一次商業動作中產生一組全球唯一識別碼，於 HTTP Header 或 Request Body 夾帶，伺服端收到請求後先檢查資料庫／快取是否已有相同 Key 的執行紀錄，若有則直接回傳既有結果，若無才真正執行並將結果寫入儲存層。此一模式讓客戶端能安全地進行 Retry，而後端也避免重複扣款、重複建立訂單等問題。文章亦提醒，Idempotency Key 的保存期限、儲存成本以及邊界條件（例如 Key 撞號、長時間未使用的 Key 清理）都需仔細設計；同時，最好在 API 一開始就將冪等策略納入規格，而非事後以補丁方式解決。作者以多年微服務落地經驗，點出網路不穩定、工程師習慣直連資料庫等痛點，強調分散式思維的重要性。

## 段落重點
### 前言: 分散式系統的常見難題
在單體應用中，一次資料庫交易即可完成的事，搬到分散式或微服務後變成多個節點透過 HTTP 溝通，網路延遲、封包遺失、節點故障皆可能發生。工程師若忽略這些不穩定因素，就會在金流、訂單等關鍵流程踩坑；因此「如何保證遠端呼叫只執行一次」成為分散式系統設計必修課。

### Retry? 我應該要重新呼叫 API 嗎?
當客戶端在呼叫 API 後未收到結果，常見做法是重試；然而若伺服端其實已成功處理，再重試就可能造成重複扣款、重複下單。此段分析網路斷線、逾時、5xx 例外等情境，以及不同 HTTP Idempotent 動詞(GET/PUT)並不足以涵蓋業務層冪等需求的困境。

### 關鍵字: Idempotent 的定義與原理
Idempotent 在數學與電腦科學定義為「f(f(x)) = f(x)」。應用到 API，即同一請求重送 n 次系統仍保持單一結果。作者解析 GET、DELETE、PUT 等天生冪等的 HTTP 動詞，並說明 POST 需輔以額外設計才能做到業務層冪等。

### 設計原生支援 Idempotent Safe 的 API
此段提出設計準則：1) 每筆「業務行為」產生唯一識別 Idempotency Key；2) 伺服端於資料庫建立 Key-Result 對映表，並以事務或悲觀鎖確保同時只有一筆寫入；3) API 回傳需攜帶相同 Key，方便用戶端對照；4) 定義 Key 的保存時間及清理策略。如此一來，用戶端能放心 Retry，而服務端只需回傳既有結果。

### 額外附加的 Idempotency Key 保護機制
若要進一步提升可靠性，可在反向代理或 API Gateway 層加入 Key 檢查與快取，讓重複請求在進入業務服務前即被擋下；對高併發場景，可使用 Redis setnx、分布式鎖減少資料庫寫入壓力。作者亦建議在觀測層收集 Key 重複率、錯誤率，迅速偵測不當重試或攻擊行為。