# 微服務架構 #2, 按照架構，重構系統

## 摘要提示
- 單體拆分: 文章說明如何將大型單體式系統透過重構逐步拆成多個獨立微服務。  
- 重構目的: 在服務化之前先釐清「為何而改」，以利後續設計與維運。  
- Factory+Proxy: 建議以 Factory 與 Proxy Pattern 建構可替換的模組界面，降低耦合。  
- 三階段演進: 以會員模組為例，展示從內嵌、共用函式庫到獨立服務的演進流程。  
- SDK 包裝: 對外服務應搭配 SDK，降低各平台直接操作 HTTP API 的複雜度。  
- 雙軌驗證: 透過本地與遠端兩版本同時執行並比對結果，快速揪出重構錯誤。  
- 單元測試: 搭配 Assert 與單元測試機制，建立多層防護確保功能一致。  
- 技術債: 先償還技術債並改善程式體質，再導入微服務，減少後期維護痛苦。  
- 漸進式轉移: 以不修改呼叫端程式碼的方式，無痛切換到新服務。  
- 經驗分享: 作者以實務經驗示範「重構先行」的微服務落地策略。

## 全文重點
本文延續前篇微服務概念，聚焦「如何從單體式系統走向微服務」。作者指出，微服務其實是更進一步的模組化，若原始程式碼缺乏良好結構，貿然拆分只會放大問題。因此第一步必須是重構。重構前先訂出目標與服務邊界，接著透過 Factory 與 Proxy Pattern 把核心功能抽離，建立「高內聚、低耦合」的程式架構。文章以會員機制為範例，示範系統典型演進：1) 只有單一系統時會員邏輯散落各處；2) 多套系統共用時先抽成函式庫；3) 規模再大則升級成獨立會員服務。過程中呼叫端完全透過抽象介面存取，切換只需調整 Factory，達到「無痛轉移」。  
在服務化階段，作者利用 ASP.NET Web API 建立遠端服務，並以 SDK 封裝 HTTP 呼叫提升易用性。同時導入「雙重驗證」技巧：撰寫 Debug 版本讓本地實作與遠端服務同時計算並用 Debug.Assert 比對結果，搭配單元測試，大幅降低除錯成本。作者最後強調：微服務不是銀彈，先做好重構、體質健康後再拆分，才能真正受惠。下一篇將進一步討論如何劃分服務邊界。

## 段落重點
### 前言
文章先回顧微服務好處，提出真正困難並非「把系統切開」而是「怎麼切」。作者主張所有改造前都應先重構，不但降低日後維護成本，也為服務化打好基礎。

### 一定要做的事: 程式碼重構
強調重構前需釐清目的，再依序執行：1) 架構設計確認欲切割模組；2) 用 Factory+Proxy 調整程式結構；3) 將模組獨立成服務；4) 透過單元測試與雙重驗證確保正確。以會員登入散落於各處為例，說明若不先重構就服務化將帶來偵錯困難。

### STEP 1 決定架構，訂定重構的目標
點出技術債與 Time-to-Market 常使系統一開始缺乏架構。當業務成長、系統增多時，技術主管需規劃取出共用模組（例如會員系統）。系統通常歷經三階段：單體、共用函式庫、獨立服務；重構目標即是為後兩階段鋪路。

### STEP 2 重構目標 - 模組化
示範如何把會員邏輯重構成 DLL。透過 Factory 取得對應實作，並以 abstract class 達成高內聚低耦合。此設計同時支援日後擴充 Remote 實作而不影響呼叫端，符合開放封閉原則。

### STEP 3 重構目標 - 服務化
當需求進一步擴大，會員機制需獨立為服務。作者以 ASP.NET Web API 實作 server 端，再寫 SDK 封裝 HTTP 呼叫。呼叫端僅透過抽象介面存取，Factory 由回傳 Local 實作改為回傳 Remote 實作，完成無痛轉移。

### STEP 4 確保服務化過程的正確性
分散式除錯成本高，作者引用《Writing Solid Code》的雙版本驗證概念：在 Debug 模式同時執行 Local 與 Remote 版本並用 Debug.Assert 比對結果，任何不一致立即被捕捉。此法與單元測試互補，共同降低瑕疵流入正式環境的機率。

### 總結: 切割為微服務的實作案例
作者分享個人經驗，證實「先重構再服務化」最可靠。此流程先償還技術債、確保代碼質量，再漸進式拆分功能，能兼顧穩定性與可維護性。下一篇將聚焦服務邊界如何劃分，敬請期待。