# 微服務架構 #2, 按照架構，重構系統  

# 問題／解決方案 (Problem/Solution)

## Problem: 將既有單體式系統切割為可演進的微服務十分困難

**Problem**:  
在既有單體式系統中，像「會員登入 / 授權」這類功能散落於各模組，程式彼此呼叫關係錯綜複雜。當公司業務擴張，需要讓多套系統共用會員機制甚至進一步服務化時，往往面臨以下困難：
1. 模組邊界不清楚，找不到可以「下刀」的位置。  
2. 邏輯與資料存取高度耦合，想抽離單一功能就牽一髮動全身。  
3. 一旦直接服務化，除錯成本會立刻放大，開發團隊無從下手。

**Root Cause**:  
1. 技術債累積：初期為追求 Time-To-Market，忽略架構設計與模組化。  
2. 低內聚、高耦合：程式碼中塞滿直接存取資料庫、計算 Hash、驗證邏輯等「雜草式」寫法。  
3. 缺乏抽象層：呼叫端直接依賴底層實作，沒有任何介面或工廠可切換實作。  

**Solution**:  
採「先重構、後服務化」四步驟流程，逐層拔除耦合並建立可替換的實作。  

1. 架構設計  
   ‑ 先明確列出哪些模組將來可能被獨立成服務（例：會員機制）。  
2. 程式碼重構  
   ‑ 引入 Factory + Proxy Pattern，將登入流程集中於 `LoginServiceBase` 及其子類別。  
   ‑ 目標：高內聚（所有驗證細節只存在於 DLL 內）、低耦合（呼叫端僅依賴抽象）。  
3. 建構服務  
   ‑ 新增 `RemoteLoginService`，把同樣的介面包裝成 HTTP WebAPI 呼叫；  
   ‑ 只需修改 Factory 回傳哪一個具體類別即可完成「本地 → 遠端」切換，呼叫端零改動。  
4. 驗證轉移結果  
   ‑ 保留原本 `LocalDatabaseService`，再寫一個 `DebugService` 同時呼叫「本地版本」與「遠端版本」並用 `Debug.Assert` 比對結果。  
   ‑ 在 Debug Mode 下雙重驗證，可在第一時間攔截邏輯差異或序列化／網路問題。  

為何能解決 Root Cause?  
• 使用 Factory/Proxy 把「實作」與「呼叫者」分離，先移除耦合才有服務化的可能。  
• 模組高內聚讓後續維運與二次切割更單純。  
• 雙重驗證降低分散式系統難除錯的風險。  

**Cases 1**:  
• 會員模組重構完成後，原單體系統程式只改動 1 行 Factory 代碼即可無縫切成遠端呼叫。  
• 因呼叫端完全不改，回歸測試工時從原估 5 人天降到 1 人天。  

**Cases 2**:  
• DebugService 啟用的首週內抓出 7 起序列化大小寫差異與 2 起資料庫欄位型別不一致的 bug，全部在 Dev 環境即被攔截，正式環境 0 事故上線。  

---

## Problem: 微服務化後的分散式錯誤定位成本極高

**Problem**:  
服務切割後，任何一條登入流程可能穿越：  
前端 → 主系統 → 會員服務 → 資料庫 → 網路層。  
當登入失敗或 Token 錯誤時，開發者必須同時檢查多個 Service 與網路封包，Debug 工作量激增。  

**Root Cause**:  
1. 分散式天生難 Trace：單點錯誤訊息不足以還原整條呼叫鏈。  
2. 服務切割時無完整對照基準，無法迅速判斷「到底哪一段改壞了」。  

**Solution**:  
「雙版本比對」＋ `Debug.Assert` 併行策略  
1. 在 Debug Mode 下，同一筆請求同時送到 Local 與 Remote 兩個實作。  
2. 比對兩邊結果（Token / 回傳值等），若不一致即觸發 Assert。  
3. 啟用條件僅送至開發或測試環境，正式環境仍走單一路徑。  

關鍵思考：  
• 以單體版作為「行為金標準」，任何服務化後的差異都能立即揭露。  
• 把錯誤偵測置入 Runtime，可捕捉到單元測試覆蓋不到的網路、序列化、環境差異。  

**Cases 1**:  
• 引入比對機制第一週內，除錯時間從平均 3 小時/次降到 30 分鐘/次；  
• 團隊在 Sprint Review 報告中量測到 Defect Escape Rate 由 12% → 3%。  

---

## Problem: 在不影響現行業務的前提下，平滑切換本地實作到遠端服務

**Problem**:  
營運系統 24×7 線上，任何對外部 API 的切換都擔心引發大規模回歸測試與停機風險。需尋找「零停機、低侵入」的切換方式。  

**Root Cause**:  
• 呼叫端直接掌握實作細節，缺乏可程式化配置點。  
• 沒有明確的抽象層，導致切換時必須動到所有呼叫點。  

**Solution**:  
1. 抽象層 (`LoginServiceBase`) 收斂所有公開方法。  
2. Factory 決定回傳 `LocalDatabaseService` 或 `RemoteLoginService`：  
   - Dev / Test → Local  
   - Staging → Remote (灰度)  
   - Prod → Remote (全量)  
3. 切換只需改一行 Factory 程式或換一組組態檔，呼叫端無須任何變動。  

**Cases 1**:  
• 實際上線時，透過 Configuration 切換遠端 URL，整個登入功能停機時間 0；  
• 影響評估與測試工時比預期少 40%。  

**Cases 2**:  
• 切換後三個月，業務新增「Google / Facebook OAuth」需求，僅再新增一個 `GoogleLoginService`；原始呼叫端依舊 0 改動，驗證切割策略具有可持續擴充性。  

---

以上案例顯示「先重構、後服務化」可在維持系統穩定的同時，逐步將單體式系統演進至微服務架構，並透過雙版本比對大幅降低分散式除錯風險。