# 微服務架構 #2, 按照架構，重構系統

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是微服務架構？
- A簡: 以小型自治、可獨立部署之服務組合應用，透過網路與標準介面協作。
- A詳: 微服務將大型應用拆解為多個小型、自治且可獨立部署的服務，每個服務聚焦單一業務能力。相較一般模組化只在程式碼層隔離，微服務強調網路層隔離、明確 API、資料所有權與獨立伸縮。優點是彈性擴展、獨立部署與技術多樣性；代價是分散式除錯與運維複雜度提升。因此在導入前，先以重構提升模組品質，能降低遷移風險並確保服務邊界清晰。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q4, A-Q13, B-Q14

A-Q2: 什麼是單體式架構（Monolith）？
- A簡: 所有功能與模組打包於單一部署單元，內部高耦合、共享資源。
- A詳: 單體式架構將 UI、業務邏輯、資料存取等組件包在一個應用的同一進程中部署。其優點是開發、部署與除錯初期較簡單，time-to-market 佳；缺點是模組耦合高、改動影響面大、伸縮需整體擴展，長期維護成本高。若未及時重構，技術債累積會拖慢演進，難以平滑切割成微服務。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q13, A-Q21

A-Q3: 微服務與一般模組化的差異？
- A簡: 模組化隔離在程式碼層；微服務強化為網路層隔離並獨立部署。
- A詳: 一般模組化透過命名空間、類別庫與介面，達到程式碼層的內聚與耦合控制，但仍在同一進程內。微服務則將邏輯拆至獨立進程或容器，以網路 API 通訊，擁有獨立部署與資料庫。這種隔離加強了自治與彈性，也引入網路延遲、失敗與版本協調問題，需更完善的 API 設計、觀測與測試策略。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, B-Q23, B-Q30

A-Q4: 為什麼微服務前要先做程式碼重構？
- A簡: 重構降低耦合、提升內聚，讓切割與遷移風險可控且可驗證。
- A詳: 微服務要求明確邊界與高品質接口。先重構可將散落邏輯收斂為高內聚模組，並以 Factory+Proxy 抽離依賴，使呼叫端對實作去耦合。接著只需替換工廠回傳的實作，即能平滑轉向遠端服務。配合單元測試與雙重驗證（local/remote 比對），能在迭代中持續確保正確性，顯著降低服務化後的除錯成本。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, A-Q25, B-Q1, B-Q11

A-Q5: 何謂高內聚與低耦合？
- A簡: 高內聚聚焦單一責任；低耦合減少外部依賴與變動傳染。
- A詳: 高內聚指模組內部職責一致、功能相關性高，便於理解與維護；低耦合指模組間依賴少、接口穩定，外部變動不易傳染。重構時以抽象介面與工廠取得實例，限制依賴方向；登入機制集中至獨立 DLL 即是高內聚，呼叫端僅透過抽象基底或 interface 存取即是低耦合，為後續服務化奠基。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, B-Q3, B-Q26

A-Q6: 為什麼低耦合在重構中優先？
- A簡: 低耦合確保替換實作不影響呼叫端，支撐平滑服務化。
- A詳: 服務化的關鍵是把實作位置改為「遠端」，若呼叫端與實作耦合緊密（直接查 DB、共享類別），將難以替換。先以抽象類別或介面定義 API，再用 Factory 隔離建構，確保呼叫端只依賴抽象。如此只需改工廠回傳 Remote Proxy，即完成替換，降低變更面積與風險。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, B-Q2, C-Q6

A-Q7: Factory 與 Proxy 設計模式是什麼？
- A簡: Factory集中建構邏輯；Proxy 以替身封裝跨邊界呼叫。
- A詳: Factory Pattern 將物件建立責任集中，依環境或設定回傳適當實作，以隔離呼叫端與具體類別。Proxy Pattern 以替身承擔遠端互動或昂貴操作，對呼叫端呈現一致接口。本例以 Factory 決定回傳 Local 或 Remote 實作，RemoteLoginService 即是遠端代理，維持呼叫端程式碼不變。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, B-Q2, C-Q5

A-Q8: 何謂開放封閉原則（OCP）？
- A簡: 對修改封閉、對擴充開放，藉由抽象保護既有行為。
- A詳: OCP 要求既有程式在新增功能時不需修改核心邏輯，而能透過新增類別或配置達成擴充。實踐方法包含抽象介面、繼承與組合。本例中 LoginServiceBase 與 Factory 讓新增 Remote 實作不需改呼叫端；日後再接 AD/OAuth 亦可延伸實作，不改既有客戶端代碼。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q6, B-Q14, C-Q2

A-Q9: 什麼是服務邊界？為何重要？
- A簡: 定義服務責任與資料所有權邊界，避免耦合與重疊。
- A詳: 服務邊界界定了服務的職責範圍、對外公開的 API 與所擁有的資料。邊界清晰可避免跨服務共享資料表與隱式耦合，促進獨立部署與演進。本例將會員驗證抽離為專屬服務與資料庫，提供統一登入 API，避免應用各自操作會員表，提升一致性與安全性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q16, D-Q10

A-Q10: 什麼是會員服務（Login Service）？
- A簡: 專責身分驗證與授權資料處理的獨立服務與 API。
- A詳: 會員服務聚焦帳號、密碼雜湊、登入驗證與 Token 簽發等職責，擁有自己的資料庫與 Web API，供多系統重用。好處是集中安全邏輯、標準化介面並可獨立伸縮；同時透過 SDK 封裝 HTTP 細節，降低各平台接入成本，確保一致驗證策略。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q7, B-Q8, C-Q4

A-Q11: SDK 與 HTTP API 的關係與差異？
- A簡: API 定義通訊協定；SDK 封裝 API 提供原生開發體驗。
- A詳: HTTP API 是跨平台通訊契約，描述路由、參數與回應格式；SDK 是針對特定語言的套件，將 HTTP 細節（序列化、重試、錯誤處理）封裝為原生方法。本例以 RemoteLoginService 封裝 /api/login，呼叫端只用方法，不需處理 HTTP 細節，降低接入門檻與錯誤率。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q9, C-Q5, D-Q3

A-Q12: 何謂重構的目的？
- A簡: 為修正設計缺陷或達成新架構目標而調整結構。
- A詳: 重構並非改功能，而是改善內部設計以支撐未來目標，例如降低複雜度、隔離責任、為服務化鋪路。先釐清目標（如切出會員服務）、擬定方案（Factory+Proxy）、再逐步實施（模組化→服務化→驗證），讓每步變更可測、低風險且可回退。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q25, B-Q1, C-Q1

A-Q13: 從單體到微服務的演進路徑是什麼？
- A簡: 單體內嵌→共用 Library+DB→獨立服務+API+自有資料庫。
- A詳: 常見三階段：1) 單體內嵌：功能散落各處；2) 共用 Library+共用 DB：以 DLL 標準化行為，呼叫端依賴抽象；3) 獨立服務：抽出成 Web API 與專屬資料庫，透過 SDK 接入。每階段以低耦合與一致 API 為原則，確保下一階段可平滑遷移。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q4, C-Q2, C-Q4

A-Q14: 為什麼微服務提高除錯難度？
- A簡: 分散式通訊、多服務互動與網路不確定性增加定位難度。
- A詳: 微服務引入多進程、多節點、多協定，錯誤可能來自呼叫端、被調服務、網路或資料一致性。傳統單體只需一個 debugger；服務化需跨服務追蹤、觀測與比對。本例以雙重驗證（Local/Remote 同步執行比對）在 debug 模式提早抓出偏差，降低除錯成本。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q11, B-Q12, D-Q3

A-Q15: 單元測試與 Debug.Assert 的差異？
- A簡: 單元測試離線驗證；Debug.Assert 在執行期即時校驗。
- A詳: 單元測試在開發/測試環境離線執行，覆蓋功能與邊界情況；Debug.Assert 內嵌於程式，在 debug 版 runtime 即時檢查不變式與前後條件。本例以 DebugService 在調用同一 API 時同跑 Local/Remote 並以 Debug.Assert 比對結果，補足測試盲區，兩者互補非互斥。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q11, B-Q12, C-Q8

A-Q16: 什麼是雙重驗證技巧（兩版本比對）？
- A簡: 同時執行兩套實作並比對結果，以即時發現偏差。
- A詳: 受「Writing Solid Code」啟發，先有正確但笨的版本，再引入最佳化版本；在 debug 模式同時跑兩者，逐項比對。對微服務遷移而言，Local 與 Remote 屬兩實作，透過 DebugService 雙跑並 Debug.Assert，能第一時間偵測行為不一致，縮短定位時間與降低風險。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q11, C-Q7

A-Q17: 為什麼要提供前端 SDK？
- A簡: 降低接入門檻、統一實作細節、減少重複與錯誤。
- A詳: 各語言客戶端若直接呼叫 HTTP，需重複處理序列化、重試、錯誤轉譯與安全細節，易出現不一致。SDK 將 API 封裝為語言原生呼叫，集中處理共通能力（如雜湊、重試策略、版本檢查），提升體驗與一致性。本例的 RemoteLoginService 即為簡化呼叫端的 SDK 實作。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, B-Q9, C-Q9

A-Q18: 何時不該急著微服務化？
- A簡: 體質未重構、邊界不清、測試不足時，應先穩基再拆。
- A詳: 若系統充滿散落邏輯、共用資料表、缺乏測試與觀測，貿然拆分只會放大問題。應先重構：集中職責、以抽象隔離依賴、建立測試與觀測；再評估邊界與流量熱點，分批切出價值高且風險可控的服務。否則維護成本會因複雜度疊加而失控。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q4, A-Q9, A-Q25

A-Q19: 何謂技術債？為何要償還？
- A簡: 為趕工而留下的設計欠缺，需逐步重構返還成本。
- A詳: 技術債指為快速交付而做的短期取捨（耦合、缺測試、硬編碼等）。短期能快上線，但長期會放大維護成本與風險。透過計畫性重構（模組化、測試自動化、API 穩定化），在合適時機償還，避免系統演進被債務綁死，影響微服務化的可行性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q12, A-Q18, A-Q25

A-Q20: 抽象類別與介面在此案例的角色差異？
- A簡: 抽象類別提供共用實作；介面只定義契約更利於擴展。
- A詳: 抽象類別（LoginServiceBase）可內建共用邏輯（如 ComputePasswordHash 與 UserLogin），減少重複；介面更輕量，適合跨語言與多實作場景。早期用抽象類別加速重構；成熟後改以 interface 穩定契約，讓多框架與語言實作更彈性。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q3, B-Q14, C-Q2

A-Q21: 何謂 API 規格的一致性（如密碼雜湊）？
- A簡: 規範參數與處理算法，跨實作結果一致可互換。
- A詳: API 規格需定義輸入、輸出與演算法關鍵點，使各實作（Local/Remote）遵守一致行為。本例雜湊算法應納入規格，不可隨意更動，否則 Local/Remote 結果會偏差。清晰規格是雙跑比對能成功的前提，也是跨系統協作的基礎。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q13, D-Q5

A-Q22: 重構的四步驟是什麼？
- A簡: 架構設計→程式碼重構→建構服務→驗證轉移。
- A詳: 1) 架構設計：明確目標與切割策略；2) 程式碼重構：用 Factory+Proxy 降耦合、提內聚；3) 建構服務：抽成 Web API，資料庫與服務獨立；4) 驗證轉移：以單元測試與雙跑比對確保一致性。此節奏可逐步交付，風險可控且可回退。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q4, A-Q13, B-Q11

A-Q23: 為什麼以會員服務為示例切割？
- A簡: 橫切關注、通用性高且邊界相對清晰，易先抽離。
- A詳: 會員驗證屬多系統共用的橫切關注點，職責集中（登入、雜湊、Token 簽發），易於抽出統一 API 與 SDK，且對使用者有明顯價值。先從此類邊界清晰模組下手，能快速驗證方法論與基礎設施，建立團隊信心與實作範式。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, A-Q10, C-Q4

A-Q24: 為什麼重構時要「可延伸到服務化」？
- A簡: 避免未來重工，確保當需求成長時平滑演進。
- A詳: 重構若只解決當下，日後服務化仍需大改。以 Factory+抽象契約將依賴剝離、對外統一入口，當需求擴大時，只需替換工廠回傳實作與部署服務，即可接上遠端，最大化早期投資回報並降低變更衝擊。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, C-Q6, B-Q10

A-Q25: 何謂「先重構再服務化」的核心價值？
- A簡: 以可測、可控的小步快跑方式降低拆分風險與成本。
- A詳: 「先重構」透過內聚與抽象，收斂散落邏輯、建立穩定 API 與測試網；「再服務化」只替換實作位置，由 Local 轉 Remote。雙跑比對與單元測試確保一致性，遇到問題可回退 Local，將風險拆解於每一步。此策略是低風險落地微服務的可複用範式。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, B-Q11, C-Q7

---

### Q&A 類別 B: 技術原理類

B-Q1: Factory Pattern 在示例中如何運作？
- A簡: 工廠集中決策回傳 Local 或 Remote 實作，呼叫端不變。
- A詳: 
  - 原理: 將物件建立與選型集中於工廠，依環境或設定產出實作，隔離呼叫端與具體類別。
  - 流程: 1) 定義抽象契約；2) 工廠讀取環境/編譯條件；3) 回傳 Local 或 Remote 實作。
  - 組件: LoginServiceBase.Create、LocalDatabaseService、RemoteLoginService。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q6, C-Q2, C-Q6

B-Q2: Proxy Pattern 在本例如何落地？
- A簡: RemoteLoginService 代理遠端 API，維持一致接口。
- A詳: 
  - 原理: 以代理物件代表真實服務，封裝跨網路呼叫與序列化。
  - 流程: 1) 代理接收呼叫；2) 序列化參數、發送 HTTP；3) 解析回應、轉成領域物件；4) 傳回呼叫端。
  - 組件: RemoteLoginService、HttpClient、LoginToken。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q7, C-Q5

B-Q3: LoginServiceBase 的技術結構是什麼？
- A簡: 以抽象基底定義契約，內含共用邏輯與可覆寫行為。
- A詳: 
  - 原理: 抽象類別提供共用流程（如 UserLogin 先雜湊再驗證），將變異點抽象化（VerifyPassword）。
  - 流程: 1) 呼叫 UserLogin；2) 雜湊密碼；3) 呼叫 VerifyPassword（由實作提供）；4) 產 Token。
  - 組件: LoginServiceBase、ComputePasswordHash、VerifyPassword、LoginToken。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q20, C-Q2

B-Q4: ComputePasswordHash 設計要點是什麼？
- A簡: 規範化算法與輸入，確保跨實作結果一致可比對。
- A詳: 
  - 原理: 密碼雜湊應固定算法與鹽值策略，避免跨實作差異。
  - 流程: 1) 正規化輸入；2) 套用既定算法（如 PBKDF2）；3) 產生雜湊字串；4) 一致傳輸欄位名。
  - 組件: 雜湊算法、鹽值策略、API 規格、SDK 實作。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q21, D-Q5, C-Q5

B-Q5: 為何將 VerifyPassword 抽象化？
- A簡: 將變動點（驗證來源）延後到實作層，支援多策略。
- A詳: 
  - 原理: 不同實作驗證來源不同（DB、LDAP、遠端 API），抽象化可替換實作而不動流程。
  - 流程: 1) Base 統一流程；2) 實作覆寫 VerifyPassword；3) 依環境由工廠選用。
  - 組件: LoginServiceBase.VerifyPassword、LocalDatabaseService、RemoteLoginService。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q3, C-Q5

B-Q6: LocalDatabaseService 背後的資料流程？
- A簡: 呼叫本地資料庫核對帳密雜湊，成功後生成 Token。
- A詳: 
  - 原理: 在同進程內執行 DB 驗證，避免網路成本。
  - 流程: 1) 收到 UserLogin；2) 計算雜湊；3) 查 DB 比對；4) 成功產 Token 回傳。
  - 組件: 連線字串、ORM/SQL、使用者表、LoginToken。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q3, D-Q1, D-Q5

B-Q7: RemoteLoginService 呼叫 Web API 的流程？
- A簡: 組裝參數→POST /api/login→解析結果→回傳 Token。
- A詳: 
  - 原理: 使用 HttpClient 發送表單或 JSON，序列化與錯誤轉譯在 SDK 處理。
  - 流程: 1) 組裝 userid、passwordHash；2) PostAsync；3) 讀取回應字串；4) 新建 LoginToken。
  - 組件: HttpClient、FormUrlEncodedContent、API BaseUri、錯誤處理。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q11, C-Q5, D-Q3

B-Q8: Web API LoginController 的執行流程？
- A簡: 接收參數→驗證→生成 Token→回傳標準結果。
- A詳: 
  - 原理: 控制器作為 HTTP 邊界，負責驗證與調用服務邏輯。
  - 流程: 1) 解析 FormDataCollection；2) 檢核欄位與雜湊；3) 呼叫資料層驗證；4) 生成 Token 回傳。
  - 組件: ApiController、路由 /api/login、模型繫結、回應格式。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q4, B-Q7, D-Q3

B-Q9: SDK 封裝 HTTP API 的設計原理？
- A簡: 將通訊細節下沉 SDK，提供語言原生方法與模型。
- A詳: 
  - 原理: 將序列化、重試、錯誤轉譯、安全策略集中封裝。
  - 流程: 1) 定義方法簽章；2) 封裝 HttpClient；3) 轉換回應為領域物件；4) 錯誤與重試策略。
  - 組件: RemoteLoginService、LoginToken、錯誤對映、版本檢查。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, C-Q5, C-Q9

B-Q10: 如何切換 Local 與 Remote 實作？
- A簡: 透過工廠判斷編譯條件或設定，回傳相對應實作。
- A詳: 
  - 原理: 將切換策略集中，避免散落條件判斷。
  - 流程: 1) 讀取編譯條件/組態；2) return Local 或 Remote；3) Debug 下可回傳 DebugService。
  - 組件: LoginServiceBase.Create、編譯常數、組態檔、DI 容器（可選）。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q6, B-Q11, A-Q24

B-Q11: DebugService 雙跑比對的機制是什麼？
- A簡: 同步呼叫 Local 與 Remote，使用 Debug.Assert 比對結果。
- A詳: 
  - 原理: 在 debug 模式同時執行兩實作，若結果不一致即觸發警示。
  - 流程: 1) 工廠回傳 DebugService；2) 內部持有 Local 與 Remote；3) 同步呼叫與比對 Equals；4) 回傳 Remote 結果。
  - 組件: DebugService、LocalDatabaseService、RemoteLoginService、Debug.Assert。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, A-Q16, C-Q7

B-Q12: Debug.Assert 的角色與觸發點？
- A簡: 在 debug 版於執行期檢查不變式，偏差立即中斷提醒。
- A詳: 
  - 原理: 透過條件判斷在 runtime 驗證假設，失敗即提示。
  - 流程: 1) 設置斷言條件；2) 執行期檢查；3) 失敗彈出與記錄；4) 開發者修正。
  - 組件: System.Diagnostics.Debug、斷言訊息、日誌管道。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q11, C-Q7

B-Q13: API 規格一致性如何保障（如雜湊欄位）？
- A簡: 以契約明文化欄位與算法，並在 SDK/服務雙向校驗。
- A詳: 
  - 原理: 契約先行，將欄位名、演算法、狀態碼標準化。
  - 流程: 1) 訂定規格；2) SDK 落地、產測；3) 服務端校驗與拒絕不合法；4) 雙跑時比對一致。
  - 組件: API 規格文件、SDK 驗證器、伺服器端 Validator。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q21, D-Q5, C-Q9

B-Q14: 抽象類別轉 interface 的演進影響？
- A簡: 契約更穩定與跨語言，但需外提共用邏輯與工具。
- A詳: 
  - 原理: interface 僅定義行為，移除繼承耦合，利於多實作。
  - 流程: 1) 萃取介面；2) 共用邏輯外提為 Helper；3) 呼叫端依賴介面；4) 工廠/DI 供應實作。
  - 組件: ILoginService、HashHelper、工廠/DI、SDK。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q20, C-Q2, C-Q9

---

### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何將散落的登入程式碼重構為 Library？
- A簡: 萃取登入相關邏輯至獨立 DLL，提供抽象契約供呼叫。
- A詳: 
  - 實作步驟: 1) 搜尋登入相關方法；2) 建立 LoginServiceBase 與 LoginToken；3) 將 ComputePasswordHash、UserLogin 移入；4) 呼叫端改用抽象方法。
  - 關鍵程式碼:
    public abstract class LoginServiceBase { public virtual LoginToken UserLogin(string u,string p) {...} }
  - 注意事項: 保持公開 API 最小化；以測試覆蓋既有場景；避免直接暴露資料層。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, B-Q3, C-Q2

C-Q2: 如何設計 LoginServiceBase 與 Factory？
- A簡: Base 提供共用流程，Factory 集中回傳實作供呼叫端使用。
- A詳: 
  - 實作步驟: 1) 定義抽象 VerifyPassword；2) 在 Base 實作 UserLogin 與 ComputePasswordHash；3) 寫 Create() 讀設定決定 Local/Remote。
  - 關鍵程式碼:
    public static LoginServiceBase Create(){ return new LocalDatabaseService(); }
  - 注意事項: 先支援 Local；保留擴展點；避免在呼叫端出現 new 具體類別。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q1, B-Q5, C-Q6

C-Q3: 如何實作 LocalDatabaseService 的 VerifyPassword？
- A簡: 以安全連線查詢使用者表，核對雜湊後回傳布林。
- A詳: 
  - 實作步驟: 1) 注入連線；2) 以參數化 SQL/ORM 查詢使用者；3) 比對雜湊；4) 回傳結果。
  - 關鍵程式碼:
    protected override bool VerifyPassword(u,h){ return db.Users.Any(x=>x.Id==u && x.Hash==h); }
  - 注意事項: 防 SQL Injection；索引優化帳號欄位；記錄登入嘗試；避免回傳敏感訊息。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q6, D-Q1, D-Q5

C-Q4: 如何以 ASP.NET Web API 建立 LoginController？
- A簡: 建立 /api/login POST，解析參數後產生 Token 回傳。
- A詳: 
  - 實作步驟: 1) 新建 ApiController；2) 實作 Post(FormDataCollection)；3) 驗證必填與格式；4) 呼叫服務層，回傳 Token。
  - 關鍵程式碼:
    public IHttpActionResult Post(FormDataCollection p){ var t=svc.Login(p["userid"],p["passwordhash"]); return Ok(t); }
  - 注意事項: 回應一致格式；處理錯誤碼；限制速率與記錄日誌；禁用回傳敏感資料。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q5, D-Q3

C-Q5: 如何在 SDK 中實作 RemoteLoginService 呼叫？
- A簡: 使用 HttpClient 封裝 POST 請求，解析回應為 LoginToken。
- A詳: 
  - 實作步驟: 1) 持有 BaseUri；2) 組裝 userid、passwordHash；3) PostAsync("/api/login")；4) 解析內容建構 Token。
  - 關鍵程式碼:
    var content=new FormUrlEncodedContent(new[]{("userid",u),("passwordhash",Hash(p))}); var r=await client.PostAsync("/api/login",content);
  - 注意事項: 設置逾時與重試；標準化錯誤；避免在 SDK 硬編碼路徑，支援設定。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q7, B-Q9, D-Q4

C-Q6: 如何切換 Factory 從本機到遠端服務？
- A簡: 以編譯常數或設定檔改變 Create() 回傳類型即可。
- A詳: 
  - 實作步驟: 1) 加入組態鍵 Login.ServiceMode；2) 讀取值 local/remote；3) 回傳對應實作；4) 發布新 SDK。
  - 關鍵程式碼:
    return mode=="remote" ? new RemoteLoginService(uri) : new LocalDatabaseService();
  - 注意事項: 預設安全回退為 local；記錄切換日誌；在測試環境先驗證。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q10, A-Q24, C-Q2

C-Q7: 如何實作 DebugService 的雙跑比對？
- A簡: Debug 模式同時呼叫兩實作，使用 Debug.Assert 驗證一致。
- A詳: 
  - 實作步驟: 1) 建立 DebugService，持有 Local/Remote；2) 覆寫 UserLogin 同跑；3) 比對 Equals；4) 回傳 Remote 結果。
  - 關鍵程式碼:
    var a=remote.Login(u,p); var b=local.Login(u,p); Debug.Assert(a.Equals(b),"Login mismatch");
  - 注意事項: 僅在 Debug 啟用；避免雙寫產生成本；記錄比對差異以利分析。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q11, B-Q12, A-Q16

C-Q8: 如何撰寫單元測試覆蓋登入流程？
- A簡: 針對成功/失敗與邊界案例撰寫測試，固定雜湊結果。
- A詳: 
  - 實作步驟: 1) 建立測試資料；2) 測成功與失敗案例；3) 測無效輸入與例外；4) 驗證 Token 等值。
  - 關鍵程式碼:
    Assert.NotNull(sut.UserLogin("u","p")); Assert.Null(sut.UserLogin("u","bad"));
  - 注意事項: 固定雜湊算法；隔離資料層（用測試替身）；CI 中自動執行。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q4, D-Q9

C-Q9: 如何封裝 SDK 並發佈給多個系統？
- A簡: 打包為 NuGet/私倉套件，版本化與變更日誌清楚。
- A詳: 
  - 實作步驟: 1) 加入 nuspec/打包腳本；2) 發布至套件庫；3) 撰寫 README/API；4) 設置版本與相容性策略。
  - 關鍵程式碼: dotnet pack / dotnet nuget push
  - 注意事項: 嚴格語意化版本；標註破壞式變更；提供相容替代 API；建立發版流程與回滾機制。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q9, B-Q27, D-Q8

C-Q10: 如何在呼叫端最小改動導入新 SDK？
- A簡: 保持方法簽章不變，僅調整工廠與參考套件。
- A詳: 
  - 實作步驟: 1) 升級套件；2) 確認 LoginServiceBase API 無變；3) 呼叫端無需改碼重編即可；4) 透過設定切換 remote。
  - 關鍵程式碼: var svc=LoginServiceBase.Create(); var t=svc.UserLogin(u,p);
  - 注意事項: 先於測試環境驗證；記錄行為變化；逐批次導入並監控。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q25, C-Q6, D-Q8

---

### Q&A 類別 D: 問題解決類（10題）

D-Q1: 遇到所有登入失敗怎麼辦？
- A簡: 檢查雜湊一致性、資料庫連線與 API 狀態，分層定位原因。
- A詳: 
  - 症狀: 任一帳號皆登入失敗。
  - 可能原因: 雜湊算法不一致、DB 連線失敗、API 500、設定錯誤。
  - 解決步驟: 1) 比對 Local/Remote 雜湊；2) 測試 DB/健康檢查；3) 查服務日誌與回應碼；4) 驗證工廠回傳實作。
  - 預防措施: 將算法寫入契約；健康檢查與告警；部署前做整合測試。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q8, C-Q3

D-Q2: 本機與遠端 Token 不一致如何處理？
- A簡: 使用雙跑比對，檢查 Token 生成與等值判斷一致性。
- A詳: 
  - 症狀: Debug 模式斷言 Token 不一致。
  - 可能原因: Token 格式不同、生成規則差異、Equals 未覆寫。
  - 解決步驟: 1) 檢查 Token 結構與 Equals/HashCode；2) 校對生成規則；3) 版本鎖定 SDK 與服務。
  - 預防措施: 契約化 Token 模型；測試等值性；版本控管。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q11, C-Q7, D-Q9

D-Q3: HTTP 500 或 404 錯誤如何排查？
- A簡: 透過日誌、路由與健康檢查定位控制器、路徑與部署狀態。
- A詳: 
  - 症狀: 呼叫 /api/login 回 500/404。
  - 可能原因: 控制器異常、路由錯誤、部署版本不符。
  - 解決步驟: 1) 檢查路由設定；2) 查應用日誌與例外；3) 比對 SDK 與服務版本；4) 重試與 Fiddler/抓包。
  - 預防措施: 自動化路由測試；API 監控；Blue-Green 發布。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q7, B-Q8, C-Q4

D-Q4: 網路逾時造成間歇性失敗如何處理？
- A簡: 設逾時與重試、退避與健康檢查，必要時降級或回退。
- A詳: 
  - 症狀: 偶發逾時或連線失敗。
  - 可能原因: 網路不穩、服務壓力、DNS 問題。
  - 解決步驟: 1) 設定合理逾時；2) 指數退避重試；3) 監控延遲；4) 降級為 Local 或快取。
  - 預防措施: 壓力測試；熔斷與隔離；多區部署。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q7, B-Q29, C-Q5

D-Q5: 密碼雜湊不一致導致驗證失敗怎麼辦？
- A簡: 對齊算法、鹽值與正規化策略，確保 SDK 與服務一致。
- A詳: 
  - 症狀: Local 成功、Remote 失敗（或反之）。
  - 可能原因: 不同算法/鹽值、字元編碼差異。
  - 解決步驟: 1) 確認算法與鹽值；2) 對齊大小寫/Trim；3) 加測編碼；4) 修正 SDK/服務。
  - 預防措施: 明文化規格；契約測試；版本門檻。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, B-Q13, C-Q5

D-Q6: 工廠回傳錯誤實作類別造成行為異常？
- A簡: 驗證工廠判斷與設定，加入日誌與防呆檢查。
- A詳: 
  - 症狀: 應該用 Remote 卻跑 Local（或相反）。
  - 可能原因: 設定值錯、環境變數未生效、條件判斷疏漏。
  - 解決步驟: 1) 列印工廠決策日誌；2) 檢查設定與載入時機；3) 加入預設值與驗證；4) 修正判斷。
  - 預防措施: 啟動自我檢查；設定 schema 驗證；部署前檢核腳本。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q6, A-Q24

D-Q7: DebugService 造成效能下降如何優化？
- A簡: 僅在 Debug 啟用雙跑，壓測關閉；必要時部分路徑抽樣。
- A詳: 
  - 症狀: Debug 模式延遲增加、資源佔用高。
  - 可能原因: 雙重呼叫與資料查詢成本。
  - 解決步驟: 1) 僅 Debug 啟用；2) 抽樣比對；3) 對重查詢路徑加快取；4) 優化日誌量。
  - 預防措施: 明確編譯條件；壓測 Release 版本；設置抽樣開關。
- 難度: 初級
- 學習階段: 進階
- 關聯概念: B-Q11, B-Q12, C-Q7

D-Q8: SDK 更新後相容性問題如何解決？
- A簡: 依語意化版本回退或調整，提供相容層並更新文件。
- A詳: 
  - 症狀: 升級 SDK 後呼叫失敗或回應不符。
  - 可能原因: 破壞式變更、依賴版本不相容。
  - 解決步驟: 1) 比對 Release Note；2) 回退版本或修正呼叫；3) 若必要建相容層；4) 增加契約測試。
  - 預防措施: SemVer；Deprecation 流程；預發環境演練。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q27, C-Q9, C-Q10

D-Q9: Token 等值判斷失效如何修復？
- A簡: 覆寫等值比較與雜湊，明確定義值相等語意。
- A詳: 
  - 症狀: 同一 Token 被視為不同，或集合行為異常。
  - 可能原因: 未覆寫 Equals/GetHashCode、大小寫/空白差異。
  - 解決步驟: 1) 實作值物件等值；2) 正規化字串；3) 加入單元測試；4) 雙跑驗證。
  - 預防措施: 值物件模式；契約測試覆蓋等值性；Code Review。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: C-Q8, B-Q11, D-Q2

D-Q10: 服務化後的資料一致性問題怎麼辦？
- A簡: 明確資料所有權，避免跨服務直存，透過 API 協作。
- A詳: 
  - 症狀: 多系統對同會員資料更新互相覆蓋。
  - 可能原因: 共用資料庫、缺乏單一寫入來源。
  - 解決步驟: 1) 定義資料所有權；2) 禁止直連資料表；3) 僅經 API 更新；4) 建審計與版本控制。
  - 預防措施: DDD 邊界；寫入路徑治理；契約演進與事件通知。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q9, B-Q16, A-Q13

---

### 學習路徑索引
- 初學者：建議先學習哪 15 題
  - A-Q1: 什麼是微服務架構？
  - A-Q2: 什麼是單體式架構（Monolith）？
  - A-Q3: 微服務與一般模組化的差異？
  - A-Q4: 為什麼微服務前要先做程式碼重構？
  - A-Q5: 何謂高內聚與低耦合？
  - A-Q7: Factory 與 Proxy 設計模式是什麼？
  - A-Q8: 何謂開放封閉原則（OCP）？
  - A-Q10: 什麼是會員服務（Login Service）？
  - A-Q11: SDK 與 HTTP API 的關係與差異？
  - A-Q12: 何謂重構的目的？
  - A-Q13: 從單體到微服務的演進路徑是什麼？
  - C-Q1: 如何將散落的登入程式碼重構為 Library？
  - C-Q2: 如何設計 LoginServiceBase 與 Factory？
  - C-Q3: 如何實作 LocalDatabaseService 的 VerifyPassword？
  - C-Q10: 如何在呼叫端最小改動導入新 SDK？

- 中級者：建議學習哪 20 題
  - A-Q6: 為什麼低耦合在重構中優先？
  - A-Q9: 什麼是服務邊界？為何重要？
  - A-Q14: 為什麼微服務提高除錯難度？
  - A-Q15: 單元測試與 Debug.Assert 的差異？
  - A-Q16: 什麼是雙重驗證技巧（兩版本比對）？
  - A-Q17: 為什麼要提供前端 SDK？
  - A-Q18: 何時不該急著微服務化？
  - A-Q21: 何謂 API 規格的一致性（如密碼雜湊）？
  - A-Q22: 重構的四步驟是什麼？
  - B-Q1: Factory Pattern 在示例中如何運作？
  - B-Q2: Proxy Pattern 在本例如何落地？
  - B-Q3: LoginServiceBase 的技術結構是什麼？
  - B-Q7: RemoteLoginService 呼叫 Web API 的流程？
  - B-Q8: Web API LoginController 的執行流程？
  - C-Q4: 如何以 ASP.NET Web API 建立 LoginController？
  - C-Q5: 如何在 SDK 中實作 RemoteLoginService 呼叫？
  - C-Q6: 如何切換 Factory 從本機到遠端服務？
  - C-Q7: 如何實作 DebugService 的雙跑比對？
  - D-Q1: 遇到所有登入失敗怎麼辦？
  - D-Q3: HTTP 500 或 404 錯誤如何排查？

- 高級者：建議關注哪 15 題
  - A-Q20: 抽象類別與介面在此案例的角色差異？
  - A-Q24: 為什麼重構時要「可延伸到服務化」？
  - A-Q25: 何謂「先重構再服務化」的核心價值？
  - B-Q4: ComputePasswordHash 設計要點是什麼？
  - B-Q5: 為何將 VerifyPassword 抽象化？
  - B-Q9: SDK 封裝 HTTP API 的設計原理？
  - B-Q10: 如何切換 Local 與 Remote 實作？
  - B-Q11: DebugService 雙跑比對的機制是什麼？
  - B-Q13: API 規格一致性如何保障（如雜湊欄位）？
  - B-Q14: 抽象類別轉 interface 的演進影響？
  - C-Q8: 如何撰寫單元測試覆蓋登入流程？
  - C-Q9: 如何封裝 SDK 並發佈給多個系統？
  - D-Q2: 本機與遠端 Token 不一致如何處理？
  - D-Q4: 網路逾時造成間歇性失敗如何處理？
  - D-Q10: 服務化後的資料一致性問題怎麼辦？