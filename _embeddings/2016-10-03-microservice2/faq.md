# 微服務架構 #2, 按照架構，重構系統

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 為什麼在把單體式系統轉成微服務之前，一定要先做程式碼重構？
微服務是網路層級的強隔離，錯誤偵錯成本遠高於單體式系統。如果原本的程式碼結構已經充滿耦合與技術債，直接服務化只會讓維護困難倍增；先重構可提升高內聚、低耦合，使後續切割服務變得容易且風險較低。

## Q: 作者在「單體 → 微服務」的過程中，採取了哪些主要步驟？
1. 架構設計：先思考要改變哪些架構、哪些模組需獨立成服務。  
2. 程式碼重構：利用 Proxy 與 Factory pattern，把模組調整成高內聚、低耦合。  
3. 建構服務：將模組獨立成遠端服務，增加 remote proxy 並修改 factory，使呼叫端無痛轉移。  
4. 驗證結果：透過單元測試與雙重驗證技巧，確認轉移過程正確無誤。

## Q: 會員機制模組，從單體一路演進到獨立服務的階段劃分為何？
1. 只有一套系統：會員邏輯直接嵌在應用程式內。  
2. 少量系統共用 (N < 5)：抽成共用函式庫，並共用同一個會員資料庫。  
3. 多服務共用：會員機制獨立成專屬服務，擁有自己的資料庫與標準 API，其他系統透過 SDK 或 HTTP API 呼叫。

## Q: 為何重構時作者特別使用 Factory + Proxy 設計模式？
Factory 先隔離「取得服務實體」的邏輯，未來可在不改動呼叫端的情況下切換本地或遠端實作；Proxy 則包裝真正的服務呼叫，讓呼叫端只面對抽象介面，達成低耦合並為日後服務化鋪路。

## Q: 作者是如何在服務化過程中驗證「本地版本」與「遠端版本」行為一致？
作者實作第三個 DebugService：  
• 在 Debug 模式下，同時呼叫 LocalDatabaseService 與 RemoteLoginService。  
• 透過 Debug.Assert 比對兩個版本的結果是否一致。  
• 若不一致立即拋出警告，及早捕捉轉移錯誤。

## Q: Debug.Assert 與單元測試的差別與互補性是什麼？
單元測試於開發／測試階段、在獨立環境中執行；Debug.Assert 則嵌在正式程式碼中，只要啟用 Debug 模式就會在 Runtime 做即時比對。兩者不互斥：單元測試驗證邏輯正確性，Debug.Assert 則在實際跑程式時第一時間攔截潛在錯誤。