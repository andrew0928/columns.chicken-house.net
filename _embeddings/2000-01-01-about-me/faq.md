# 安德魯是誰?

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

Q1: 誰是安德魯 Andrew Wu？
- A簡: 91APP 首席架構師、微軟 MVP，專長 .NET、微服務、API 設計與分散式系統，持續分享技術超過 20 年。
- A詳: Andrew Wu 現任 91APP 首席架構師，長期負責核心產品的服務化與團隊架構改善。擁有超過 20 年經驗，專注 Microsoft .NET 生態、SaaS 與 B2B2C 雲端服務，擅長軟體工程、物件導向設計、分散式系統、平行處理、API 設計與微服務架構。他自 2004 年起持續寫作與公開分享，並多次擔任 DevOpsDays、.NET Conf 等大型研討會講者。自 2016 至 2025 年獲頒 Microsoft MVP，亦維運部落格與社群平台，並歡迎透過 Facebook 粉絲頁洽談演講或企業內訓。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q5, A-Q8

Q2: 什麼是首席架構師（Chief Architect）？
- A簡: 管理產品技術藍圖、架構治理與關鍵技術決策，協調跨團隊落地策略與品質屬性。
- A詳: 首席架構師負責制定與維護系統整體架構願景，確保可用性、可擴展性、安全與可維護性等品質屬性。工作包含標準制定、技術選型、跨團隊協調、風險控管與技術債治理；同時推動服務化、平台化與工程效率提升（如 CI/CD、觀測性）。亦會透過原型驗證、指導與培訓，協助團隊落實最佳實踐，並與產品、營運等利害關係人對齊技術與商業目標。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q8, B-Q7

Q3: Microsoft MVP 是什麼？
- A簡: 微軟頒發給長期貢獻社群的技術專家之獎項，肯定其分享、影響力與實作經驗。
- A詳: Microsoft Most Valuable Professional（MVP）是微軟授與非員工技術社群領袖的年度獎勵，評選標準包含技術內容品質、分享頻率、社群影響力與實務貢獻。Andrew 自 2016 至 2025 持續獲獎，代表其在 .NET、雲端與架構實務等領域具備深厚專業與長期分享。MVP 通常積極撰文、演講、參與開源或培訓，擔任產學社群橋梁，促進技術傳播與產業成長。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q24

Q4: 為何安德魯專注 .NET、SaaS 與 B2B2C？
- A簡: 因應企業雲轉型與商業整合需求，.NET 生態成熟，SaaS/B2B2C需多租戶、穩定整合與快速交付。
- A詳: 企業數位化轉型需要穩定交付與長期維運。.NET 生態在工具鏈、效能、雲整合與企業支援上成熟，適合大型團隊與長期產品經營。SaaS 與 B2B2C 服務常面臨多租戶、品牌/通路整合與高可用的挑戰，需重視 API 設計、擴展性、資料治理與自動化。專注這些領域有助在複雜商業場景中落實可持續的軟體工程與架構品質。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q18, B-Q12

Q5: 什麼是 API First？
- A簡: 先定義 API 契約再開發實作，促進跨團隊對齊、早期對接與自動化測試與文件。
- A詳: API First 是以 API 規格（如 OpenAPI）為產品的第一級產出。先定義端點、模型、錯誤碼與契約，再啟動開發並行：文件、Mock、SDK/Server Codegen、契約測試與管線管控。好處是降低誤解、早期發現整合風險、促進自治團隊同步前進，並透過 CI/CD 守護相容性。常搭配版本治理、語意化版本與變更審查流程。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q1, C-Q1, B-Q9

Q6: 什麼是 AI First？
- A簡: 以 AI 能力為核心規劃產品與流程，資料與模型治理成為一級產能與競爭力來源。
- A詳: AI First 強調以資料與模型為核心設計體驗：問題定義、資料取得與標註、特徵/提示工程、模型選型與評估、部署與持續監測。它重視質量指標（準確率、延遲、漂移）、安全/治理（隱私、偏誤、濫用防護）與回饋閉環（A/B 與人機協作）。和 API First 相輔相成：前者聚焦智慧體驗，後者保障整合與治理。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q2

Q7: API First 與 AI First 有何差異？
- A簡: API First 重契約與整合治理；AI First 重資料、模型與評估。決策點與風險管理側重不同。
- A詳: API First 聚焦合約清晰、相容性與交付效率，核心產物是可測可管的 API 規格與管線。AI First 聚焦資料生命週期、模型表現與風險治理，核心產物是資料/模型資產與評估指標。前者風險在破壞相容與整合延宕；後者風險在資料品質、模型漂移與誤用。兩者可結合：以 API 提供 AI 能力，並以契約和評測共同守護品質。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, A-Q6, B-Q1, B-Q2

Q8: 什麼是微服務架構？
- A簡: 以小型自治服務組成系統，各自部署擴展，透過 API 或事件協作以對應組織與領域。
- A詳: 微服務將單體拆分為聚焦單一業務能力的自治服務，獨立部署與伸縮。服務間以同步（REST/gRPC）或非同步（事件/佇列）溝通，搭配服務發現、配置管理、觀測性與自動化。優點是敏捷與獨立演進；代價是分散式複雜度、資料一致性與治理成本。適用於大型團隊與明確的界限內容（Bounded Context）。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q9, A-Q10, B-Q13, B-Q15

Q9: 微服務與單體架構有何差別？
- A簡: 單體集中部署、簡單但耦合高；微服務自治部署、彈性高但分散式複雜度大。
- A詳: 單體適合初期快速迭代與小團隊，部署與除錯簡單，但擴展與協作瓶頸明顯。微服務讓團隊自治、獨立伸縮與技術多樣性，但需處理跨服務交易、網路可靠性與觀測性。選擇取決於組織規模、變更頻率、領域複雜度與工程成熟度，可先單體良好模組化，再逐步演進。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, B-Q14

Q10: 什麼是服務發現（Service Discovery）？
- A簡: 在動態環境自動管理並查找可用服務端點的機制，常含註冊、心跳與健康檢查。
- A詳: 服務發現透過註冊中心維護服務實例清單，服務啟動註冊、定期心跳與健康檢查，消失或不健康即摘除。客戶端或邊車向註冊中心查詢可用端點並負載平衡。常見實作有 Consul、Eureka 與 Kubernetes 原生 Service/Endpoints。它是微服務基礎設施核心之一。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q6

Q11: 什麼是 CQRS（命令與查詢責任分離）？
- A簡: 將寫入（命令）與查詢責任分離，各自用最佳模型以提升性能與可擴展性。
- A詳: CQRS 主張用不同模型處理寫入與查詢：寫入模型專注一致性與商務規則；讀取模型為查詢與報表最佳化，可能去正規化或快取。兩者透過事件或資料同步達到最終一致，適合讀多寫少或讀寫需求差異大的情境。常與事件溯源搭配，但可獨立使用。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q4, A-Q13, C-Q4

Q12: 什麼是 Event Sourcing（事件溯源）？
- A簡: 以事件作為真相來源，聚合狀態由事件回放重建，並可產生投影供查詢。
- A詳: 事件溯源將每次狀態改變記錄為不可變的事件，存入事件儲存。當需要當前狀態時，透過事件回放或快照重建聚合。事件也可驅動外部投影（Read Model），支援審計、回溯與重建能力。挑戰在事件版本化、冪等處理與投影延遲管理。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q5, A-Q13, C-Q5

Q13: CQRS 與 Event Sourcing 的關係與差異？
- A簡: 可搭配也可分離。CQRS 管責任分離；Event Sourcing 管狀態存證與重建。
- A詳: CQRS 專注把寫與讀分離以優化性能與演進；Event Sourcing 將變更以事件持久化，狀態由事件回放。兩者常共用事件流：寫入產生事件，事件更新讀模型。但 CQRS 可用傳統資料庫同步；Event Sourcing 也可不做專門讀模型。選擇依照審計需求、延遲容忍與團隊成熟度。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, A-Q12, B-Q15

Q14: 什麼是 DevOps？
- A簡: 強調開發與運維協作，用自動化與文化實踐，快速且可靠地交付價值。
- A詳: DevOps 結合流程、文化與工具，縮短交付週期並提升品質。關鍵實踐包含版本控制、CI/CD、基礎設施即程式碼、觀測性、變更小步快跑、事後檢討與錯誤預算。重點在跨職能合作與持續改進，而非僅引入工具。大型團隊需配套治理與標準化平台。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q7, C-Q2

Q15: 什麼是 CI/CD？
- A簡: 持續整合與持續交付/部署流程，自動建測與發布，縮短回饋迴路並降低風險。
- A詳: CI（持續整合）在每次提交觸發建置與測試，早期發現問題。CD（持續交付/部署）讓可發布套件自動推向環境，包含安全掃描、品質門檻、核准與漸進式發布。與 API First、微服務結合，可支援多團隊並行交付與版本治理，提升可預測性與速度。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q7, C-Q2, D-Q3

Q16: 什麼是 SLO（服務水準目標）？
- A簡: 以使用者體驗為中心的服務目標（如可用性、延遲），用以管理錯誤預算與風險。
- A詳: SLO 定義從使用者視角量測的可量化目標，如 P95 延遲、成功率、可用性。SLI 是量測指標，SLA 是對客戶的承諾。SLO 有助平衡新功能與穩定性，透過錯誤預算指引變更節奏。非同步系統需納入佇列滯留與最終一致延遲。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q7, D-Q6

Q17: 什麼是基於訊息佇列的 RPC？
- A簡: 使用佇列進行請求/回應的 RPC，透過 correlationId 與回覆佇列實現對應與解耦。
- A詳: 客戶端把請求送至請求佇列，指定 replyTo 與 correlationId；服務處理後把回應送至回覆佇列，客戶端依識別碼配對回應。具去耦與緩衝優勢，能跨網路不穩與突發載荷，但需妥善處理超時、重試、冪等與監控。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, C-Q3, D-Q5

Q18: 什麼是 B2B2C 雲端服務的特性？
- A簡: 多租戶、品牌與通路協作、異質整合多，需高伸縮、治理與穩定交付能力。
- A詳: B2B2C 涉及平台、品牌商與消費者三方，常見需求為多租戶隔離、彈性配置、夥伴 API 整合、資料同步與結算。必須重視權限、節流、合規、版本治理與觀測性。架構常見多租戶核心、整合閘道與事件中台，支撐高速變更與跨域協作。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q12, D-Q10

Q19: 什麼是分散式系統架構設計？
- A簡: 設計跨節點服務的可用性、可靠性與一致性，並具備觀測與自動化能力。
- A詳: 分散式設計需在 CAP/BASE 取捨間平衡，處理網路不可靠、部分失效與最終一致。核心能力包含服務發現、配置、通訊模式、資料一致性（Saga/Outbox）、觀測性（Log/Metric/Trace）與自動化（擴縮/治療）。良好邊界與治理是成功關鍵。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q13, B-Q15

Q20: 什麼是平行處理（Parallel Processing）？
- A簡: 利用多核心/多節點同時執行工作，提升吞吐與縮短完成時間。
- A詳: 平行處理將工作切分並行，在多核或分散環境同時運算。對 CPU 計算型任務可用資料切片；對 I/O 型任務則善用非阻塞並發。須注意共享狀態、資源爭用、排程與背壓，並以度量監控實際效益。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q11, D-Q7

Q21: 物件導向設計（OOP）的核心價值是什麼？
- A簡: 透過抽象化、封裝、繼承、多型，降低耦合、提高可重用與可維護性。
- A詳: OOP 以實體與行為建模，透過抽象化與封裝隱藏複雜度，繼承與多型促進擴充與替換。良好設計常結合 SOLID 原則、界限內容與設計模式，提升可測試性與團隊協作效率。即使在微服務中，服務內部仍受益於穩健的 OOP 設計。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q4

Q22: 什麼是容器驅動開發？
- A簡: 以容器作為一致的開發/測試/部署環境，降低環境落差與依賴地獄。
- A詳: 透過 Dockerfile、devcontainer 與 compose 定義依賴服務，在本機以容器啟動與雲端相同的堆疊，確保「在我電腦可行」不再發生。結合 CI/CD 與 Kubernetes，可形成從開發到上線一致的生命週期與映像治理。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q9, D-Q8

Q23: 什麼是「模型的降級驗證」？
- A簡: 驗證新模型對舊客戶端相容，或能安全退回較低版本的機制與測試流程。
- A詳: 當模型或 API 演進時，需確保舊客戶端不被破壞。降級驗證包含契約比對、樣例回放、向下轉換器與多版本並存策略，並在 CI 中自動檢查。若破壞相容，應提供相容層或緊急回退方案；同時清楚揭露棄用路徑與時程。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, C-Q8, D-Q1

Q24: 為什麼知識分享重要？
- A簡: 加速社群共同成長，個人以教為學，累積可重複的最佳實踐與影響力。
- A詳: 分享讓經驗外化成文件、範例與工具，降低他人摸索成本，形成網路效應與標準化。對個人而言，教學迫使結構化思考與反思，促進能力成長；對團隊與產業，能擴散最佳實踐與建立共同語言。Andrew 持續 20 年分享即是最佳示範。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q16


### Q&A 類別 B: 技術原理類

Q1: API First 開發流程如何運作？
- A簡: 以規格為中心：設計、評審、Mock、代碼產生、契約測試與管線治理。
- A詳: 原理是把 API 規格（OpenAPI）當作單一事實來源。關鍵步驟：1) 設計並評審規格；2) 以 Mock/Prism 提供早期對接；3) 用 Codegen 產生 Server/Client 樣板；4) 撰寫契約測試（Pact/NSwag）守護相容；5) 文件自動化（Swagger UI）；6) 在 CI/CD 實施規格差異比對與語意化版本檢查。核心組件：規格倉庫、Mock 伺服器、契約測試、代碼產生器與品質閘。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, C-Q1, B-Q9

Q2: AI First 的執行流程為何？
- A簡: 問題定義→資料管線→特徵/提示工程→模型選型→評估→佈署與回饋。
- A詳: 先明確問題與成功指標，再建立資料蒐集與標註流程；進行特徵或提示工程與基準模型選擇（傳統 ML 或 LLM）。使用線上/離線評估指標（準確率、延遲、成本、漂移），加入安全與風控（內容過濾、隱私）。部署後持續監測與 A/B，透過標註回饋持續改進。核心組件：資料湖、特徵庫、評估框架、Guardrails 與推理服務。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, A-Q7

Q3: 服務發現的運作原理是什麼？
- A簡: 註冊中心維護實例清單，透過心跳/健康檢查更新，客戶端查詢並負載平衡。
- A詳: 服務啟動時向註冊中心（Consul/Eureka）註冊，並定期心跳或由中心主動健康檢查；故障或逾時即摘除。客戶端採 Client-side（本地快取+LB）或 Server-side（代理）發現模式。關鍵步驟：註冊、監測、查詢、摘除與快取。核心組件：註冊中心、健康檢查器、服務代理/SDK 與可觀測性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, C-Q6, D-Q2

Q4: CQRS 的運作機制是什麼？
- A簡: 寫入用命令改變聚合，產生事件；讀取用投影/快取優化查詢，最終一致。
- A詳: 寫模型處理 Command，套用商業規則並持久化（可搭配事件溯源）。事件推播至讀模型，投影為查詢友善的資料（如去正規化或索引）。讀寫分離允許各自擴展與最佳化。核心組件：命令處理器、事件匯流排、投影器、讀模型儲存與一致性監測。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, C-Q4, B-Q15

Q5: Event Sourcing 背後的機制是什麼？
- A簡: 以事件流持久化狀態變更，透過回放重建聚合，投影提供查詢視圖。
- A詳: 每個聚合維度維護事件序列，事件不可變且可版本化。重建時回放事件或載入快照再增量回放。投影將事件轉為讀模型供查詢。關鍵步驟：定義事件、追加寫入、回放重建、投影、壓縮快照。核心組件：事件儲存、序列器、投影器與冪等控制。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q12, C-Q5, D-Q4

Q6: 基於訊息佇列的 RPC 如何運作？
- A簡: 使用請求/回覆佇列與 correlationId 對應請求，並管理超時、重試與死信。
- A詳: 客戶端把訊息放入請求佇列，標註 replyTo 與 correlationId；服務處理並將回覆發至回覆佇列。客戶端監聽回覆佇列，依識別碼配對。流程含宣告佇列、消費者預取（prefetch）、超時與重試策略、死信路由。核心組件：Broker、Producer/Consumer、序列化、關聯識別與觀測指標。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, C-Q3, D-Q5

Q7: 大型團隊的 CI/CD 流程如何設計？
- A簡: 採主幹開發、品質門檻與漸進式發布，流水線可復現且標準化。
- A詳: 關鍵步驟：主幹分支、短分支與合併前檢查；建置、單元/契約/端對端測試與安全掃描；產物管理與環境推送；金絲雀/藍綠與回滾；變更審批與可觀測性。核心組件：CI 服務、Artifact 儲存、部署控制器、Feature Flag 與合規審查。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, C-Q2, D-Q3

Q8: 非同步系統的 SLO 設計機制是什麼？
- A簡: 以端到端延遲、成功率與新鮮度為指標，納入佇列滯留與重試成本。
- A詳: 定義 SLI：e2e 延遲（提交到完成的 P95/P99）、成功率、資料新鮮度與失敗比率。監測佇列長度、消費延遲與重試次數，計算錯誤預算並據以節奏調整。核心組件：度量收集、追蹤鏈路、告警規則與自動擴縮策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, C-Q7, D-Q6

Q9: API 版本管理與降級驗證機制如何設計？
- A簡: 採語意化版本、明確棄用政策，契約測試與規格差異比對守護相容。
- A詳: 新增欄位採向後相容策略，重大變更提升主版本。以契約測試驗證舊版客戶端，規格差異工具（OpenAPI diff）在 CI 中阻擋破壞性變更。提供轉換層（Down-converter）與多版本並存期限。核心組件：版本規範、契約測試、差異工具、API Gateway 政策。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q23, C-Q8, D-Q1

Q10: 容器驅動開發的技術架構如何設計？
- A簡: 以 Docker/DevContainer 宣告環境，Compose/K8s 對齊本地與雲端。
- A詳: 使用多階段 Dockerfile 建產物，devcontainer 定義本機 IDE 與工具，compose 啟動依賴（DB/Cache）。以相同映像在 CI 與 K8s 運行，確保環境同質。核心組件：基底映像、映像倉庫、IaC、觀測與建置快取。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, C-Q9, D-Q8

Q11: .NET 平行處理（TPL/async/await）如何運作？
- A簡: 由工作排程與狀態機實現非阻塞並行，區分 CPU 與 I/O 工作模式。
- A詳: TPL 管理工作與 ThreadPool 排程；async/await 將非同步 I/O 展開為狀態機，避免阻塞執行緒。CPU 密集使用 Parallel/PLINQ 設定並行度；I/O 密集使用真正的 async API。關鍵在避免同步等待、控制上下文捕捉與正確的取消/超時。核心組件：Task、Scheduler、非同步 I/O 提供者。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q20, D-Q7

Q12: B2B2C 典型雲端架構如何設計？
- A簡: 多租戶核心與品牌前台，整合閘道連接夥伴，事件中台與觀測支撐營運。
- A詳: 以租戶識別隔離資料與配置；前台與後台透過 API Gateway 與身份服務協作；夥伴介接經由節流、配額、版本治理；事件中台連接訂單/庫存/行銷流程；觀測系統提供端到端可見性。核心組件：多租戶核心、Gateway、事件匯流排、Data/Feature 平台。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q18, D-Q10

Q13: 微服務間通訊模式如何選擇？
- A簡: 同步 REST/gRPC 與非同步事件/佇列各有取捨，依一致性與耦合選用。
- A詳: REST 適合廣泛兼容與資源操作；gRPC 適合同語言高效二進位通訊。事件/佇列支援鬆耦合與高峰緩衝，但一致性為最終一致。關鍵步驟：識別流程同步需求、失敗模式、重試/超時、冪等與順序性。核心組件：API Gateway、Broker、重試策略與追蹤。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, A-Q17, D-Q5

Q14: 從單體到微服務的遷移機制是什麼？
- A簡: 採絞殺者架構，外圍代理轉發，逐步抽離界限內容以降低風險。
- A詳: 以 Proxy 包覆單體，將流量導向新服務；逐步抽離功能域並設反腐層隔離資料模型。建立端到端測試與觀測，確保行為一致。資料遷移以事件同步或雙寫/回填。核心組件：邊界識別、代理/路由、反腐層、資料同步管道與回退方案。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q9, D-Q9

Q15: 微服務資料一致性的原理（Saga/Outbox）？
- A簡: 用 Saga 編排與補償，Outbox 確保事件與資料同時落地，達成最終一致。
- A詳: Saga 將跨服務交易拆成本地交易與補償步驟，可由協調者或事件編舞驅動。Outbox 把資料變更與事件同庫寫入，再由 Relay 發送到 Broker，避免雙寫不一致。核心組件：Saga 協調器、Outbox 表、Relay、冪等與重放保護。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q13, D-Q9, C-Q5

Q16: 技術社群分享如何促進知識擴散？
- A簡: 以演講、文章、範例與開源沉澱可複製經驗，建立共同語言與網絡效應。
- A詳: 分享把隱性知識顯性化，降低學習摩擦並促進標準化。會議與社群帶來快速回饋，部落格與程式碼庫便於長期引用，內訓擴大組織影響。持續輸出與互動形成正循環，驅動個人與社群共同成長。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q24


### Q&A 類別 C: 實作應用類（10題）

Q1: 如何用 OpenAPI 落實 API First？
- A簡: 設計規格→Mock→代碼產生→契約測試→CI 比對差異，完整落地。
- A詳: 實作步驟：1) 用 OpenAPI 撰寫規格並評審；2) 用 Prism/Swagger Mock；3) NSwag/Swashbuckle 產生 Server/Client；4) 用 Pact 驗證；5) 在 CI 比對差異。程式碼/設定：
  - openapi.yaml 片段:
    ```
    paths:
      /orders/{id}:
        get:
          responses:
            '200': { description: OK }
    ```
  注意事項：欄位新增採向後相容；版本與棄用政策清晰；CI 中自動化檢查不可少。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q1

Q2: 如何用 GitHub Actions 建立 .NET 服務 CI/CD？
- A簡: 建置/測試→容器化→推送映像→部署→漸進式發布與回滾。
- A詳: 步驟：dotnet restore/build/test；docker build/push；部署到 AKS/ACI。workflow 片段：
  ```
  name: ci
  on: [push]
  jobs:
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-dotnet@v4
        - run: dotnet build --configuration Release
        - run: dotnet test --no-build
        - run: docker build -t ghcr.io/org/app:${{ github.sha }} .
  ```
  注意：使用快取、保護機密、設品質門檻與回滾策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q7

Q3: 如何以 RabbitMQ 在 C# 實作 MQ-based RPC？
- A簡: 建立 request/reply 佇列，使用 correlationId 與 replyTo 對應回應。
- A詳: 步驟：宣告請求佇列，客戶端發送訊息含 replyTo 與 correlationId；服務端消費並回覆。程式碼片段（客戶端）：
  ```
  var props = channel.CreateBasicProperties();
  props.ReplyTo = replyQueue;
  props.CorrelationId = Guid.NewGuid().ToString();
  channel.BasicPublish("", "rpc_req", props, body);
  ```
  注意：設定超時/重試、prefetch、死信佇列；確保處理冪等與觀測指標。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, B-Q6

Q4: 如何在 ASP.NET Core 以 MediatR 落實 CQRS？
- A簡: 定義 Command/Query 與 Handler，分離讀寫模型與控制器邊界。
- A詳: 步驟：新增 MediatR；定義 Command/Query 與 Handler；控制器注入 IMediator。程式碼：
  ```
  public record CreateOrder(string Sku,int Qty): IRequest<Guid>;
  public class Handler : IRequestHandler<CreateOrder, Guid> { ... }
  [HttpPost("/orders")]
  public Task<Guid> Post([FromBody]CreateOrder cmd)=> _m.Send(cmd);
  ```
  注意：寫入加上交易邊界；讀模型可獨立存放；處理最終一致與事件發佈。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, B-Q4

Q5: 如何實作 Event Sourcing（C# 簡化版）？
- A簡: 將聚合變更追加為事件，回放事件重建狀態，必要時建立快照。
- A詳: 步驟：定義事件型別、事件儲存與聚合套用；寫入時追加事件，讀取時回放。程式碼：
  ```
  interface IEvent {}
  class OrderCreated: IEvent { public Guid Id; }
  class Order {
    List<IEvent> _changes=new();
    public void Apply(IEvent e){ /* mutate state */ }
    public void Load(IEnumerable<IEvent> evts){ foreach(var e in evts) Apply(e); }
  }
  ```
  注意：事件版本化、冪等、投影延遲與快照策略。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q12, B-Q5

Q6: 如何設定服務發現（Consul/Eureka）？
- A簡: 服務啟動註冊，配置健康檢查；客戶端透過 SDK 查詢可用端點。
- A詳: 步驟：部署 Consul；服務在啟動註冊並提供健康檢查；客戶端使用 Consul SDK。設定：
  ```
  {
    "service": {
      "name": "orders",
      "check": { "http": "http://localhost:5000/health", "interval": "10s" }
    }
  }
  ```
  注意：TTL/檢查間隔、停機註銷、權限與端點快取更新。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q10, B-Q3

Q7: 如何為非同步訂單系統設計 SLO 與監控？
- A簡: 設定 e2e 延遲與成功率 SLI，建立 Prometheus 告警與錯誤預算管理。
- A詳: 步驟：定義 SLI（P95 e2e < 5s、成功率 > 99.5%）；暴露指標（佇列長度、消費延遲）；Prometheus 告警：
  ```
  - alert: E2EHighLatency
    expr: histogram_quantile(0.95, rate(e2e_latency_bucket[5m]))>5
  ```
  注意：時鐘差、重試乘載、分流高優先；以錯誤預算調整發布節奏。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q8, C-Q10

Q8: 如何設計 API 版本與相容性測試（Pact）？
- A簡: 啟用版本策略、生成 OpenAPI、撰寫 Pact 契約並在 CI 驗證。
- A詳: 步驟：使用 Microsoft.AspNetCore.Mvc.Versioning；輸出 OpenAPI；以 Pact 撰寫消費者契約並在供應者驗證。程式碼片段：
  ```
  services.AddApiVersioning(o=>o.AssumeDefaultVersionWhenUnspecified=true);
  ```
  注意：只做向後相容新增；破壞性變更升主版；規格差異比對與棄用公告。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q23, B-Q9

Q9: 如何用 Docker 容器化 .NET 並建立開發環境？
- A簡: 撰寫多階段 Dockerfile、devcontainer 與 compose，確保環境一致。
- A詳: 步驟：Dockerfile 建置與運行階段；devcontainer.json 設 IDE/工具；compose 啟依賴服務。Dockerfile 片段：
  ```
  FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
  WORKDIR /src && dotnet publish -c Release -o /out
  FROM mcr.microsoft.com/dotnet/aspnet:8.0
  COPY --from=build /out /app
  ```
  注意：非 root、健康檢查、快取還原與密碼管理。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q22, B-Q10

Q10: 如何以 Prometheus/Grafana 監控 SLO 並告警？
- A簡: 暴露指標→寫錄製/告警規則→建立儀表板→以錯誤預算管理風險。
- A詳: 步驟：在 .NET 用 prometheus-net 暴露指標；Prometheus 規則：
  ```
  - record: req_error_ratio
    expr: sum(rate(http_requests_total{code!="200"}[5m]))/sum(rate(http_requests_total[5m]))
  - alert: ErrorBudgetBurn
    expr: req_error_ratio > 0.01
  ```
  Grafana 建 P95 延遲與成功率看板。注意：標籤基數、降噪、錄製規則與儀表板審視節奏。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q8


### Q&A 類別 D: 問題解決類（10題）

Q1: 遇到 API 合約變更導致舊客戶端壞掉怎麼辦？
- A簡: 症狀：舊客戶端報錯。先回退或加相容層，再補齊契約測試與版本治理。
- A詳: 症狀：4xx/5xx 增加、客戶端解析失敗。原因：破壞性變更未檢出。解法：緊急回退或加 Down-converter；補上契約測試與 OpenAPI 差異比對；公告棄用時程。預防：語意化版本、變更審查、Pact 驗證與自動化門檻。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, C-Q8

Q2: 服務發現資料過期造成流量打到壞節點，如何處理？
- A簡: 症狀：連線錯誤集中。調整健康檢查/TTL、快取刷新與自動摘除策略。
- A詳: 可能原因：心跳/健康檢查過寬、客戶端快取過久。解法：縮短 TTL、主動健康檢查、啟用 readiness 探針與自動摘除；客戶端定期刷新快取與熔斷重試。預防：部署前健康檢查、關閉流量再關機、觀測失敗率告警。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q6

Q3: CI/CD 測試不穩定拖慢交付，怎麼改善？
- A簡: 症狀：流水線常紅燈。隔離不穩測試、強化決定性與測試金字塔。
- A詳: 原因：資料競態、外部依賴、時間敏感。解法：為不穩測試加標籤與隔離、使用測試替身、固定種子與時區；收斂端對端比例、強化契約/單元測試。預防：預提交快檢、失敗歸因與指標化治理、研發共用測試平台。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, C-Q2

Q4: Event Sourcing 投影延遲導致查詢落後，如何處理？
- A簡: 症狀：查詢資料舊。擴充消費者、重放投影並監測滯留與錯誤。
- A詳: 原因：事件堆積、投影器性能不足或錯誤重試。解法：水平擴充投影器、提升批次與並行度、修復壞事件後重放；儀表化 Lag 與重試。預防：容量規劃、死信與回壓、快照縮短重放時間。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q5, C-Q5

Q5: MQ-based RPC 常發生逾時，如何診斷與修復？
- A簡: 症狀：請求逾時/回覆慢。調整預取、併發、超時與死信，必要時改事件驅動。
- A詳: 原因：消費者太少、處理過慢、佇列堆積或網路不穩。解法：增加消費者與預取（prefetch）、設計超時/重試與 DLQ、拆分重任務；對非必同步流程改為事件。預防：壓測、SLO 告警、背壓與容量自動擴縮。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, C-Q3, B-Q13

Q6: 非同步系統 SLO 經常超標，如何診斷？
- A簡: 症狀：端到端延遲升高。以追蹤找瓶頸，調整佇列/批次與自動擴縮。
- A詳: 先用分散式追蹤定位哪一段延遲最大；觀察佇列長度、重試與錯誤。解法：增減批次大小、動態擴縮消費者、優先級佇列；降低重試放大效應。預防：錯誤預算看板、節流與退避、容量預估。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, C-Q7, C-Q10

Q7: 平行處理出現 ThreadPool 饑荒與吞吐下降怎麼辦？
- A簡: 症狀：CPU 利用不均、延遲高。移除同步阻塞、設定並行度與正確 async。
- A詳: 原因：同步等待非同步、阻塞 I/O、過度平行化或鎖競爭。解法：全鏈路 async、使用 ConfigureAwait(false)、設定 MaxDegreeOfParallelism、避免同步 I/O。預防：壓測與分析（PerfView）、儀表化佇列長度與延遲。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q11

Q8: 容器開發環境與生產不一致導致 Bug，怎麼解？
- A簡: 症狀：本機 OK、上線壞。以容器驅動開發與不可變基礎設施統一環境。
- A詳: 原因：版本差異、依賴缺漏、配置不一致。解法：devcontainer 固定工具版本、共用基底映像、IaC 管理基礎設施、相同入口與健康檢查。預防：以映像為單位交付、本地與 CI 用同一映像與 Compose 堆疊。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q9

Q9: 單體拆分造成跨服務資料不一致，怎麼辦？
- A簡: 症狀：交易半完成。以 Saga 補償與 Outbox 確保最終一致與事件可靠。
- A詳: 原因：跨服務分散交易、雙寫。解法：引入 Saga（協調/編舞）與補償步驟、Outbox+Relay 避免事件遺失、消費冪等與去重。預防：界限內容清晰、事件契約治理與觀測延遲/失敗率。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q14, B-Q15, C-Q5

Q10: B2B2C 夥伴 API 升版破壞相容，如何應對？
- A簡: 症狀：對接失敗。以 Gateway 適配、版本並存與契約治理平滑升級。
- A詳: 原因：夥伴重大變更。解法：在 API Gateway 設適配器維持舊行為；短期多版本共存；加入 Schema 驗證與監測錯誤率；協調升級時程。預防：對接契約與測試、夥伴自動化驗證、清晰棄用政策。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q12, B-Q9


### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 誰是安德魯 Andrew Wu？
    - A-Q2: 什麼是首席架構師（Chief Architect）？
    - A-Q3: Microsoft MVP 是什麼？
    - A-Q5: 什麼是 API First？
    - A-Q6: 什麼是 AI First？
    - A-Q7: API First 與 AI First 有何差異？
    - A-Q8: 什麼是微服務架構？
    - A-Q9: 微服務與單體架構有何差別？
    - A-Q10: 什麼是服務發現（Service Discovery）？
    - A-Q14: 什麼是 DevOps？
    - A-Q15: 什麼是 CI/CD？
    - A-Q16: 什麼是 SLO（服務水準目標）？
    - A-Q17: 什麼是基於訊息佇列的 RPC？
    - A-Q22: 什麼是容器驅動開發？
    - A-Q24: 為什麼知識分享重要？

- 中級者：建議學習哪 20 題
    - B-Q1: API First 開發流程如何運作？
    - B-Q2: AI First 的執行流程為何？
    - B-Q3: 服務發現的運作原理是什麼？
    - B-Q4: CQRS 的運作機制是什麼？
    - B-Q5: Event Sourcing 背後的機制是什麼？
    - B-Q6: 基於訊息佇列的 RPC 如何運作？
    - B-Q7: 大型團隊的 CI/CD 流程如何設計？
    - B-Q8: 非同步系統的 SLO 設計機制是什麼？
    - B-Q9: API 版本管理與降級驗證機制如何設計？
    - B-Q10: 容器驅動開發的技術架構如何設計？
    - B-Q11: .NET 平行處理（TPL/async/await）如何運作？
    - B-Q12: B2B2C 典型雲端架構如何設計？
    - B-Q13: 微服務間通訊模式如何選擇？
    - C-Q1: 如何用 OpenAPI 落實 API First？
    - C-Q2: 如何用 GitHub Actions 建立 .NET 服務 CI/CD？
    - C-Q6: 如何設定服務發現（Consul/Eureka）？
    - C-Q7: 如何為非同步訂單系統設計 SLO 與監控？
    - C-Q8: 如何設計 API 版本與相容性測試（Pact）？
    - D-Q1: 遇到 API 合約變更導致舊客戶端壞掉怎麼辦？
    - D-Q3: CI/CD 測試不穩定拖慢交付，怎麼改善？

- 高級者：建議關注哪 15 題
    - A-Q13: CQRS 與 Event Sourcing 的關係與差異？
    - A-Q18: 什麼是 B2B2C 雲端服務的特性？
    - A-Q19: 什麼是分散式系統架構設計？
    - B-Q14: 從單體到微服務的遷移機制是什麼？
    - B-Q15: 微服務資料一致性的原理（Saga/Outbox）？
    - C-Q4: 如何在 ASP.NET Core 以 MediatR 落實 CQRS？
    - C-Q5: 如何實作 Event Sourcing（C# 簡化版）？
    - C-Q9: 如何用 Docker 容器化 .NET 並建立開發環境？
    - C-Q10: 如何以 Prometheus/Grafana 監控 SLO 並告警？
    - D-Q2: 服務發現資料過期造成流量打到壞節點，如何處理？
    - D-Q4: Event Sourcing 投影延遲導致查詢落後，如何處理？
    - D-Q5: MQ-based RPC 常發生逾時，如何診斷與修復？
    - D-Q6: 非同步系統 SLO 經常超標，如何診斷？
    - D-Q9: 單體拆分造成跨服務資料不一致，怎麼辦？
    - D-Q10: B2B2C 夥伴 API 升版破壞相容，如何應對？