# 替你的應用程式加上智慧! 談 LLM 的應用程式開發

## 摘要提示
- 智慧化願景分階段: 以四階段路徑由傳統操作、風險評估、Copilot 輔助到全對話式操作，漸進把 LLM 嵌入應用。
- LLM 當人來溝通: 把 LLM 視為「人」設計，重點是提示工程與語意理解，而非傳統 function+parameters。
- 關鍵節點導入 AI: 在結帳等高風險環節引入 LLM 進行語意推理與常識檢查，補足 rule-based 盲點。
- Copilot 邊操作邊提示: 以操作歷程為上下文，LLM 靜默監控並於必要時「HINT」提醒，貼近 GitHub Copilot 體驗。
- 對話驅動 + Function Calling: 以自然語言解意圖，LLM 自主規劃並呼叫對應技能/API 完成交付。
- 架構核心五要素: LLM 大腦、Chat History（短期記憶）、RAG/Knowledge（長期記憶）、Skills/Plugins（技能）、Persona（人格）。
- Semantic Kernel 角色: 以開發框架抽象化模型、記憶、技能與協作流程，讓 AI 能在 APP 內安全可控地運作。
- Skills 設計要精不在多: 以清楚描述與精準邊界讓 LLM 正確選擇與呼叫，避免「放錯招」。
- 開發者新職能: 提示工程與技能/插件設計成關鍵能力，程式從寫邏輯轉為定義語意與任務編排。
- 未來趨勢判斷: 自然語言正成為新介面與「程式語言」，AI 不必完美但可用，10 年內將深度改變開發樣態。

## 全文重點
作者以「安德魯小舖」PoC 展示傳統應用如何循序導入 LLM，從既有操作介面出發，先在結帳等關鍵節點以提示工程與常識推理進行風險檢查；再發展成「Copilot 式」全程輔助，LLM根據操作歷程靜默監測、必要時提示；最終讓 AI 以自然語言理解意圖，自主呼叫對應函式（Skills/Function Calling）完成複合任務，達到全對話式操作。作者進一步以架構師視角拆解 LLM 應用必備構件：LLM 為大腦，Chat History 提供短期記憶，RAG/Knowledge 解決長期記憶與領域知識，Skills/Plugins 則賦予行動能力，Persona 負責角色定位與邊界。Microsoft Semantic Kernel 把這些能力框架化，抽象出模型、記憶與插件，並以標註與描述驅動 LLM 正確理解與呼叫技能。實作重點從「寫演算法」轉向「寫提示與技能描述」，API/Swagger 或 C# Attributes 的描述即是 LLM 的「說明書」。作者主張技能要精準、可測與可控，避免因技能過多而讓模型誤選；而在產品節奏上應以漸進式策略整合 AI，兼顧體驗、可靠度與成本。最後作者觀察到開發工作正被自然語言驅動的流程重塑：提示工程、任務編排與插件設計成為核心競爭力；AI 的不可確定性可被系統與流程容忍與治理，就像企業用人一樣。長遠看，自然語言將成新型態的「編程介面」，LLM 成為新的執行環境，軟體開發的角色與工具將在未來十年快速演進。

## 段落重點
### 1, 「安德魯小舖」的進化
作者判斷短期不會把服務完全寄託於 ChatGPT 平台，改採「漸進式智慧化」嵌入既有應用。提出四階段路線：1) 標準操作對照組；2) 在結帳等關鍵節點用 LLM 做語意風險檢查；3) 以 Copilot 模式在操作歷程中即時提示；4) 允許 AI 以自然語言代為操作。此策略兼顧成熟度、成本與產品風險，並能逐步驗證架構手感與開發模式，讓開發團隊與使用者習慣逐步遷移。

### 1-1, 標準的操作模式 (對照組)
以 Console App 模擬傳統選單式操作，涵蓋列商品、加購物車、結帳、查紀錄等功能，作為未來智慧化的對照基準。此階段重點不在體驗而在「穩定流程」，讓後續注入 LLM 能清楚比較價值：哪些環節仍適合確定性邏輯，哪些需要語意與常識推理來補足。

### 1-2, 從操作意圖評估風險
在結帳前引入 LLM，使用 System Prompt 設定「助理店長」角色與 SOP/FAQ，並以結構化 User Prompt 注入購物清單、金額與客註，要求以「OK/HINT」格式回覆。示例中，LLM 由「小孩生日派對」聯想到「酒精法規」與「含糖提醒」，提出合宜建議。此法把常識推理與情境理解嵌入關鍵流程，且 Prompt 由開發者治理，提升一致性與可控性。

### 1-3, 操作過程中全程輔助
仿 GitHub Copilot 體驗：每次操作都以自然語言向 LLM 報告，由其在背景判斷是否需要提示，僅於必要時輸出「HINT」，平時回「OK」不打擾。System Prompt 增加「行為監控規則」，如連續加入/移除商品或重複看指令清單便主動關懷。此設計將語意監控「內嵌於流程」，以極低摩擦提供高價值提醒，顯著提升體驗而不改動使用習慣。

### 1-4, 允許透過對話，由 AI 代為操作
加入 Function Calling 與技能集，讓 LLM 由一段自然語言自動拆解步驟、選擇並呼叫正確函式與參數（如列商品、試算、加購物車、顯示購物車），再以人機混合完成確認與結帳。此模式保留登入、交易等剛性流程的可控性，卻讓「意圖到動作」的轉譯由 LLM 負責，大幅提升靈活度與可達性。

### 2, 探索 LLM 應用的系統架構與開發框架
對照 Microsoft 對 Agent 的分類（Chatbot、RAG、Copilot、Fully Autonomous），與本文四階段自然對齊。作者強調架構師要先理解 LLM 的特性與不可確定性，再設計合適的邊界、流程與分工。Semantic Kernel（SK）與 OpenAI Assistants API 把模型、記憶、技能與協作抽象化，成為把 AI 放進應用的關鍵底座。

### 2-1, 加上「智慧」的設計框架
軟體人不必成為模型訓練專家，但需理解 LLM 的能力與限制，據以設計「語意驅動」的系統。關鍵在：以 LLM 理解自然語言、配合短長期記憶與可執行的技能，並以明確 Persona 界定任務邊界。先理解原理與資料流，再看框架程式碼，能更有效掌握整體設計意圖與取捨。

### 2-2, LLM + 短期記憶（聰明）
單純 LLM 無狀態，需以 Chat History 保持對話脈絡，形成「短期記憶」。在購物情境中，這是客人進店到結帳期間的上下文。給足脈絡能顯著提升意圖理解與回應品質，但也要兼顧 Token 成本與速度，形成提示工程的第一個取捨點。

### 2-3, RAG，長期記憶（智慧）
以 Embeddings + 向量資料庫建立知識索引，對詢問先做語意檢索，再把相關片段餵入 LLM 生成答案，獲得可延展的「長期記憶」。此法不必重訓模型即可接入 SOP、FAQ、案例與內部資料，符合人類「聯想」與「提取」的知識使用模式，亦是企業導入私域知識的主流作法。

### 2-4, Skills（才能）
LLM 需能「做事」，靠 Skills/Function Calling 將自然語言轉為具體 API 呼叫。流程是：語意理解→挑選合適技能→蒐集必要參數→執行→以回傳值更新上下文並生成回覆。關鍵在技能說明與參數描述要清楚可測，並控制技能數量與邊界，避免選錯與誤用。

### 2-5, Persona（人格）
以 System Prompt/Instructions 設定 Agent 的角色、任務與紀律；若由 OS 提供主模型，未來可結合本地個資（行事曆、聯絡人、筆記、歷史）做個人化 RAG。本文 PoC 以簡化自我介紹式設定即可應付場景，但指向未來更深的端上個人化能力。

### 2-6, 開發框架全貌
落地重點有二：提示工程與技能/插件設計。Semantic Kernel 抽象出 Models、Memories（向量 DB）、Plugins（Skills）與 Orchestration，配合屬性標註與描述即能讓 LLM 正確理解與呼叫。示例以 C# Attributes 標記 KernelFunction/Description 註冊為插件，成為 LLM 的「可執行說明書」。整體生態正往「自然語言（Prompt）+ 模型 + 技能 + 記憶 + 任務編排」的統一圖譜收斂。

### 3, 未來的發展（個人觀點）
作者認為自然語言正成為新一代「編程介面」，LLM 像新型 Runtime；開發者從寫演算法，轉為寫提示、設計技能與任務編排。AI 不可確定性可由流程與治理吸收，正如企業用人不求完美但求進步。當成本與效能在未來十年持續改善，「用嘴巴寫程式」將從局部可行走向廣泛實用；開發者不會消失，但工具與能力模型將徹底重塑，關鍵在於看清分工邊界：何者需精準確定性處理，何者交給有「智慧」的系統。

## 資訊整理

### 知識架構圖
1. 前置知識：
   - 基本軟體架構分層概念（UI/Domain/Data）
   - LLM 基礎（prompt、token、chat history）
   - 雲端與 API 基礎（HTTP、Swagger、OAuth 基本概念）
   - 向量檢索與 Embeddings 概念（RAG 基本流程）
   - .NET/C# 或同等開發語言的基本能力

2. 核心概念：
   - LLM 作為「人機介面」與「推理引擎」：以自然語言驅動，需以 prompt 而非傳統參數思維設計
   - 記憶體系：短期記憶（Chat History）+ 長期記憶（RAG/Knowledge）
   - 技能/外掛（Skill/Plugin）與 Function Calling：讓 LLM 能執行任務、呼叫系統能力
   - Copilot 模式：旁路輔助、情境感知、即時提醒
   - 代理人（Agent）與 Persona：角色設定、任務邏輯與行為邊界
   - 逐步智慧化演進：標準操作 → 風險判定 → 全程輔助 → 對話式自主操作

3. 技術依賴：
   - LLM 模型（Azure OpenAI GPT-4 等）
   - Embedding 模型 + 向量資料庫（作為知識檢索）
   - 開發框架（Microsoft Semantic Kernel / LangChain）
   - Function Calling/Assistants API（API 編排與外部動作）
   - 應用服務/API 層（Swagger 定義、域模型、權限）
   - Orchestration（Planner/Prompt Flow/工作流）

4. 應用場景：
   - 電商結帳風險提示、FAQ 智能應答、個人化建議與加購
   - 後台作業與客服輔助（從操作歷程提示、SOP 導引）
   - 對話式任務執行（條件化購物、預算拆解、組合規劃）
   - 一般企業內知識檢索、政策合規審查、表單自動化處理
   - 產品內建 Copilot（IDE 類體驗：隨行提示、少打擾高價值建議）

### 學習路徑建議
1. 入門者路徑：
   - 了解 LLM 與 Prompt 基礎：system/user/assistant 的差異與作用
   - 實作簡單 Chat Completion：帶入 Chat History 觀念
   - 認識 RAG 概念：Embedding、向量相似度（cosine）與檢索結果拼接至 prompt
   - 用 Postman/Swagger 認識 API 結構、嘗試簡單 Function Calling 範例

2. 進階者路徑：
   - 以 Semantic Kernel 建立 Plugins/Skills：以描述屬性驅動函式被 LLM 正確選用
   - 設計 Persona/Instructions：將 SOP、FAQ、風險規則轉成系統化提示
   - 建立 Copilot 旁路輔助：把使用者操作歷程結構化傳給 LLM，定義回覆協議（OK/HINT）
   - 導入 RAG：建立向量庫、切片策略、過濾與排序（Top-k、Score 門檻）
   - 基本 Orchestration：多步驟任務規劃（ListProducts → Estimate → Add → Confirm）

3. 實戰路徑：
   - 從傳統 APP 切入：保留標準操作流，於關鍵節點嵌入 LLM 風險判定
   - 建立知識庫：把 SOP/FAQ/政策規範嵌入 RAG，持續擴充與迭代
   - 定義清晰的 Skill 介面：小而精、語意明確、參數描述完善
   - 實作 Copilot：事件鉤子收集操作訊息 → 規則化 prompt → OK/HINT 協議 → UI 非干擾式提示
   - 漸進開放自主操作：從推薦/草擬到自動執行前確認、最後才放寬全自動

### 關鍵要點清單
- 漸進式智慧化路徑：從標準操作到對話式自主，分階段落地（優先級: 高）
- Prompt Engineering：以人為本的指令設計，包含回覆協議與上下文選擇（優先級: 高）
- Chat History（短期記憶）：對話脈絡維持與成本控制策略（優先級: 中）
- RAG/Knowledge（長期記憶）：Embedding、向量檢索、切片與過濾（優先級: 高）
- Skill/Plugin 設計：小而精、強描述、可測試、與域模型一致（優先級: 高）
- Function Calling/Assistants API：讓 LLM 能「做事」的關鍵能力（優先級: 高）
- Persona/Instructions：角色定位、任務邊界、SOP/FAQ 系統化（優先級: 中）
- Copilot 體驗設計：低打擾、高價值、OK/HINT 協議與 UI 呈現（優先級: 高）
- Orchestration/Planner：多步驟任務分解與執行順序管理（優先級: 中）
- 架構抽象與可替換性：模型/向量庫/外掛可插拔，避免供應商鎖定（優先級: 中）
- 成本與效能：token 預算、延遲、頻率限制與回應品質平衡（優先級: 高）
- 可靠性與風險控管：關鍵節點 AI 檢查、合規提醒、人類確認環（優先級: 高）
- 測試與觀測：Prompt/Skill 的 A/B 與回歸測試、日誌與可觀測性（優先級: 中）
- 資料與隱私：個資與公司內規範納入 RAG 時的安全邊界（優先級: 高）
- 組織與職能轉型：開發者從「寫函式」轉為「定義指令與能力介面」的心智變革（優先級: 中）