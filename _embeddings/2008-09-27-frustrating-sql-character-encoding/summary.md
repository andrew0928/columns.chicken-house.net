# 令人火大的 SQL 字元編碼...

## 摘要提示
- 外包協作: 客戶 IT 委外導致責任不清、問題難以界定。  
- LINKED SERVER: 透過 Linked Server 將 A 系統資料複製到中繼庫時產生亂碼。  
- 編碼差異: A、B 兩系統中文字編碼不同，初步以 CONVERT(ntext) 修正。  
- 資料錯亂: SELECT INTO 後出現字元混雜、上一筆資料覆蓋本筆的怪異現象。  
- 溢位推論: 作者判斷為 SQL Server/NATIVE CLIENT 的緩衝區溢位 Bug。  
- 排除方向: 暫不糾結排序規則與編碼，改以程式邏輯繞道處理。  
- CURSOR 解法: 以 Cursor 一筆一筆 Fetch → 變數 → Update，成功避開問題。  
- 微軟缺陷: 作者認定為 SQL Server 內部問題，客戶又不願更新 SP。  
- 維運現實: 小廠常被踢皮球，只能以繞道法應急。  
- 經驗談: 碰到同樣症狀，建議別硬拼設定，改走替代流程。  

## 全文重點
作者記錄一次令人「火大」的 SQL 字元編碼意外。客戶 A 系統需將資料匯入作者維護的 B 系統，中間設置中繼資料庫，利用 Linked Server 將整個 Table 複製過來再加工。起初僅是 A、B 系統中文字編碼不同，直接 SELECT 會出現亂碼，經由將欄位轉成 ntext 便能正確顯示，問題似乎已解。

正當作者打算收工時，發現批次跑完後資料仍錯誤，而且錯法離奇：原本只是「?」亂碼，現在卻變成上一筆資料的前半段加上其他筆殘留字元，活像程式 Buffer 沒清乾淨。用純 SELECT 觀看資料正常，一旦 SELECT INTO 暫存表就錯，排除定序或編碼設定後，作者推斷 SQL Server 或其 Native Client 在某處發生字串終止碼錯誤、導致緩衝區溢位。

不具備深入偵測 SQL 低層的工具與時間，再加上客戶不願升級 Service Pack，作者決定採取繞道方案：改用 Cursor，逐筆 Fetch 欄位值到 nvarchar 變數，再 Update 回暫存表。此「笨方法」最終成功複製出正確內容。作者感嘆中小廠常在外包體系中被迫處理這類「誰也不想背鍋」的問題，並提醒若他人遇到同樣症狀，不必執著於各種編碼設定，改走替代流程往往更省事。

## 段落重點
### 1. 問題開端：外包體系與資料匯整
作者被同事求助處理客戶 A→B 系統的資料轉移。因客戶 IT 委外，A、B 兩包商互踢皮球，小廠常得自行吸收問題。為了轉換資料，在中繼資料庫建立 Linked Server，直接將 A 系統表格 SELECT 進來。

### 2. 初步亂碼：編碼差異與 ntext 轉換
第一次障礙是兩系統中文字編碼不一致，導致直接 SELECT 出現亂碼。經與客戶 IT 確認後，作者在中繼資料庫以 CONVERT 將欄位轉成 ntext，成功顯示正確中文，以為問題已解決。

### 3. 詭異錯亂：SELECT INTO 觸發資料覆寫
批次處理時卻發生新狀況：使用 SELECT INTO 暫存表後，第 33 筆資料被上一筆與其他筆殘字覆蓋，顯示明顯錯亂。純 SELECT 正常，唯有 SELECT INTO 出錯，排除單純編碼問題。

### 4. 原因推測：緩衝區溢位的可能 Bug
作者以多年寫程式經驗判斷，症狀像是字串結尾 0x00 錯誤導致 Buffer 讀過頭，屬 SQL Server 或 Native Client 的 Bug，而非定序設定。缺乏底層 Trace 工具，也無法要求客戶立刻打補丁，只能尋找繞路方案。

### 5. 迂迴解法：Cursor 逐筆搬運
最終作者改用 Cursor：Fetch 每筆資料到 nvarchar 變數，再 Update 進暫存表。雖屬「笨方法」，卻成功避開溢位問題，資料全部正確。此舉印證 Bug 存在於批次 SELECT INTO 的內部機制。

### 6. 經驗與建議：別硬拼設定，先求可行
作者選擇不再深究 Microsoft Bug，也不要求客戶更新 SP，以免無止盡拉扯。文章作為經驗分享：若遇到相同現象，與其在編碼、排序規則上死磕，不如先用替代流程（如 Cursor 或其他 Copy 方法）繞過，快速恢復系統運作。