---
source_file: "docs/_posts/2020/2020-03-10-interview-abstraction.md"
generated_date: "2025-08-03 14:30:00 +0800"
version: "1.1"
tools:
  - github_copilot
  - claude_sonnet_3_5
model: "claude-3-5-sonnet-20241022"
---

# 架構面試題 #4 - 抽象化設計；折扣規則的設計機制 - 生成內容

## Metadata

### 原始 Metadata

```yaml
layout: post
title: "架構面試題 #4 - 抽象化設計；折扣規則的設計機制 (06/25 補完)"
categories:
- "系列文章: 架構師觀點"
- "系列文章: 架構面試題"
tags: ["系列文章", "架構師", "C#", "OOP"]
published: true
comments: true
redirect_from:
logo: /wp-content/images/2020-03-10-interview-abstraction/logo.jpg
```

### 自動識別關鍵字

keywords:
  primary:
    - 抽象化設計
    - 折扣規則系統
    - 物件導向程式設計
    - 規則引擎
    - 購物車架構
  secondary:
    - 配對折扣演算法
    - 折扣排除機制
    - 動態規則載入
    - 插件式架構
    - 架構面試題

### 技術堆疊分析

tech_stack:
  languages:
    - C#
    - JSON
  frameworks:
    - .NET Framework
    - OOP
  tools:
    - Visual Studio
    - GitHub
    - Git
  platforms:
    - Windows
    - .NET Runtime

### 參考資源

references:
  internal_links:
    - /series/microservice-architecture/
    - /series/architect-interview/
  external_links:
    - https://github.com/andrew0928/Andrew.DiscountDemo
    - https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96
    - https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)
    - https://medium.com/orangeapple/%E9%81%8B%E7%AE%97%E6%80%9D%E7%B6%AD%E7%9A%84%E6%A0%B8%E5%BF%83-%E6%8A%BD%E8%B1%A1%E5%8C%96-c7e013f30c6
  mentioned_tools:
    - GitHub
    - Visual Studio
    - JSON
    - Newtonsoft.Json

### 內容特性

content_metrics:
  word_count: 12000
  reading_time: "60 分鐘"
  difficulty_level: "進階"
  content_type: "技術深度解析"

## 摘要 (Summaries)

### 文章摘要 (Article Summary)

作者透過實際的折扣規則計算系統設計，深入探討抽象化思維在軟體架構設計中的威力與實踐方法。文章從日常生活中常見的各種複雜折扣規則出發，包括第二件六折、買一送一、配對折扣等現實場景，逐步分析當僅使用歸納法處理這些需求時會遇到的困境。作者強調抽象化的核心精神是「隱藏細節、提取重點」，並將此概念應用於折扣系統的設計中。通過定義統一的規則介面，將複雜的折扣計算細節封裝在各自的實作類別中，讓購物車系統只需要關注最終的折扣金額計算，而不必被各種不同的計算邏輯綁架。文章詳細展示了從基礎的商品定義開始，逐步建構出完整的規則引擎架構，包括抽象基類的設計、購物車上下文的管理、以及複雜配對折扣的演算法實作，為讀者提供了一個完整且實用的抽象化設計範例。

### 關鍵要點 (Key Points)

- 抽象化是「隱藏細節、提取重點」的思考過程，目的是讓主系統不被細節變化影響
- 良好的抽象化成果體現在介面設計上，介面定義了重點與細節的分界線
- 折扣系統的抽象化重點是統一的折扣計算介面，隱藏各種複雜的計算規則細節
- OOP的封裝、繼承、多型三大權杖與抽象化思維密切相關且相輔相成
- 規則引擎架構讓系統具備高度的可擴展性，新增規則不會影響既有系統架構

### 段落摘要 (Section Summaries)

1. **問題提出與現實案例分析**：作者從各大超市和便利商店的實際折扣活動中收集案例，展示了現實世界中折扣規則的複雜程度。作者指出純粹使用歸納法來處理這些需求會遇到的困境，包括規則數量急速增長、設定選項過於複雜、使用者體驗不佳等問題。通過分析買一送一、第二件六折、配對折扣等不同類型的優惠，作者說明了為什麼傳統的參數化歸納法無法有效處理未來可能出現的新型折扣規則，為後續的抽象化解決方案奠定了問題背景與動機。

2. **抽象化理論基礎與OOP關聯**：作者深入闡述抽象化的核心概念，強調「隱藏細節、提取重點」不僅是思考方法，更是解決複雜度的根本手段。作者將抽象化與OOP的三大權杖（封裝、繼承、多型）建立明確的關聯，說明抽象化是目的，封裝是手段，而良好的抽象化會自然導向合適的繼承關係與多型應用。作者特別強調介面設計是抽象化成果的具體體現，並且指出在微服務架構、API設計、相依性注入等現代軟體技術中，抽象化能力都是基礎且關鍵的技能。這個段落為讀者建立了紮實的理論基礎。

3. **折扣系統抽象化思考過程**：作者詳細分析了折扣系統應該如何進行抽象化，明確界定了什麼是「重點」（統一的折扣計算結果）以及什麼是「細節」（各種不同的計算規則）。作者提出購物車系統真正關心的是「這些商品符合哪些折扣規則的條件，能折抵多少金額」，而不是具體的計算過程。通過這樣的抽象化思考，作者設計出了理想的結帳流程：計算原價、逐一確認折扣、計算最終價格、執行後續流程。這個段落展示了從問題分析到抽象化方案的完整思考路徑，是全文的核心理論部分。

4. **系統架構實作與代碼展示**：作者從基礎的商品實體定義開始，逐步建構完整的折扣系統架構。首先定義Product類別包含基本商品資訊和標籤系統，接著實作簡單的結帳流程作為基礎架構。然後引入抽象的RuleBase基類，定義統一的折扣規則介面，並展示具體規則的實作方式。作者特別注重實際可執行的程式碼範例，包括JSON資料檔案的設計、購物車上下文的管理、以及規則動態載入機制。每個程式碼片段都有詳細的說明，幫助讀者理解從抽象概念到具體實作的轉換過程，展現了完整的工程實踐經驗。

5. **複雜折扣規則實作深度解析**：作者深入探討複雜折扣規則的實作挑戰，特別是配對折扣、折扣排除機制等進階議題。透過多個實際案例，包括同商品配對、跨區域配對、以及複合規則設計，作者展示了如何在抽象化架構下處理各種複雜的業務邏輯。作者詳細分析了不同實作策略的優缺點，包括標籤擴展法、規則展開法、動態配對法等，並提供了具體的演算法實作與效能考量。這個段落不僅展示了抽象化設計的威力，也體現了在實際專案中處理複雜需求時需要的工程技巧與經驗積累。

## 問答集 (Q&A Pairs)

### Q1: 什麼是抽象化思維？
Q: 抽象化思維的核心概念是什麼？
A: 抽象化思維的核心是「隱藏細節、提取重點」。目的是讓主系統只依照被提取的重點設計流程，而跟重點無關的細節不會影響主系統的設計，即使日後改變細節也不會影響到主系統的運作。抽象化的成果體現在介面設計上，介面定義了重點與細節的分界線。

### Q2: 為什麼歸納法無法有效處理折扣系統？
Q: 單純使用歸納法處理複雜折扣規則有什麼問題？
A: 歸納法只能從已知需求中歸納出解決方案並參數化，但很難面對未知的問題。當面對各種不同的折扣規則時，會產生過多的設定選項和複雜的條件判斷，導致系統難以維護。例如買一送一與第二件免費看似相同，但在實作上需要不同的邏輯處理，無法用同一套參數化規則解決。

### Q3: 如何設計折扣系統的抽象介面？
Q: 折扣規則的統一介面應該如何設計？
A: 折扣規則的抽象基類應該包含規則名稱、說明，以及核心的Process方法，該方法接收購物車上下文並返回可用的折扣。透過這樣的介面設計，購物車系統只需要知道「給定這些商品，這個規則能提供多少折扣」，而不需要了解具體的計算邏輯。這樣的設計讓新增規則變得簡單，且不會影響既有系統。

### Q4: 什麼是購物車上下文（CartContext）？
Q: CartContext在折扣系統中扮演什麼角色？
A: CartContext是購物車的狀態容器，包含已購買商品清單、已套用折扣清單、以及總金額等資訊。它作為各個折扣規則之間溝通的媒介，讓規則可以讀取商品資訊、檢查已套用的折扣、並記錄新的折扣結果。這種設計讓規則之間可以互相協調，避免重複套用或衝突的情況。

### Q5: 如何處理配對折扣的複雜計算？
Q: 配對折扣（如早餐+飲料特價）該如何實作？
A: 配對折扣可以透過商品標籤系統實作。首先為商品標記相應的類別標籤，然後在規則中檢查購物車是否同時包含指定類別的商品。實作時需要考慮配對策略，包括同區配對、跨區配對、以及最佳化配對等不同方法，選擇能提供最大折扣效益的配對組合。

### Q6: 折扣排除機制如何運作？
Q: 如何避免多個折扣重複套用在同一商品上？
A: 透過ExclusiveTag機制實作折扣排除。當商品套用某個折扣後，會被標記上該折扣的專屬標籤，其他有相同排除標籤的規則就不會再套用到該商品上。這種機制可以支援複雜的多層級互斥關係，讓不同類型的折扣可以有不同的排除規則。

### Q7: 這套架構如何支援團隊協作開發？
Q: 抽象化設計如何改善團隊開發效率？
A: 透過明確的抽象介面，團隊成員可以獨立開發不同的折扣規則，而不會互相影響。每個規則都有統一的介面規範，可以獨立進行單元測試。新加入的開發者只需要理解抽象介面的定義，就能快速上手開發新規則，而不需要了解整個系統的複雜度。

### Q8: 如何確保系統的效能與擴展性？
Q: 這套抽象化架構在效能方面有什麼考量？
A: 系統採用無狀態設計，規則計算不修改輸入狀態，支援並行處理。使用延遲計算和快速過濾機制減少不必要的運算。對於大規模系統，還可以考慮快取機制、非同步處理等進階優化。抽象化設計讓效能優化可以在不影響業務邏輯的情況下進行。

## 解決方案 (Solutions)

### P1: 複雜折扣規則管理難題
Problem: 電商系統需要支援各種複雜的折扣規則，包括第二件六折、買一送一、配對折扣等，每種規則的計算邏輯都不同，導致系統難以維護和擴展。
Root Cause: 缺乏統一的抽象介面，各種折扣規則的實作散落在不同地方，新增規則需要修改核心業務邏輯，造成高度耦合。
Solution: 設計統一的折扣規則抽象基類RuleBase，定義Process方法作為標準介面。所有具體的折扣規則都繼承此基類並實作自己的計算邏輯。購物車系統只需要透過統一介面與規則互動，不需要了解計算細節。
Example: 
```csharp
public abstract class RuleBase
{
    public string Name;
    public string Note;
    public abstract IEnumerable<Discount> Process(CartContext cart);
}
```

### P2: 配對折扣計算複雜度問題
Problem: 處理配對折扣（如早餐+飲料特價）時，需要找出最佳的商品配對組合以獲得最大折扣，計算複雜度高且容易出錯。
Root Cause: 缺乏系統性的配對演算法，無法有效處理跨類別商品的組合優化問題，特別是當商品數量較多時的效能問題。
Solution: 實作標籤型商品分類系統，透過商品標籤快速過濾符合條件的商品。設計專門的配對演算法，包括同區配對、跨區配對等策略，並使用動態規劃或貪婪演算法找出最佳配對組合。
Example: 
```csharp
// 商品標籤系統
public HashSet<string> Tags; // 在Product類別中

// 配對邏輯
var breakfastItems = cart.PurchasedItems.Where(p => p.Tags.Contains("BREAKFAST")).ToArray();
var drinkItems = cart.PurchasedItems.Where(p => p.Tags.Contains("DRINK")).ToArray();
```

### P3: 折扣排除與衝突處理
Problem: 多個折扣規則可能會套用到同一商品上，造成重複優惠或不符預期的計算結果，需要建立有效的排除機制。
Root Cause: 缺乏明確的折扣優先序與排除規則，不同規則之間沒有溝通機制，導致無法正確處理折扣衝突情況。
Solution: 建立ExclusiveTag機制，當商品套用某個折扣後標記專屬標籤，其他規則檢查標籤決定是否可以套用。同時實作折扣狀態管理系統，追蹤每個商品的折扣套用狀況。
Example: 
```csharp
public string ExclusiveTag = null; // 在Discount類別中

// 檢查排除邏輯
if (product.AppliedDiscounts.Any(d => d.ExclusiveTag == this.ExclusiveTag))
{
    continue; // 跳過已套用相同類型折扣的商品
}
```

### P4: 系統可擴展性與維護性問題
Problem: 隨著業務發展，需要頻繁新增各種新型態的折扣規則，但現有系統架構無法支援快速擴展，每次修改都影響整體系統穩定性。
Root Cause: 系統架構耦合度過高，新增功能需要修改核心邏輯，缺乏插件式的擴展機制，測試與部署風險較高。
Solution: 採用插件式架構設計，透過動態載入機制載入折扣規則。建立完善的測試框架，每個規則可以獨立測試。實作規則版本管理機制，支援規則的動態更新與回滾。
Example: 
```csharp
// 動態載入規則
private static IEnumerable<RuleBase> LoadRules()
{
    yield return new BuyOneGetOneFreeRule();
    yield return new SecondHalfPriceRule();
    yield return new ComboDiscountRule();
    // 新增規則只需要在這裡加入
}
```

### P5: 效能優化與大規模處理
Problem: 當商品數量龐大且折扣規則複雜時，系統運算效能下降明顯，特別是配對折扣的計算時間過長，影響使用者體驗。
Root Cause: 演算法時間複雜度過高，缺乏有效的快取機制，沒有針對大數據量進行優化設計。
Solution: 實作多層級的效能優化策略，包括商品預過濾、快取機制、演算法優化等。使用索引結構加速商品查找，實作延遲計算減少記憶體使用，考慮並行處理提升運算效率。
Example: 
```csharp
// 使用yield return實作延遲計算
public IEnumerable<Discount> Process(CartContext cart)
{
    // 預先過濾符合條件的商品
    var eligibleProducts = cart.PurchasedItems
        .Where(p => p.Tags.Contains(this.RequiredTag))
        .ToArray();
    
    if (eligibleProducts.Length < this.MinimumQuantity)
        yield break; // 快速返回，避免不必要的計算
        
    // 具體折扣計算邏輯
}
```

## 版本異動紀錄

### v1.1 (2025-08-03)
- 修正摘要格式，改用第三人稱敘述，加入生成工具資訊
- 按照最新的embedding-structure.instructions.md規範重新生成
- 更新front matter格式，加入source_file、generated_date等欄位
- 調整Q&A和解決方案格式，使其更符合指令要求

### v1.0 (2020-03-10)
- 初始版本
