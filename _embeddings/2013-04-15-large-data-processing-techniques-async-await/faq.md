# 處理大型資料的技巧 – Async / Await

# 問答集 (FAQ, frequently asked questions and answers)

## Q: 為什麼在 Web 服務中直接用同步 while‐loop 讀取、處理並輸出大型檔案時，效能只剩下原來的一半？
同步寫法一次只做「讀取→處理→輸出」其中一項，造成 CPU、Disk I/O 與 Network I/O 無法同時被利用。當程式在讀取與處理時，輸出被迫暫停；輸出時又無法同時讀下一批資料，導致整體吞吐量只有直接從 Azure Storage 下載的約 50％。

## Q: 這種「三個員工卻一次只讓一人工作」的狀況常見嗎？
是的，非常普遍。連作者自己都曾多次用傳統 while‐loop 來複製或處理大型檔案，而沒有考慮 I/O 與 CPU 可以重疊執行的可能性，因此經常白白浪費硬體資源。

## Q: 使用 async / await 可以怎麼改善上述瓶頸？
把 Write() 改寫成非同步方法，並在迴圈中將上一個 Write() 的 Task 保存下來，下一輪開始 Read() 之前以 await 確認前一次 Write() 完成。如此即可讓「讀取＋處理」與「輸出」兩段工作時間重疊，充分利用 CPU 與 I/O。

## Q: 改寫為 async / await 後，示範程式的執行時間有何變化？
原本同步版本 10 次循環需約 10 秒；改用 async / await 後僅約 5.5 秒，效能提升接近 2 倍。

## Q: 效能提升幅度會受哪些因素影響？
主要取決於「讀取＋處理」所需時間與「輸出」所需時間的比例。當兩者相近（例：Client 頻寬約 80 Mbps 時），效能改善最明顯；若其中一段明顯較長，重疊空間減少，提升幅度隨之下降，低於 10 % 時往往已經「無感」。

## Q: 在什麼情況下應優先考慮 async / await 而非自行排程 Thread？
當工作內容以 I/O 等待為主、需要在特定時間點「切換上下文並等待結果」時，async / await 能以最少的程式碼改動取得最好可讀性。若需求是大規模平行計算（CPU bound）才建議改用明確的多執行緒或平行化技術。

## Q: 觀察到 CPU、Disk、Network 都沒有滿載，但效能依舊無法提升，通常代表什麼？
這往往意味著程式在執行流程中存在大量等待（blocking）時段，造成硬體資源無法同時運作。此時可嘗試用 async / await 或其他非同步技巧，重新排列流程以消除不必要的等待。

## Q: 使用 async / await 就一定能帶來可觀效能提升嗎？
並非如此。只有當程式的等待時間與可重疊的工作確實存在且比例適中時才有明顯效果；若等待時間本就佔比極低，或重疊空間有限，改善幅度也會隨之變小。