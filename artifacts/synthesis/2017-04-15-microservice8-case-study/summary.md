# 架構師觀點 - 轉移到微服務架構的經驗分享 (Part 1)

## 摘要提示
- 微服務定位: 微服務是解決特定問題的方法，不是目標本身，導入前需明確問題與目標。
- 切割準則: 以業務邏輯與組織流程為核心劃分服務邊界，避免僅以技術視角過度切割。
- 分散式成本: 微服務帶來網路不可靠、資料一致性、跨服務除錯等複雜度，成本不可忽視。
- 技術異質性: 微服務結合容器可容許不同平台與技術選型，採用「各服務最佳解」。
- 容器優勢: 容器效能接近原生、映像建置與註冊中心生態成熟，遠優於傳統 VM。
- .NET 與容器: Windows Container 降低 .NET 採用容器與異質架構的門檻，跨平台部署更容易。
- 重構路徑: 以「不重寫」為原則，透過前後端切割、抽取內部元件、路由分流逐步演進。
- API 相容性: 一旦公開 API，需長期維持相容性，讓服務可獨立升級而不牽一髮動全身。
- 進入門檻: 必備分散式架構能力、成熟研發流程（CI/CD、自動化測試）、健全營運基礎建設。
- 戰略節制: 能不拆就不拆，切到「剛好夠用」即可，避免為切而切導致效益不成、成本先爆。

## 全文重點
本文以實務導入視角，釐清微服務是解決問題的方法而非目標。微服務的核心在於依據業務邏輯及組織協作邊界，將單體系統拆解為小而專注、自主且可獨立部署的服務，並以 API 連結。然而分散式本質帶來通訊不可靠、資料一致性、跨服務除錯與追蹤等高複雜度，若僅以技術熱潮「能拆就拆」，不僅看不到效益，還會付出高昂維運成本。正確姿勢是先辨識問題與目標，依「技術適合且與流程對齊」的服務邊界漸進拆分。

作者強調「模擬世界、加以處理」的物件導向精神可上升到微服務：服務關係應映射真實商業流程與組織分工，才能具備良好適應與演進能力。以 Stack Overflow 架構為例，微服務加上容器能自然支持技術異質性，讓團隊可在各服務選用最佳技術組合，不再受限於單一平台。容器相對 VM 具近原生效能、低成本製像與傳遞、生態成熟；Windows Container 與 Hyper-V Container 更進一步降低 .NET 團隊採用容器與跨平台部署的摩擦。

在演進策略上，作者主張「重構優先、避免重寫」。提出三類漸進重構法：其一，新增功能不再注入單體，透過路由將新功能導向新服務，必要時以暫時性的 Glue Code 過橋；其二，粗粒度將單體一分為二為前後端，明確定義 API 並維持相容性，之後持續細化；其三，抽取內部元件成獨立服務，透過 REST 介面替代原本的內部呼叫，但須警覺遠端呼叫效能與可靠性成本，後續需再優化設計。

最後點出微服務的三大門檻：分散式系統架構能力（跨服務除錯、追蹤、韌性設計）、開發流程成熟度（API 版本管理、相容性、CI/CD、自動化測試與套件管理）、營運流程與基礎建設（規模化部署、監控、日誌、容器與編排）。若未同步升級這三面向，再好的切割也將在維運中崩潰。總結而言，微服務適用於確有痛點且團隊工程能力到位的情境；採取自上而下的業務導向設計與自下而上的漸進重構，切到剛好足夠，才是穩健落地之道。

## 段落重點
### 寫在前面
作者暫停三個月撰文，期間專注於「還債與充電」，透過多場分享與線上課程累積微服務與 Windows Container 的實務經驗。四個場合各自聚焦：DevOps Taipei 談微服務導入陷阱與案例；Study4.TW 面向 .NET 開發者介紹 Windows Container 與容器化對 DevOps 的意義；TibaMe 線上課系統化講解 Docker/微服務背景與實作；TibaMe 線上小聚以互動與 Lab 實操為主。文字可更精準傳遞內容，本文旨在整合演講精華，聚焦觀點與經驗，後續將補充更多實作細節與程式碼。

### "微服務" 是什麼?
微服務是將單體系統拆成多個以 API 聯結的小服務，目的是以拆解複雜度換取可維護性：大型系統維護成本呈超線性上升，拆成小服務可趨近線性。然而微服務本質是分散式系統，會引入通訊不可靠、資料一致性、跨服務除錯等挑戰。關鍵不在「能切就切」，而是「為何而切、怎麼切」。切割準則應從業務與組織流程出發，讓服務邊界映射實際運作（康威定律），而非只看技術上的高內聚低耦合指標。作者以 OOP「模擬世界、加以處理」的理念類比：把物件提升為服務，讓服務互動對應真實流程，系統才能在需求變動下保持彈性。設計時，建議用 Use Case 與微服務關係圖互相對照，若流程合理但技術困難，應先重構系統再行拆分，避免本末倒置。

### 使用微服務的理由 - 容許技術異質性
以 Stack Overflow 架構為例，核心用 .NET，周邊採 Redis、Elastic、HAProxy 等 OSS，展現以架構與問題導向選擇最佳解，而非被語言/平台綁死。微服務搭配容器將此優勢最大化：容器接近原生效能、製像容易、Registry 生態完善，部署與分發遠勝 VM。Windows Container 的成熟，讓 .NET 團隊也能低摩擦擁抱容器與異質組合；Docker 與 Microsoft 對 Hyper-V Container 支援 Linux 容器的走向，更使跨 OS 執行成為日常，實現真正的「Run Everywhere」體驗。結論：容器化是微服務落地與異質選型的關鍵推手。

### 重構: 找出服務邊界，將之切割為獨立的服務
導入微服務應優先重構而非重寫，以提升成功率與降低風險。作者從「重用層級」回顧演進路徑：從共用程式碼、共用函式庫、元件（獨立程序）、到服務（獨立實體/節點），越往上隔離越強、部署越彈性。若難以一步到位，先向上一層抽離，逐步提升隔離與自治。提出三種重構策略：1) 停止擴大單體，新增功能獨立服務，前端以路由分流；必要時用暫時性的 Glue Code 過橋，待全面服務化後移除。2) 粗粒度將單體切為前後端兩個服務，嚴謹定義 API 並維持相容性，再持續內部重構與去重。3) 抽取內部元件為獨立服務，雙向以 REST 介面替代本地呼叫，但需留意遠端呼叫的效能衰減與可靠性風險，後續再優化架構設計。核心原則：想清楚切點與 API 穩定性，分階段、可回退、可驗證。

### 微服務架構的進入門檻
微服務不是萬靈丹，過度設計將先吞噬成本。作者歸納三大前置門檻：1) 分散式系統架構能力：面對跨服務除錯、追蹤、日誌聚合、失敗與延遲的常態，需設計韌性與可觀測性。2) 開發流程成熟度：多服務並行要求 API 版本管理與相容性、套件與相依治理、自動化測試、CI/CD 與可復現環境；若每次變更牽動整體升級，即違背微服務獨立演進的價值。3) 營運流程與基礎建設：服務/實例數量暴增，沒有標準化部署、容器/編排、監控告警、配置與金絲雀/滾動更新，維運將失控。結語：先評估團隊工程成熟度與痛點是否足以支撐，再審慎導入，穩步演進勝於一次到位。

## 資訊整理

### 知識架構圖
1. 前置知識：學習本主題前需要掌握什麼？
- 分散式系統基本概念（網路不可靠、延遲、資料一致性）
- 物件導向與系統分析觀念（UML use case、內聚/耦合、邊界劃分）
- API 設計與 REST/HTTP 基礎、版本相容性
- 容器與 Docker（含 Windows Container、映像檔、Registry）
- DevOps 流程（CI/CD、自動化測試、部署、監控與日誌）

2. 核心概念：本文的 3-5 個核心概念及其關係
- 微服務的本質：以小而自治的服務透過 API 組合應用，是「解法」不是「目標」
- 邊界劃分：以業務流程/組織分工為主，技術適配為輔（康威定律）；避免過度切割
- 逐步重構路徑：從單體到微服務的可執行策略（停擴、前後端切分、抽取內部模組）
- 技術異質性：透過容器與標準協議，採用各服務的最佳技術組合
- 進入門檻：分散式架構、開發流程、營運流程三關缺一不可

3. 技術依賴：相關技術之間的依賴關係
- 微服務運作依賴穩定的 API 設計與版本治理
- 容器（Docker/Windows Container/Hyper-V Container）提升部署一致性，支撐異質技術並行
- 請求路由（Reverse Proxy/API Gateway/HAProxy）作為前端入口與灰度/導流基礎
- 登錄與映像（Registry/Dockerfile）作為建置與分發的基礎設施
- DevOps/CI-CD 與自動化測試支撐高頻率小變更；集中式日誌與追蹤支撐問題定位

4. 應用場景：適用於哪些實際場景？
- 單體應用隨規模成長，維護與協作成本急遽上升
- 需要不同技術棧組合以取得最佳解（如 .NET Web + Linux 上的 Redis/Elastic/HAProxy）
- 需要獨立部署/彈性擴縮的子域或新功能
- 組織已具備基本 DevOps 能力，期望加速交付與提升可靠性
- .NET 團隊導入容器化（Windows Container）並計畫逐步微服務化

### 學習路徑建議
1. 入門者路徑：零基礎如何開始？
- 釐清「為何要微服務」：當前痛點盤點與目標界定
- 補齊基礎：REST/API 設計、分散式系統常識、OOP 與邊界劃分（用 use case 思考）
- 動手實作入門容器：安裝 Docker（含 Windows Container），撰寫簡單 Dockerfile 與映像推送
- 讀一篇案例架構（如 Stack Overflow 公開架構）理解技術異質性價值

2. 進階者路徑：已有基礎如何深化？
- 練習三種重構策略：停擴→前/後端切分→抽取內部模組，做小型 PoC
- 建立 API 版本治理、向前相容與契約測試
- 佈建基本 DevOps：CI/CD pipeline、自動化測試、映像版控、環境一致性
- 建立集中式日誌與分散式追蹤，規劃問題定位流程

3. 實戰路徑：如何應用到實際專案？
- 選定一個新功能以「新服務＋路由導流」方式上線（策略 #1）
- 對單體做「前後端切分」（策略 #2），定義穩定 API，保留 Glue Code 作過渡
- 將高內聚模組抽出為獨立服務（策略 #3），並逐步移除冗餘與轉接碼
- 容器化部署全鏈路：映像建置、Registry、預備藍綠/金絲雀釋出與回滾
- 持續優化：性能監測、遠端呼叫失效率治理、容量與成本評估

### 關鍵要點清單
- 微服務是手段不是目標: 先釐清問題與目標再決定是否導入，避免為技術而技術 (優先級: 高)
- 邊界以業務為先: 以業務流程與組織分工對齊（康威定律），技術適配其次 (優先級: 高)
- 避免過度切割: 切到「剛好夠用」即可，過度拆分只會增加成本 (優先級: 高)
- 分散式的代價: 網路不可靠、延遲與一致性挑戰，跨服務除錯更難 (優先級: 高)
- 異質技術組合的價值: 以容器與標準協議整合各服務最佳解，脫離單一技術棧束縛 (優先級: 中)
- 容器是關鍵推手: Docker/Windows Container/Hyper-V Container 降低部署門檻、提升一致性 (優先級: 高)
- 重構策略 #1（停擴）: 新功能以新服務承載，前端透過路由導流，減少單體繼續變大 (優先級: 高)
- 重構策略 #2（前後端切分）: 以 API 為界快速二分單體，後續再逐步內部優化 (優先級: 高)
- 重構策略 #3（抽取模組）: 將高內聚模組抽為服務，短期以 Glue Code/REST 轉接 (優先級: 中)
- Glue Code 的角色: 作為過渡期橋接，非對外 API，將來應被移除 (優先級: 中)
- API 版本與相容性: 維持向前相容，確保服務能獨立升級與部署 (優先級: 高)
- 開發流程要求: 建立 CI/CD、自動化測試、依賴與版本治理，否則效益被折抵 (優先級: 高)
- 營運與部署能力: 監控、集中日誌、追蹤、批量部署能力是微服務存活線 (優先級: 高)
- 性能權衡: 本地呼叫與遠端 API 效能量級差異巨大，設計需考量延遲與吞吐 (優先級: 高)
- 用 use case 對照架構: 以 UML/use case 對齊服務切分，驗證設計與業務一致性 (優先級: 中)