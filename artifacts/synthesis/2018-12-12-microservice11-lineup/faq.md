# 微服務基礎建設 - 線上購物排隊機制設計 FAQ

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是電商「排隊機制」？
- A簡: 以號碼牌與四個指標控管流量，先來先服務，維持公平與可預期，保護結帳服務不被流量壓垮。
- A詳: 電商排隊機制是一種在高流量時保護結帳服務的秩序化控流設計。以號碼牌（token）代表每個請求，並維護四個核心指標：號碼機（CurrentSeed）、結帳起點（FirstCheckOutPosition）、排隊起點（LastCheckOutPosition）、排隊終點（LastQueuePosition）。達到「公平（先到先服務）」、「可觀測（可查順位、預估時間）」與「可控（限制同時結帳數、限制隊伍長度）」三目標，避免後端服務暴衝，並提供使用者良好的等待體驗。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, A-Q9, B-Q1

A-Q2: 為什麼需要排隊機制？
- A簡: 緩衝高峰流量、確保服務穩定、公平分配資源，提升體驗與交易成功率。
- A詳: 高流量活動（如雙十一）會造成後端結帳、驗證、計算等服務瞬間被壓垮。排隊機制能在前緣對請求「序化」，限制同時進入結帳的人數，避免後端資源爭用與失敗率飆升。同時提供使用者順位與預估時間，降低焦慮並減少無效重試。對系統而言，相當於引入緩衝與背壓，讓交易TPS穩定在可承受區間內，進而提高總體成交量與穩定性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q5, A-Q6, B-Q10

A-Q3: 排隊機制與「流量管控（Rate Limiting）」差異？
- A簡: 排隊機制決定「誰可進入」；流量管控決定「同時處理多少」。前者序化請求，後者限制速率。
- A詳: 排隊機制先在入口以FIFO與指標控制，決定哪些請求可以進入結帳階段；流量管控則在結帳處理點，限制每秒可處理的交易數量（TPS），避免資源飽和。兩者互補：排隊確保公平與體驗，流量管控確保穩定與成功率。文章中以餐廳比喻：排隊控制「入場順序」，流量管控控制「櫃台出菜速度」。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q4, B-Q14, C-Q5

A-Q4: 排隊機制與「斷路器/熔斷」有何不同？
- A簡: 熔斷是最後防線，排隊是前置引導。排隊避免暴衝；熔斷在無法服務時果斷拒絕。
- A詳: 熔斷（Circuit Breaker）用於服務故障或延遲過高時，快速失敗避免雪崩，是「不得已的最後一道防線」。排隊機制則是前端主動控流，透過序化與限制隊伍長度，讓後端保持可承載狀態，盡量避免觸發熔斷。設計上應以排隊＋流量管控為常態方案，熔斷保留給不可控的異常情境。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q10, D-Q8

A-Q5: 什麼是 QoS？排隊如何體現 QoS？
- A簡: QoS是服務品質；排隊以可預期、公平、穩定處理速率維持體驗與成功率。
- A詳: QoS（Quality of Service）指服務對使用者的穩定性與體驗品質。排隊機制透過公平的順位、清楚的狀態回饋與預估時間，讓尚未被服務者也獲得良好體驗；同時配合流量管控維持穩定TPS，避免大量失敗或逾時。這種「質量並重」的設計，是電子商務在高峰期間維持正向口碑與營收的關鍵。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q6, B-Q12

A-Q6: 什麼是 TPS？與排隊的關係是？
- A簡: TPS是每秒交易數。排隊確保TPS維持在可承受範圍，避免因暴衝導致失敗。
- A詳: TPS（Transactions Per Second）衡量系統每秒可完成交易數。排隊機制將請求序化並管制同時進入結帳的人數，搭配後端流量管控，讓TPS穩定在系統容量內，減少逾時與錯誤。穩定TPS代表高成功率與較低成本（如降低不必要的重試與IOPS），進而提高整體成交量。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q14, D-Q8

A-Q7: 什麼是「公平性」？為何重要？
- A簡: 公平性是先來先服務（FIFO），避免後來居上；提升信任與體驗，也是稀缺資源必須。
- A詳: 公平性代表隊伍遵守FIFO，不出現後到者插隊。對限量商品或高峰活動特別重要，避免爭議與負面觀感。設計上以單調遞增的token與不回收重複發號，結合四指標控制，確保順位僅由時間先後決定（除非使用者自行離隊或超時），構成系統信任的基礎。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q9, D-Q3, C-Q8

A-Q8: 什麼是「Pooling（輪詢）」？為何採用？
- A簡: 客戶端定期查詢狀態。簡單、健壯，適合高峰環境下的大量使用者。
- A詳: Pooling是客戶端每隔固定時間向伺服器查詢狀態。相對推播，輪詢在高併發下更易水平擴充且容錯性佳。本文以輪詢配合O(1)查詢（計算順位=token−排隊起點），將大量狀態查詢的成本降到最低，並藉由最後查詢時間記錄支撐超時判斷與回收。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q4, B-Q8, D-Q5

A-Q9: 排隊機制的四個核心指標是什麼？
- A簡: 號碼機、結帳起點、排隊起點、排隊終點。共同定義隊伍範圍、順位與容量。
- A詳: 四指標分別為：號碼機（CurrentSeed，下一張號碼值）、結帳起點（FirstCheckOutPosition，已完成清除的最前位置）、排隊起點（LastCheckOutPosition，可入場的臨界點）、排隊終點（LastQueuePosition，允許排隊的上限）。它們以最小狀態量，完成序化、順位計算、容量限制、與回收掃描範圍界定。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, B-Q5, C-Q1

A-Q10: 什麼是「Token（號碼牌）」？
- A簡: 代表使用者在隊伍中的唯一編號，單調遞增，不重複發放，用於定位與計算順位。
- A詳: Token是進入隊伍的唯一識別，來源為號碼機單調遞增產生。以token與四指標即可推算是否可入場、當前順位與是否超出隊伍範圍。Token也關聯最後查詢時間，供超時回收判定。實務上可與使用者ID綁定並簽名，避免偽造與重放攻擊。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q3, B-Q7, D-Q6

A-Q11: 為何強調 O(1) 查詢與降低 IOPS？
- A簡: 大量輪詢若非O(1)會放大成本；低IOPS設計可降費用並提升穩定性。
- A詳: 排隊中大多數動作是「查詢狀態」。若每次查詢是O(n)，在大量使用者與高頻率輪詢下會膨脹為O(n^2)，拖垮儲存與計算。以四指標與token做O(1)計算，把複雜度集中在少數事件（取號、離隊、回收）上，再配合快取，能大幅降低storage IOPS與成本。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q8, D-Q1, C-Q3

A-Q12: 如何估算等待時間？
- A簡: 等待順位=token−排隊起點，乘以近段平均處理時間，快速估算剩餘時間。
- A詳: 排隊順位可O(1)計算：順位=token−LastCheckOutPosition。以近期的平均處理時間（可採滑動窗口）乘以順位，即得預估等待時間。此計算可於服務端統一統計，客戶端僅取回估算結果或必要指標，降低重複運算與後端壓力。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q12, B-Q27, C-Q3

A-Q13: 如何避免不必要的排隊？
- A簡: 比較號碼機與排隊終點；超出即拒絕取號，並可提供替代方案。
- A詳: 若下一張號碼（號碼機）已大於排隊終點，代表隊伍已達上限，允許取號只會徒增等待與壓力。此時應直接拒絕，並可回傳補償（如折價券）或通知選項。此策略節省用戶與伺服器資源，亦避免過長隊伍帶來的負面體驗。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q8, D-Q9

A-Q14: 如何處理離線/放棄排隊？
- A簡: 記錄最後查詢時間，超過門檻即回收；或顯式離開移除，騰出名額。
- A詳: 每次輪詢更新token最後查詢時間。背景回收程序定期掃描四指標界定範圍，將超過閾值未回報者標為TIMEOUT並移除；顯式離開則標記為LEAVE並更新指標。此法確保座位不被幽靈佔用，隊伍能持續前進。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, C-Q4, D-Q2

A-Q15: 為何在此案例強調 POC/MVP/Fast Fail？
- A簡: 以最小實作快速驗證可行性與指標，降低風險，促進團隊溝通與迭代。
- A詳: 以數百行C#原型，聚焦核心演算法與API，先驗證公平、O(1)查詢、回收機制與監控指標是否成立，再逐步產品化。這種MVP/快速失敗策略能於早期確認方向、建立共同語言、同時產出生產可用的metrics定義，讓後續工程化落地更順暢。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q13, B-Q12, C-Q6

A-Q16: DevOps 觀點：何謂「開發期就設計可維運」？
- A簡: 在POC即定義可觀測性與指標，確保上線後可監控、可調參、可診斷。
- A詳: DevOps不僅是自動化與部署，更是把「可維運」前置到設計階段。本文在模擬中即輸出CSV metrics、設計四指標、可調窗口與限流參數、與人工介入（剔除用戶）能力。這些設計讓系統在上線後可被觀測、調整與持續優化，降低營運風險。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q12, C-Q6, D-Q8


### Q&A 類別 B: 技術原理類

B-Q1: 演算法整體如何運作？
- A簡: 以四指標與token驅動流程：取號、輪詢、入場、結帳、回收，少量更新，查詢O(1)。
- A詳: 技術原理說明：以號碼機發號、四指標界定範圍與容量。流程：初始化（設席位數與隊長）、TryGetToken取號、CanCheckout依排隊起點判定可否入場、完成後移動排隊指標、批次回收TIMEOUT/LEAVE並可能推進結帳起點。關鍵步驟：把頻繁操作（查詢）設計為O(1)，把昂貴操作（掃描）限縮至指標範圍。核心組件：CheckoutLine、TokenInfo、Recycle Worker、Rate Limiter（於結帳階段）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q9, B-Q8, C-Q1

B-Q2: 初始化四指標的設定流程？
- A簡: 依席位與隊長設定結帳起點、排隊起點、排隊終點、號碼機，決定初始可入場與可排隊範圍。
- A詳: 技術原理：席位=可同時結帳量。初始化時，發號從1開始；可入場區間=1..席位；排隊區間緊接其後，長度=隊長。步驟：1. FirstCheckOutPosition=0；2. LastCheckOutPosition=席位；3. LastQueuePosition=席位+隊長；4. CurrentSeed=1。核心組件：CheckoutLine建構子接收checkoutWindowSize與queueWindowSize，計算四指標。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, C-Q1, B-Q5

B-Q3: 取號 TryGetToken 如何設計？
- A簡: 成功時取走當前號碼機值並遞增；若超過排隊終點則拒絕，避免無謂排隊。
- A詳: 技術原理：以原子操作取得CurrentSeed並遞增，確保不重複發號。關鍵步驟：1. 檢查CurrentSeed<=LastQueuePosition；2. 成功則回傳token，並為其建立TokenInfo；3. 失敗回false。核心組件：CheckoutLine.TryGetToken(ref long token)、TokenInfo（記錄最後查詢時間供超時）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, C-Q2, D-Q9

B-Q4: 可否入場的判斷（CanCheckout）如何運作？
- A簡: 比較token與排隊起點；token<=排隊起點即可入場；同時可刷新最後查詢時間。
- A詳: 技術原理：將token與LastCheckOutPosition比較，若token<=LastCheckOutPosition代表已輪到。關鍵步驟：1. 驗證token存在且未LEAVE/TIMEOUT；2. refresh=true則更新LastCheckTime；3. 回傳true/false。核心組件：CheckoutLine.CanCheckout(token,bool refresh)、TokenState維護。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, A-Q11, C-Q3

B-Q5: 結帳完成後指標如何移動？
- A簡: 當用戶離開，向後推進排隊起點與排隊終點；釋放名額讓下一位入場。
- A詳: 技術原理：Remove(token)後，表示座位釋放。關鍵步驟：1. 標記token為LEAVE；2. LastCheckOutPosition++（放行下一位）；3. LastQueuePosition++（允許多一人加入排隊）；核心組件：CheckoutLine.Remove(token)負責更新狀態與移動窗口，確保入場與排隊窗口滑動。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q6, B-Q7, C-Q5

B-Q6: 如何清除已完成區塊並更新「結帳起點」？
- A簡: 連續完成的一段區塊可推進結帳起點，縮小掃描範圍，降低回收成本。
- A詳: 技術原理：當隊首連續token已LEAVE/TIMEOUT，FirstCheckOutPosition可一路向右推進至下一個仍在隊伍中的token。關鍵步驟：1. 檢查FirstCheckOutPosition後續是否連續完成；2. 批次推進；3. 收斂掃描邊界。核心組件：CheckoutLine內部狀態維護、Recycle流程中同時嘗試推進。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, B-Q7, D-Q7

B-Q7: 超時偵測與回收（Recycle）機制如何執行？
- A簡: 以最後查詢時間判斷TIMEOUT，定期掃描四指標範圍移除，釋放名額。
- A詳: 技術原理：輪詢時更新TokenInfo.LastCheckTime。Recycle每秒掃描[FirstCheckOutPosition, CurrentSeed)範圍，若現在−LastCheckTime>timeout，標記TIMEOUT並呼叫移除流程。關鍵步驟：定期執行、控制掃描範圍、批次處理。核心組件：CheckoutLine.Recycle()、TokenInfo、狀態枚舉。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q14, C-Q4, D-Q2

B-Q8: 範圍掃描與O(1)/O(n)如何分工？
- A簡: 把頻繁查詢設計成O(1)，將O(n)限制在回收與批次推進，降低平均成本。
- A詳: 技術原理：查詢順位與可入場判斷只做常數運算；昂貴的掃描僅在Recycle與推進結帳起點時執行，且掃描區間受四指標約束。關鍵步驟：1. 明確分層操作成本；2. 快取不常變動的指標；3. 只在事件觸發時更新。核心組件：四指標、Recycle、快取與原子操作。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, D-Q1, C-Q6

B-Q9: 公平性如何以單調遞增token保證？
- A簡: 嚴格單調發號不回收重用；入場只依token相對於排隊起點的先後。
- A詳: 技術原理：CurrentSeed只增不減，token唯一且不重用。入場條件token<=LastCheckOutPosition，隊伍不排序、不跳躍。關鍵步驟：1. 發號原子化；2. 移除只針對狀態，不變更其他token相對次序；3. 推進指標只朝右。核心組件：CheckoutLine.TryGetToken/Remove、狀態機、原子操作。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, D-Q3, C-Q8

B-Q10: 如何用「排隊終點」限制隊伍長度與過載？
- A簡: 當號碼機超過排隊終點，拒絕取號；維持合理候補，避免資源浪費。
- A詳: 技術原理：LastQueuePosition定義最大可排隊位置；CurrentSeed>LastQueuePosition即拒發號。關鍵步驟：1. 取號前檢查；2. 可配動態調參以應對流量；3. 提供替代流程（例如回饋）。核心組件：CheckoutLine.TryGetToken、運維側調參能力。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q13, C-Q8, D-Q9

B-Q11: CheckoutLine API 與核心組件是什麼？
- A簡: API含取號、查狀態、可入場、移除、回收；組件含四指標、TokenInfo、狀態列舉。
- A詳: 技術原理：類別封裝隊伍行為。關鍵步驟/流程：1. TryGetToken(ref token)；2. TokenState(token, refresh)；3. CanCheckout(token, refresh)；4. Remove(token)；5. Recycle()。核心組件：四指標屬性（CurrentSeed/First/LastCheckOut/LastQueue）、TokenInfo（LastCheckTime）、CheckoutStateEnum（NORMAL/LEAVE/TIMEOUT/NOTEXIST）。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, C-Q1, C-Q2

B-Q12: 如何設計監控與CSV輸出？
- A簡: 以固定頻率輸出指標與業務計數到CSV，EXCEL畫圖驗證設計與效能走勢。
- A詳: 技術原理：在模擬階段即內建Metrics蒐集，含四指標與關鍵計數（排隊中、結帳中、成功、放棄等）。關鍵步驟：1. MonitorWorker定期輸出；2. 以毫秒時間戳排序；3. 交由EXCEL製圖檢驗是否逼近理論上限。核心組件：檢測迴圈、檔案輸出、圖表分析。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q16, C-Q6, D-Q8

B-Q13: 單元測試如何驗證演算法？
- A簡: 以初始化、取號、窗口滑動、回收等情境撰寫測試，確保邏輯正確。
- A詳: 技術原理：針對可確定的狀態轉移寫明確斷言。關鍵步驟：1. 驗證初始四指標；2. 取號成功/失敗分支；3. 入場與移除推進窗口；4. TIMEOUT回收與結帳起點推進。核心組件：測試框架（如MSTest）、可重現資料、最小可運行原型。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q15, C-Q7, D-Q7

B-Q14: 與Rate Limiter整合的流程？
- A簡: 排隊放人入場後，結帳環節由限流器控速，確保TPS穩定與成功率。
- A詳: 技術原理：將限流器放在「開始結帳」區段，確保後端處理不超負載。關鍵步驟：1. CanCheckout=true→進入結帳；2. 調用rate.AcquireRequestAsync()；3. 執行交易邏輯；4. 成功後Remove(token)。核心組件：Rate Limiter、CheckoutLine、業務處理器，三者串接形成完整控流。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q3, C-Q5, D-Q8


### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何用C#建立CheckoutLine並初始化隊列？
- A簡: 以席位、隊長、超時秒數建構CheckoutLine；重用單例，避免重複開新隊伍。
- A詳: 步驟：1. new CheckoutLine(checkoutWindowSize, queueWindowSize, timeoutSec)；2. 以DI或static持有單例；3. 多店面則一店一實例。程式碼：CheckoutLine engine=new CheckoutLine(10,100,5); 注意：重複new會變成新隊伍；實例生命週期應受控；參數由運維可調。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q2, B-Q11, C-Q9

C-Q2: 如何設計Web API：取號、查狀態、離隊？
- A簡: 提供/token、/status、/leave端點；分別映射TryGetToken、CanCheckout/TokenState、Remove。
- A詳: 步驟：1. POST /token→呼叫TryGetToken；2. GET /status?token=→回CanCheckout與順位；3. POST /leave→Remove(token)。程式碼要點：回傳狀態枚舉與可選refresh；保護ID與token對應。注意：超過LastQueuePosition時回適當錯誤碼與替代建議。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q3, B-Q4, D-Q6

C-Q3: 前端如何實作輪詢並顯示順位與預估時間？
- A簡: 以固定間隔呼叫/status，顯示順位(token−排隊起點)與估時(順位×平均耗時)。
- A詳: 步驟：1. 取號成功後進入輪詢；2. 每400~1000ms呼叫/status；3. 顯示「是否可入場」、「當前順位」、「預估剩餘時間」；4. 入場即導引至結帳。程式碼：setInterval→fetch /status。注意：間隔取決於容量；以快取或CDN提供指標值可減伺服器壓力。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q8, A-Q12, D-Q5

C-Q4: 如何實作回收（Recycle）與超時策略？
- A簡: 啟動背景工作每秒掃描範圍，若現在−最後查詢>timeout則移除並推進指標。
- A詳: 步驟：1. 啟一個背景Thread/HostedService；2. 每1s呼叫engine.Recycle()；3. 以配置設定timeout秒；4. 彙整回收量供監控。程式碼：new Thread(()=>{while(!stop){Thread.Sleep(1000);engine.Recycle();}}).Start(); 注意：掃描範圍受四指標限制；避免長時間鎖定。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q7, D-Q2, C-Q6

C-Q5: 如何整合Rate Limiter控制結帳併發？
- A簡: 入場後呼叫限流Acquire再執行交易；成功後Remove釋放，保TPS穩定。
- A詳: 步驟：1. if (engine.CanCheckout(token)){ await rate.AcquireRequestAsync(); 執行結帳; engine.Remove(token);} 2. 將限流閾值對齊後端容量；3. 監控成功率與延遲動態調整。程式碼：rate.AcquireRequestAsync().Wait(); 注意：入場即離開隊列，避免重複統計。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q14, A-Q3, D-Q8

C-Q6: 如何輸出Metrics CSV並用EXCEL畫圖？
- A簡: 以固定頻率輸出四指標與業務計數至CSV，貼進EXCEL做時序圖觀察走勢。
- A詳: 步驟：1. MonitorWorker每300ms輸出：seed、since、until、limit、排隊/結帳中、成功/放棄等；2. 以毫秒SN排序；3. 匯入EXCEL→折線圖對比。程式碼：File.AppendAllText(logfile,$"{ts},{metrics...}\n"); 注意：時間同步與採樣頻率影響解讀；持續調整想看的指標。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q12, A-Q16, D-Q8

C-Q7: 如何撰寫單元測試驗證核心邏輯？
- A簡: 針對初始化、取號、入場、移除、回收撰寫斷言；確保指標與狀態轉移正確。
- A詳: 步驟：1. 驗證初始：First=0、LastCheckOut=席位、LastQueue=席位+隊長、Seed=1；2. TryGetToken成敗路徑；3. CanCheckout前後順位變化；4. Remove後窗口滑動；5. Recycle後TIMEOUT移除。程式碼：Assert.AreEqual(...)。注意：涵蓋邊界與連續完成區塊推進。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q13, B-Q6, D-Q7

C-Q8: 如何動態調整排隊上限並維持公平？
- A簡: 調整隊長與席位對應LastQueue/LastCheckOut；保持單調滑動，不改已發號順位。
- A詳: 步驟：1. 以運維面板調整checkoutWindowSize/queueWindowSize；2. 實時計算新的LastQueuePosition；3. 僅向右滑動避免影響已在隊中的token排序。注意：縮小隊長需謹慎，避免大量拒號；所有改變應可觀測並回退。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: B-Q10, B-Q9, D-Q9

C-Q9: 如何支援多店（多隊列）管理？
- A簡: 一店一路徑或一實例；以店ID對應CheckoutLine；確保實例生命週期與隔離。
- A詳: 步驟：1. 以字典<店ID, CheckoutLine>管理；2. 取號/查詢/離隊皆需帶店ID；3. 可用DI容器註冊工廠；4. 水平擴充時以分片或一致性雜湊分配。注意：跨實例需共享狀態（未實作時可先單機驗證）。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q11, D-Q7

C-Q10: 如何將原型部署為微服務並保高可用？
- A簡: 將API容器化、無狀態化，指標持久化至共享儲存；加上健康檢查與自動伸縮。
- A詳: 步驟：1. 抽出REST API；2. 以容器部署多副本；3. 四指標/TokenInfo放共享儲存（如快取/資料庫）；4. 增加健康檢查與Prometheus/雲監控；5. 設定HPA依QPS/延遲自動擴縮。注意：一致性、鎖與原子性需在分散式層面補上。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q15, B-Q8, D-Q7


### Q&A 類別 D: 問題解決類（10題）

D-Q1: 排隊查詢造成高IO/高IOPS怎麼辦？
- A簡: 以四指標實現O(1)查詢，避免全掃；配合快取與減少寫入頻率降IOPS。
- A詳: 症狀：輪詢頻繁導致儲存IO飆高、延遲上升。原因：每次查詢做O(n)搜尋或頻繁寫入。解法：改為以token與排隊起點O(1)計算順位；僅在事件時更新指標；將指標放快取；減少不必要持久化。預防：設計之初明確成本分工與快取策略，測試不同輪詢間隔。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q11, B-Q8, C-Q3

D-Q2: 使用者「永遠排不到」或卡住怎麼診斷？
- A簡: 檢查回收是否運作與指標是否推進；確認移除與窗口滑動邏輯正確。
- A詳: 症狀：順位不變、長時間無法入場。原因：Recycle未執行、移除未推進LastCheckOutPosition、結帳起點未批次前移。解法：檢視Metrics（排隊中/結帳中/指標變化）；確認回收執行頻率；修正Remove與推進邏輯。預防：加入健康檢查與告警，對指標長時間不動態勢發警。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q5, B-Q7, B-Q6

D-Q3: 出現「後來居上」不公平怎麼排查？
- A簡: 檢查發號是否單調、是否重用token、是否錯誤重排；確保只向右推進。
- A詳: 症狀：晚到token先入場。原因：發號非原子、token重用、排序操作、指標回退。解法：確保CurrentSeed原子遞增、禁止token回收重用、所有指標僅右移、入場條件唯依token≤排隊起點。預防：加單元測試覆蓋排序與指標不回退。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q9, C-Q7, A-Q7

D-Q4: 模擬或實際發生OOM/執行緒爆量怎麼辦？
- A簡: 限制同時工作數、使用SpinWait或工作佇列；改用Task與限流控制。
- A詳: 症狀：啟動大量模擬執行緒後OutOfMemory。原因：瞬間創建過多執行緒與堆疊占用。解法：以SpinWait控制Start節奏、SemaphoreSlim限制併發、優先用Task+佇列；分批投放負載。預防：壓測前先估算資源；在程式加入最大併發保護。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: C-Q5, C-Q6, B-Q14

D-Q5: Pooling造成後端壓力過大怎麼優化？
- A簡: 增加輪詢間隔、前置快取指標、合併請求；必要時分級輪詢或WebSocket。
- A詳: 症狀：查詢QPS飆高。原因：間隔過短、每次都打到核心儲存。解法：1. 動態調整輪詢間隔；2. 用快取或CDN提供排隊起點與平均耗時；3. 分級輪詢（接近入場→較頻繁）；4. 有條件地切WebSocket推播。預防：以Metrics觀察並設自動調節策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q8, C-Q3, B-Q12

D-Q6: Token丟失或遭偽造如何處理？
- A簡: 於伺服器側維護狀態，token與使用者ID綁定並簽名驗證，提供補票機制。
- A詳: 症狀：無效token查詢或冒用。原因：純客端保存、未驗簽。解法：在服務端保存TokenInfo，token加入簽名或隨機鹽，綁定使用者ID；提供重新取號流程。預防：過期token作廢；限制查詢速率與異常監控。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: A-Q10, C-Q2, B-Q11

D-Q7: 指標錯亂/數據不一致怎麼修復？
- A簡: 以原子操作或鎖保證一致；加入自檢程序自動糾正並告警。
- A詳: 症狀：指標逆向、重疊或步進異常。原因：併發更新未保護、批次移動遺漏。解法：關鍵更新加鎖或CAS、加入一致性檢查與修復（如校正至相容狀態）；回滾異常變更。預防：單元測試覆蓋邊界；監控指標合理性。
- 難度: 高級
- 學習階段: 進階
- 關聯概念: B-Q6, B-Q8, C-Q7

D-Q8: 結帳效能不佳如何診斷與優化？
- A簡: 觀察TPS、延遲與成功率；以Rate Limiter限流、找瓶頸（DB/外部服務）並調參。
- A詳: 症狀：延遲上升、失敗增加。原因：過載或下游瓶頸。解法：1. 限流器收緊TPS；2. 剖析交易流程（資料庫、外部API）；3. 加快快取與批次處理；4. 監控指標趨勢回饋調參。預防：容量規劃與壓測、動態限流策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q14, C-Q5

D-Q9: 排隊上限設得不當如何調整？
- A簡: 觀測拒號率與等待時間；調整隊長與席位，平衡體驗與成功率。
- A詳: 症狀：上限過低→拒號多；過高→等待過長。原因：參數未依容量與流量調校。解法：1. 以Metrics觀察（拒號率、平均等待、完成率）；2. 調整queueWindow與checkoutWindow；3. 餘裕時適當放寬。預防：建立自動化調參與告警閾值。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q10, C-Q8, B-Q12

D-Q10: 超時策略過嚴或過寬怎麼拿捏？
- A簡: 觀測TIMEOUT比例與回收速度；以滑動平均自動調整timeout並預先提醒。
- A詳: 症狀：過嚴→誤踢；過寬→佔位。原因：固定timeout不匹配實際網路/行為。解法：1. 監控TIMEOUT率；2. 動態調整timeout；3. 在接近閾值前提示用戶刷新；4. 區分VIP與一般用戶策略。預防：以A/B測試與活動前壓測校正。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q14, C-Q4, B-Q7


### 學習路徑索引

- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是電商「排隊機制」？
    - A-Q2: 為什麼需要排隊機制？
    - A-Q3: 排隊機制與「流量管控」差異？
    - A-Q4: 排隊機制與「斷路器/熔斷」有何不同？
    - A-Q5: 什麼是 QoS？排隊如何體現？
    - A-Q6: 什麼是 TPS？與排隊的關係是？
    - A-Q7: 什麼是「公平性」？為何重要？
    - A-Q8: 什麼是「Pooling（輪詢）」？為何採用？
    - A-Q9: 排隊機制的四個核心指標是什麼？
    - A-Q10: 什麼是「Token（號碼牌）」？
    - B-Q2: 初始化四指標的設定流程？
    - B-Q3: 取號 TryGetToken 如何設計？
    - B-Q4: 可否入場的判斷（CanCheckout）如何運作？
    - C-Q1: 如何用C#建立CheckoutLine並初始化隊列？
    - C-Q3: 前端如何實作輪詢並顯示順位與預估時間？

- 中級者：建議學習哪 20 題
    - A-Q11: 為何強調 O(1) 查詢與降低 IOPS？
    - A-Q12: 如何估算等待時間？
    - A-Q13: 如何避免不必要的排隊？
    - A-Q14: 如何處理離線/放棄排隊？
    - A-Q16: DevOps 觀點：何謂「開發期就設計可維運」？
    - B-Q1: 演算法整體如何運作？
    - B-Q5: 結帳完成後指標如何移動？
    - B-Q6: 如何清除已完成區塊並更新「結帳起點」？
    - B-Q7: 超時偵測與回收（Recycle）機制如何執行？
    - B-Q8: 範圍掃描與O(1)/O(n)如何分工？
    - B-Q9: 公平性如何以單調遞增token保證？
    - B-Q10: 如何用「排隊終點」限制隊伍長度與過載？
    - B-Q12: 如何設計監控與CSV輸出？
    - B-Q13: 單元測試如何驗證演算法？
    - B-Q14: 與Rate Limiter整合的流程？
    - C-Q2: 如何設計Web API：取號、查狀態、離隊？
    - C-Q4: 如何實作回收（Recycle）與超時策略？
    - C-Q5: 如何整合Rate Limiter控制結帳併發？
    - C-Q6: 如何輸出Metrics CSV並用EXCEL畫圖？
    - C-Q8: 如何動態調整排隊上限並維持公平？

- 高級者：建議關注哪 15 題
    - C-Q9: 如何支援多店（多隊列）管理？
    - C-Q10: 如何將原型部署為微服務並保高可用？
    - D-Q1: 排隊查詢造成高IO/高IOPS怎麼辦？
    - D-Q2: 使用者「永遠排不到」或卡住怎麼診斷？
    - D-Q3: 出現「後來居上」不公平怎麼排查？
    - D-Q4: 模擬或實際發生OOM/執行緒爆量怎麼辦？
    - D-Q5: Pooling造成後端壓力過大怎麼優化？
    - D-Q6: Token丟失或遭偽造如何處理？
    - D-Q7: 指標錯亂/數據不一致怎麼修復？
    - D-Q8: 結帳效能不佳如何診斷與優化？
    - D-Q9: 排隊上限設得不當如何調整？
    - D-Q10: 超時策略過嚴或過寬怎麼拿捏？
    - A-Q15: 為何在此案例強調 POC/MVP/Fast Fail？
    - A-Q16: DevOps 觀點：何謂「開發期就設計可維運」？
    - B-Q11: CheckoutLine API 與核心組件是什麼？