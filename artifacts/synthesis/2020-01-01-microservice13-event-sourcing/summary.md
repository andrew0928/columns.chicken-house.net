# 微服務架構設計 - Event Sourcing

## 摘要提示
- Event Sourcing: 儲存的是造成資料改變的事件歷程而非最終狀態，能回放還原任一時間點的狀態。
- 與CRUD差異: 事件日志只增不改不刪，使資料處理從CRUD轉為以Create/Append為主。
- CQRS搭配: 以命令/查詢責任分離，將寫入的事件序列化並以投影維護查詢視圖。
- 銀行存摺類比: 以時間序紀錄每筆異動與當下餘額，利於追溯、重算與補差。
- 成本與門檻: 換取可追溯與可還原的同時，增加儲存、運算與開發複雜度。
- Cloud Native思維: 在大規模下以最終一致與流式處理對應硬體故障與資料規模，非傳統強一致/集中式DB。
- Google啟示: 將計算送往資料端(MapReduce)、服務容錯與自癒，奠定雲原生與微服務基礎。
- 模式組合: Event Sourcing通常與訊息佇列、流處理、CQRS、DDD、NoSQL共同組成解法。
- 時效與延遲: 資料「發生時間」與「收到時間」不同步會放大，需以事件回放與多視圖統一處理。
- 校正回歸: 以事件驅動與報表視圖修正延遲資料，區分即時觀測與事後回填分析用途。

## 全文重點
本文從實務出發，說明何時需要採用Event Sourcing。Event Sourcing的核心是保存造成狀態改變的「事件」而非最終狀態；藉由完整且不可變的事件序列，可在任何時點重建狀態、追溯異常並重算補差。此模型使資料寫入由CRUD轉為Append-only，並常與CQRS搭配：命令端負責產生事件，查詢端則以事件投影維護各種查詢視圖，彌補以事件為中心不利頻繁即時計算最終結果的特性。銀行存摺是直觀比喻：每筆異動皆被記錄，且可在修正利息或錯帳後回放重建餘額；事件是「來源資料」，不同於僅供查閱難以重算的log。

作者將Event Sourcing置於Cloud Native脈絡解讀：雲時代在大規模與不可靠硬體下，系統需以軟體模式容錯、擴展與流式處理，強調最終一致、以訊息可靠傳遞取代鎖與交易。以Google經驗為例，MapReduce將「計算移向資料」，Bigtable等存儲強調多副本自癒，並透過容器、部署、自動化、服務發現等達成可擴展與可用。相較傳統正規化與JOIN在數量級上受限，雲原生模式傾向資料到達時即處理與複寫，查詢以O(1)鍵值與預先投影換取線性擴展能力。故Event Sourcing只是雲原生工具箱中的常用模式之一，往往不會單獨使用，而是與訊息佇列、流處理、CQRS、DDD、NoSQL一起成套設計。

在實務應用上，作者以交易/帳戶案例說明：必要知識包括Message Queue、Streaming、CQRS、DDD、NoSQL。系統藉事件流水與投影維持帳戶餘額、訂單狀態、聚合查詢，並以最終一致確保延遲到達資料仍能被修正。延伸到「校正回歸」的社會討論，本文將其抽象為「發生時間」與「收到時間」的不一致所致：即時性要求不斷提高，而資料收集與處理延遲難以同步縮短，必然導致事後回補與重算。正確做法是以事件化處理、定義延遲邊界、區分多種視圖：即時觀測、隔日/歷史報表、歷史修正通知。修正數據的歸屬應依用途決定：用於派工處置則算當日，用於趨勢分析則回填發生日。總結來說，掌握Event Sourcing與CQRS，能優雅處理時間維度帶來的一致性與延遲難題，滿足雲原生環境下的可追溯、可還原與可擴展。

## 段落重點
### 簡介: 什麼是 Event Sourcing ?
Event Sourcing理念是儲存「事件」而非「最終狀態」：完整保留狀態變遷的時間序，使系統能回放至任一時間點重建狀態。其系統特性包括：事件只增不改不刪，資料處理由CRUD簡化為Append；寫入端常搭配CQRS確保命令序列化與一致進入事件庫；查詢端以事件投影維護匯總視圖，彌補直接由事件計算最終結果的成本。以銀行存摺比喻，所有存提都依時間記錄並附當下餘額，好處是可追溯、可重算、能保留交易流水。當發現錯誤（如利息算錯），可修正並回放補差；事件作為來源資料可重建結果，log則多半只能查閱。代價是儲存與計算需求提升、開發門檻變高，若沒有明確需求並非萬靈丹。

### 雲端時代的架構設計觀念 - cloud native
作者從Google早期大規模系統經驗引出雲原生觀念：在大規模下硬體故障不可避免，應以軟體容錯與自癒設計（多副本、節點下線再建），資料處理以MapReduce將計算下沉至資料端，避開跨網路I/O瓶頸。這些促成容器化、部署自動化、健康檢查、服務註冊/發現等雲原生基石。從資料建模看，傳統關聯式正規化+JOIN追求強一致，但在規模上限與時延上受限；雲原生則於資料到達當下即處理與複寫，藉可靠訊息傳遞確保最終一致，查詢以預先計算的視圖/鍵值存取達成O(1)近似複雜度與線性擴展。Event Sourcing正是此思維中的常見模式，通常不會單獨使用，而是與訊息佇列、流式處理、CQRS、DDD、NoSQL共同形成整體架構。

### Event Sourcing 應用案例
實務上常見於交易/帳務等需要可追溯的領域。必要技術堆疊包含：Message Queue實現可靠傳遞與序列化、Streaming Data Processing做就地與即時投影、CQRS分離寫入命令與查詢視圖、DDD界定邊界上下文與聚合、NoSQL（K/V）支撐高併發低延遲查詢。以銀行帳戶為例，事件來源涵蓋存提、轉帳、利息計算等，命令端生成事件並寫入事件庫；查詢端透過投影更新餘額視圖、明細視圖、彙總視圖等，供不同報表與查詢使用。遇到規則修正或遲到事件，可回放事件重建或補償；跨服務的交易一致性則可配合Saga而非2PC。此模式在保留完整歷程的同時，透過多視圖換取查詢效率與擴展性。

### 校正回歸 - 談 資料處理的時效性
本文以「校正回歸」說明資料即時性與處理延遲的張力：資料有「發生時間」與「收到時間」，當即時呈現(A)的要求不斷提高，而資料收集/處理(B)的延遲無法同步降低，便會出現事後補正。以線上與門市交易為例，線上可即時上傳，門市可能隔日匯入；老闆同時想看到即時趨勢與事後完整數據。解法：以Event Sourcing按時間序處理與保留來源事件；以CQRS建立多種視圖以滿足不同用途——即時看板（僅含已達資料）、隔日/歷史報表（等待容忍延遲後產出）、歷史修正通知（遲到資料觸發修正）。同時需定義可容忍最大延遲與關帳點，超過走例外流程。修正數據是否回填發生日或計入當日，取決於業務用途：若用於派工處置則算當日，若用於趨勢分析則回填發生日。借助Event Sourcing+CQRS的時間維度建模，可兼顧可視性、正確性與系統可行性。

### #校正回歸 背後的現象...
進一步拆解「延遲到達」帶來的體驗落差：以時間線範例展示即時系統如何在資料尚未到齊時呈現不完整累計，而事後上傳又需回補。這不是工程怠惰，而是收集/審核/彙整流程本就耗時，當規模與即時性要求上升時問題被放大。工程上的務實做法是：分拆「即時資訊」、「歷史資訊（隔日/定期）」、「歷史修正通知」三類輸出；制定資料延遲SLA與關帳；在架構上以事件來源保真、視圖多態呈現、延遲可被追蹤與修正。核心能力是抽象化時間維度與用途導向的多視圖設計；而掌握Event Sourcing與CQRS，正是應對此類廣泛且不可避免現象的關鍵。

## 資訊整理

### 知識架構圖
1. 前置知識：學習本主題前需要掌握什麼？
- 分散式系統與雲原生思維（可用性、可擴展性、最終一致性）
- 訊息佇列與可靠通訊（序列化、重送、順序）
- NoSQL/Key-Value 存取模型與索引
- 基本資料建模與交易處理（CRUD vs append-only）
- 時間觀念：事件發生時間(event time) vs 接收/處理時間(processing/ingest time)

2. 核心概念：本文的 3-5 個核心概念及其關係
- Event Sourcing（事件溯源）：以事件作為唯一真相來源，追加寫入、可重放；為 CQRS/流式處理提供基礎資料
- CQRS（命令/查詢責任分離）：寫入走命令與事件，查詢走預先計算的讀模型；解耦性能與一致性
- Cloud Native 思維：接受故障、以軟體承擔可靠性、以資料為中心進行就地處理與複寫；追求最終一致性與 O(1) 查詢
- Streaming Processing（流式處理）：事件到達即處理，滾動更新聚合視圖；支援延遲資料的回補與更正
- 一致性與延遲管理：強一致性轉為最終一致性；定義最大可容忍延遲與關帳點，設計回填與修正流程

3. 技術依賴：相關技術之間的依賴關係
- 訊息佇列/事件日誌(Kafka/類似) → 提供事件序列化、順序、重送
- 事件存儲(Event Store/Append-only Log) → 永久保存事件，支援重播與快照
- 流式處理框架 → 消費事件即時計算聚合/讀模型
- CQRS 讀模型存儲（Key-Value/文件庫/搜尋引擎） → 以 O(1)/近 O(1) 查詢提供高效讀取
- DDD/聚合根 → 定義事件邊界與命令驗證；搭配 SAGA 處理分散式交易
- 補償/校正機制 → 延遲事件回補、重算聚合、通知修正

4. 應用場景：適用於哪些實際場景？
- 金融與交易帳務（銀行存摺、清算、拆帳、審計可追溯）
- 高規模雲原生系統（大資料量、需要線性擴展的讀取）
- 需要完整歷程追蹤與重播能力（法遵、稽核、Debug）
- 線上/離線混合、資料延遲不可避免的場景（門市晚到資料、疫情統計「校正回歸」）
- 分散式交易協調（非 2PC；以 SAGA/補償保證最終一致）

### 學習路徑建議
1. 入門者路徑：零基礎如何開始？
- 理解事件與狀態的差別；閱讀 Event Sourcing/CQRS 的入門文章（含 Fowler）
- 了解訊息佇列的基本概念（順序、重送、至少一次投遞）
- 用簡單範例實作：以 append-only list 儲存事件，重放產生狀態

2. 進階者路徑：已有基礎如何深化？
- 導入 DDD：以聚合根定義命令驗證與事件邊界
- 實作 CQRS：將寫入/讀取分離，建立讀模型（聚合視圖）
- 學會處理延遲與校正：事件時間 vs 處理時間、回填與重算、快照策略
- 掌握一致性模型與冪等性；瞭解 SAGA/補償交易

3. 實戰路徑：如何應用到實際專案？
- 建立最小可行系統：帳戶/交易的 ES + CQRS + 讀模型（Key-Value）
- 接入訊息佇列與流式處理，實作即時聚合、延遲事件回補與修正通知
- 設計營運規則：最大延遲/關帳點、校正回歸策略、多讀模型以對應不同報表需求
- 擴展：分散式交易以 SAGA 落地、觀測性/監控與重放工具

### 關鍵要點清單
- Event Sourcing 定義: 儲存「事件」而非最終狀態，支持任何時間點重建狀態 (優先級: 高)
- Append-only 模式: 僅追加不可變更，CRUD 轉為 CR，刪除多為封存 (優先級: 高)
- 事件 vs 日誌: 事件是來源資料可重放，日誌多為審計查閱難以重算 (優先級: 高)
- CQRS 分離: 寫入用命令產生事件，讀取用預先計算的讀模型 (優先級: 高)
- 讀模型/聚合視圖: 以查詢需求預先計算，支撐高效讀取與多視角 (優先級: 高)
- 流式處理: 事件到達即處理與更新視圖，降低查詢時計算成本 (優先級: 中)
- 雲原生取捨: 放棄強一致性，換取最終一致性與線性擴展 (優先級: 高)
- Key-Value 存取: 以 O(1) 模式替代關聯 Join 的 O(log n)/更高成本 (優先級: 中)
- 事件時間 vs 處理時間: 清楚區分並支援延遲資料的回補與校正 (優先級: 高)
- 校正回歸策略: 延遲資料回填至發生時間並重算讀模型，並發出修正通知 (優先級: 中)
- 最大延遲/關帳: 制定可容忍延遲窗口，逾時走例外/下期處理 (優先級: 高)
- 冪等性與重放: 設計命令/事件處理為冪等，支援重送與重播 (優先級: 高)
- 快照策略: 以快照加速重建狀態，平衡儲存與重放成本 (優先級: 中)
- SAGA/補償交易: 在分散式場景用補償動作取代 2PC，維持最終一致 (優先級: 中)
- 應用邊界判斷: 僅在需完整歷程、延遲回補、規模擴展時採 ES/CQRS (優先級: 高)