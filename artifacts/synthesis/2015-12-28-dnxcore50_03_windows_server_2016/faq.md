# .NET Core 跨平台 #3, 記憶體管理大考驗 - Windows Container (2016 TP)

## 問題與答案 (FAQ)

### Q&A 類別 A: 概念理解類

A-Q1: 什麼是 Windows Server 2012 R2 Server Core？
- A簡: Windows 2012 R2 的最小化安裝選項，無 GUI，僅命令列與核心服務，資源占用低，適合對照與伺服器工作負載。
- A詳: Server Core 是精簡化安裝，移除圖形介面，保留 PowerShell、cmd 等管理工具，降低攻擊面、更新量與資源占用。本文選 Server Core 作為對照組，讓各平台組態一致且干擾最小。雖無 GUI，也可在命令列執行 taskmgr.exe 開啟工作管理員，以觀察記憶體與處理程序行為，利於進行客觀的記憶體測試與比較。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q2, A-Q14, C-Q2

A-Q2: 什麼是 Windows Server 2016 Nano (Tech Preview 4)？
- A簡: 微軟極度精簡的伺服器版本，支援 Windows 容器，TP4 首度亮相，著重輕量與雲原生。
- A詳: Nano Server 是高度精簡、無本機登入、以遠端管理為主的 Windows 伺服器變體，在 2016 TP4 與容器技術一同亮相。它設計給雲端與容器場景，鏟除不必要元件以降低佔用與重新開機需求。本文在 TP4 上體驗 Windows 容器，並比較其在記憶體碎片測試中的表現，評估容器化對 .NET Core 記憶體行為與資源利用的影響。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q4, C-Q3

A-Q3: 什麼是 Windows Container？
- A簡: 以 Windows 核心為基礎的容器化技術，共用主機核心，隔離程序與檔案系統，與 Docker 工具相容。
- A詳: Windows Container 是在 Windows 上提供的容器技術，容器與宿主共用同一個內核，透過命名空間與檔案系統層隔離程序、檔案與網路等資源。管理工具與 API 與 Docker 相容，可使用熟悉的 docker CLI 或 PowerShell。由於共用內核，Windows 容器無法直接執行 Linux 映像；需使用 Windows 基底映像如 Server Core 或 Nano。本文在容器中執行 .NET Core 記憶體測試並與原生對照。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, B-Q4, C-Q3

A-Q4: 什麼是 Hyper-V Container？
- A簡: 為加強隔離，微軟在容器外再包一層輕量 VM，使容器獲得核心層級隔離。
- A詳: Hyper-V Container 是 Windows 容器的強化隔離模式。當需要核心層級隔離時，系統會自動以 Hyper-V 啟動一個精簡虛擬機器，並在其中承載容器。對使用者與工具而言仍是容器，但內部有獨立內核，避免與宿主共享內核造成風險。此模式結合 VM 的安全隔離與容器的部署效率，是多租戶或高安全需求場景的折衷方案。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q5, B-Q5, C-Q8

A-Q5: Windows Container 與 Hyper-V Container 有何差異？
- A簡: 前者共用宿主內核、較輕；後者以輕量 VM 隔離內核、更安全，代價是額外開銷。
- A詳: Windows Container（process/隔離模式）與主機共用內核，啟動快、資源效率高，但內核層面非完全隔離。Hyper-V Container 會為每個容器啟動精簡 VM，容器在 VM 內執行，獲得核心層級隔離與更強安全邊界。兩者管理體驗一致（docker CLI/PowerShell），但 Hyper-V 模式消耗更多資源、啟動較慢，適合多租戶與嚴格合規場景。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q4, B-Q5, C-Q8

A-Q6: Windows Container 與傳統 VM 有何差異？
- A簡: 容器共用宿主內核，啟動快、占用小；VM 內含完整客體 OS，隔離強、成本高。
- A詳: VM 透過虛擬化硬體執行一整套客體作業系統，提供強隔離但開銷大、啟動慢。容器重用宿主內核，僅封裝應用與依賴，透過命名空間與檔案系統層提供輕量隔離，啟動秒級、佔用小。本文觀察到宿主工作管理員可見容器內進程，即反映了共用內核的特性，與 VM 進程完全隔離的行為不同。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q4, A-Q17

A-Q7: 為何 Windows 容器不能直接使用 Linux 映像？
- A簡: 容器需共用宿主內核，Windows 與 Linux 內核不同，映像不可互通。
- A詳: 容器的核心即「內核共用」。映像中的使用者空間需在與之相容的內核上執行。Windows 容器映像（如 windowsservercore、nanoserver）依賴 Windows 內核，Linux 映像依賴 Linux 內核，互不相容。雖管理工具與概念可共用（Docker CLI、鏡像分層），但二者在系統呼叫與 ABI 層面不同，因此無法跨用。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, B-Q8

A-Q8: 什麼是 .NET Core 的 dnx.exe？
- A簡: 早期 .NET Core 執行環境（DNX）啟動程序，用於還原、建置與執行應用。
- A詳: DNX（.NET Execution Environment）是早期 .NET Core 工具鏈，dnx.exe 是其執行宿主，負責載入執行時、解析套件與啟動應用。本文以 dnx.exe 執行記憶體測試，工作管理員觀察到其記憶體使用達數 GB。雖後續已由 dotnet CLI 取代，但在本文場景下，dnx 即代表 .NET Core 應用宿主程序。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, C-Q1, C-Q4

A-Q9: 什麼是本文的「記憶體利用率」指標？
- A簡: Phase1 可分配總量為基準，Phase3 在碎片後可再取得的量做分子之比。
- A詳: 文中以三階段分配測試記憶體。Phase1 量測「無碎片時」能取得的記憶體總量；Phase2 刻意製造碎片；Phase3 再次嘗試分配。指標定義為 Phase3/Phase1，反映碎片化後可用記憶體之比例。例：2012R2 為 65.40%，2016 容器為 66.87%，可比較不同平台在碎片情境下的可用性。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q2, C-Q5

A-Q10: 為什麼要做記憶體管理大考驗？
- A簡: 驗證跨平台下 .NET Core 在碎片情境的可用記憶體與回收表現差異。
- A詳: 記憶體是效能與穩定的關鍵資源，跨平台執行時，作業系統、容器與工具鏈差異可能影響配置行為、回收與碎片。本文以一致流程在多平台測試，量化碎片後可用性，並對照容器與原生環境，以利選型與調校。結果顯示兩個 Windows 平台的利用率相近，容器化沒有帶來明顯劣化。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q15, A-Q16, B-Q1

A-Q11: 為何測試需連續執行兩次取第二次數據？
- A簡: 避免首次啟動包含還原、JIT、最佳化等額外成本影響測值。
- A詳: 第一次執行常伴隨套件下載/還原、JIT 編譯、快取初始化等行為，會扭曲目標指標（例如可用記憶體或分配速度）。第二次執行在相同環境下，已完成前述初始化，較能反映穩態行為。本文統一取第二次結果，增進跨平台比較的公平性與可靠性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q11, C-Q3, C-Q4

A-Q12: 什麼是記憶體碎片化（在本文脈絡）？
- A簡: 記憶體空間被分散為多個小區塊，難以再配置大型連續空間。
- A詳: 碎片化指釋放與配置交錯後，剩餘可用記憶體雖多，卻非連續，導致無法滿足大型配置需求。本文在 Phase2 刻意釋放部分區塊、打亂配置，形成碎片，再在 Phase3 嘗試配置以量測影響。結果顯示兩平台碎片後可用比例約六成多，反映碎片對可用性的實際衝擊。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: B-Q3, C-Q1

A-Q13: 什麼是分頁檔（pagefile），在測試中扮演何種角色？
- A簡: 磁碟上的虛擬記憶體延伸，物理記憶體不足時提供提交空間。
- A詳: 分頁檔是將部分記憶體交換到磁碟的機制，擴大可提交的虛擬記憶體上限。本文 2012R2 預設 4GB 分頁檔配合 1GB RAM，dnx.exe 可在 Phase1 申請逾 4GB 空間。監看圖可見實體記憶體先滿，後續主要使用分頁檔承載，反映出記憶體管理器的工作集與提交模型。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q10, C-Q6, D-Q7

A-Q14: 為何選擇 Server Core 作為對照組？
- A簡: 組態簡單、干擾少、資源占用低，利於公平比較與可重現性。
- A詳: 對照組需具備穩定、成熟、干擾少的環境。Server Core 移除 GUI 與多餘元件，資源佔用與背景活動較少，能降低非受測因素干擾。本文同時以相同測試步驟在 Server Core 與容器執行，對照容器化對可用記憶體的影響。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q10, B-Q1

A-Q15: Windows Container 的效能是否接近原生？
- A簡: 測試顯示記憶體利用率相近，容器化未見明顯劣化。
- A詳: 本文以相同程式、流程在 Server Core 與 Windows 容器測試，利用率分別為 65.40% 與 66.87%。差距不大，且宿主可見容器內進程，顯示共用內核降低額外開銷。結論是就此測項，容器與原生表現接近，容器化在記憶體可用性上未造成顯著負擔。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q4, D-Q7

A-Q16: 本文兩平台的測試數據與差異？
- A簡: 2012R2：Phase1 4416MB、Phase3 2888MB、65.40%。2016 容器：4032MB、2696MB、66.87%。
- A詳: 在 2012R2 Server Core，未指定分頁檔下，Phase1 可得 4416MB，碎片後 Phase3 得 2888MB，利用率 65.40%。在 2016 TP4 Windows 容器，Phase1 為 4032MB、Phase3 為 2696MB，利用率 66.87%。整體來看容器與原生差異有限，顯示容器開銷在此測項可忽略。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q15, B-Q2, C-Q5

A-Q17: 宿主工作管理員可見容器內進程代表什麼？
- A簡: 代表共用同一內核，進程由宿主核心管理，非完全隔離的 VM。
- A詳: 在宿主 OS 的工作管理員中可看到容器內的指令與進程，證實容器與宿主共用同一內核，進程由同一核心排程與記憶體管理，符合容器設計。反之，若為 VM，宿主看不到客體內部進程。此觀察也解釋為何容器在資源利用與效能上更接近原生。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q6, B-Q6

A-Q18: 什麼是互動模式（interactive mode）？本文遇到何種現象？
- A簡: 以互動終端進入容器的模式；TP4 回應較慢，指令輸入有延遲。
- A詳: 互動模式指在 docker run -it 或相當機制下，附著終端至容器內殼層，方便手動操作與診斷。本文於 TP4 體驗時，互動模式回應較慢，可能與 Preview 版效能調校未完善、終端轉送與 I/O 管線有關。建議後續以非互動批次流程或新版系統改善體驗。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q12, C-Q10, D-Q1

A-Q19: 為何選擇以原始碼就地編譯測試？
- A簡: 排除編譯產物差異，貼近目標平台行為，提升公平性與重現性。
- A詳: 不同平台的執行時、編譯器與最佳化可能影響行為。就地編譯可確保使用該平台的工具鏈與相依，避免跨平台建置帶來的差異，並可同步量測還原、編譯成本。本文在各平台下載套件、編譯後執行兩次，取第二次數據，以統一流程確保比較公允。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: B-Q1, A-Q11, C-Q3

A-Q20: 「記憶體回收不算特別突出」意味著什麼？
- A簡: GC 與系統回收後仍留有碎片或不可用空間，Phase3 容量顯著低於 Phase1。
- A詳: 即使在釋放記憶體並觸發回收後，由於碎片化或大物件堆的限制，重新配置時能取得的連續空間仍明顯少於初始狀態。本文以利用率衡量，兩平台皆約六成多，顯示一般回收並未完全緩解碎片造成的可用性下降，需視需求採更進階的記憶體策略。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q3, D-Q8


### Q&A 類別 B: 技術原理類

B-Q1: 本文記憶體測試流程如何運作？
- A簡: 重啟、還原套件、編譯、連續執行兩次，取第二次結果，確保穩態與可比性。
- A詳: 技術原理說明：首次執行常含套件還原與 JIT，影響觀測。關鍵步驟：1) VM 重啟清環境；2) 下載/還原套件；3) 編譯；4) 連續執行兩次取第二次。核心組件：.NET Core 宿主（dnx.exe）、套件管理器、JIT 與 GC。此流程將非測項的成本盡可能移除，呈現平台在穩態下的記憶體可用性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, A-Q19, C-Q3

B-Q2: 記憶體利用率指標的計算機制是什麼？
- A簡: Phase3 可得量除以 Phase1 可得量，衡量碎片化後可用性比例。
- A詳: 技術原理說明：以相同程式在三階段測量可分配量。Phase1 為乾淨狀態最大可用；Phase2 製造碎片；Phase3 再配置。關鍵步驟：記錄 Phase1、Phase3 的總量，計算 Ratio=Phase3/Phase1。核心組件：分配器、GC、記憶體管理器。此指標直觀反映碎片化對可用空間的折損，便於跨平台比較。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q9, A-Q16, C-Q5

B-Q3: 記憶體碎片如何影響 .NET Core 的配置？
- A簡: 碎片使大區塊難以連續配置，特別影響大物件堆，導致 Phase3 能力下降。
- A詳: 技術原理說明：.NET 的 GC 會整理小物件堆，但大物件堆（LOH）通常不壓縮，長期配置/釋放大陣列易產生碎片。關鍵步驟：交錯配置與釋放，形成非連續空間，導致再配置大陣列失敗或縮減量。核心組件：GC、LOH、記憶體管理器。本文以碎片階段後再配置，觀察可用量下降，即為此效應的體現。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, D-Q8

B-Q4: Windows 容器的架構如何運作？
- A簡: 共用宿主內核，透過命名空間與層級檔案系統隔離，Docker 工具管理。
- A詳: 技術原理說明：容器是 OS 層虛擬化，共用內核，隔離進程、檔案、網路。關鍵步驟或流程：映像分層→建立容器→配置命名空間→啟動進程。核心組件：Windows 容器執行時、Docker Engine/CLI、基底映像（Server Core/Nano）。宿主工作管理員可見容器內進程，反映共用內核的排程與記憶體管理。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q3, A-Q17, B-Q6

B-Q5: Hyper-V 容器的機制是什麼？
- A簡: 以 Hyper-V 啟動輕量 VM，容器在 VM 內執行，提供核心層隔離。
- A詳: 技術原理說明：當指定 Hyper-V 隔離時，系統建立精簡 VMM 基底映像，於其中啟動容器。關鍵步驟：建立輕量 VM→掛載容器映像→啟動容器進程。核心組件：Hyper-V、容器執行時、隔離模式控制。對管理者透明，仍透過 docker CLI 操作，但宿主將看不到容器進程，因其位於 VM 內，隔離更強。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q4, A-Q5, C-Q8

B-Q6: 為何宿主可見容器內進程？
- A簡: 因共用同一內核，進程由宿主核心管理，故可被宿主工具列示。
- A詳: 技術原理說明：容器是進程層隔離，非硬體虛擬化；進程仍由宿主內核排程。關鍵步驟：建立容器命名空間→啟動進程→宿主核心追蹤 PID 與資源。核心組件：Windows 內核命名空間、Task Manager。此行為與 VM 不同，VM 內進程對宿主不可見。若改用 Hyper-V 容器，則會轉為不可見。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q17, B-Q5

B-Q7: Windows 上的 Docker 工具如何管理容器？
- A簡: 透過 Docker Engine 與 CLI/PowerShell 與 Windows 容器執行時整合，提供一致體驗。
- A詳: 技術原理說明：Windows 提供與 Docker 相容的 Engine 與 API。關鍵流程：安裝 Docker→拉取 Windows 映像→docker run 建立容器→docker exec 管理。核心組件：Docker CLI、Engine（Windows 版）、Windows 容器執行時。雖工具一致，但映像與系統呼叫必須對應 Windows 內核。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q3, C-Q3

B-Q8: Windows 與 Linux 容器架構通用與差異？
- A簡: 通用在映像分層與工具；差異在內核與系統呼叫，映像不可互通。
- A詳: 技術原理說明：兩者皆用分層映像、命名空間、Cgroups/Job Objects 等觀念。關鍵差異：內核不同、系統呼叫與 ABI 不同，映像需匹配內核。核心組件：Linux/Windows 內核子系統、容器執行時。管理上 Docker CLI 相似，但實作細節與映像來源不同。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q7, B-Q4

B-Q9: 2012R2 Server Core 與 2016 Nano 的資源特徵差異原理？
- A簡: Nano 更精簡、雲原生；Server Core 較完整，皆適合伺服器與容器基底。
- A詳: 技術原理說明：Nano 移除本機登入與大量元件，以遠端管理為主，鏟除不必要 DLL 與角色，減少佔用與更新。Server Core 保留較多元件與相容性。本文將 Nano 作為容器宿主與映像基礎，觀察其在容器化記憶體測試的效率，與 Server Core 對照。兩者皆能支援 .NET Core 測試流程。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q1, A-Q2

B-Q10: 分頁檔與 RAM 如何共同影響程序記憶體？
- A簡: Windows 以提交與工作集模型管理，RAM 先滿，後續依需使用分頁檔。
- A詳: 技術原理說明：程序配置記憶體需「提交」虛擬記憶體，總提交受 RAM+分頁檔上限影響。工作集是實際駐留於 RAM 的頁面，超出時會換出至分頁檔。關鍵流程：先用盡可用 RAM→增加換出→提交繼續上升。核心組件：Memory Manager、Pagefile。本文觀察到實體先滿，後續主要使用分頁檔承載大配置。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, D-Q7

B-Q11: 第二次執行為何更能代表穩態？
- A簡: 首次包含還原、JIT、快取等開銷；第二次則多已完成初始化。
- A詳: 技術原理說明：.NET 第一次執行會 JIT 編譯、讀取組件、建立快取；相依套件可能首次還原。關鍵步驟：第一次執行完成後，記憶體與快取狀態穩定，第二次執行減少非受測因素。核心組件：JIT、NuGet/套件管理、檔案快取。本文統一採第二次數據，以提升跨平台比較一致性。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, A-Q19

B-Q12: 為何互動模式較慢？
- A簡: 預覽版調校未完善，加上終端輸入輸出轉送與 TTY 管線開銷。
- A詳: 技術原理說明：docker -it 會建立偽終端與資料流轉送，Windows TP4 時期在管線、I/O 合併與緩衝尚未最佳化。關鍵步驟：宿主與容器間 STDIN/STDOUT 綁定→資料多層轉送。核心組件：Docker Engine、ConPTY/TTY 管線。建議使用非互動腳本或升級版本以改善。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q18, C-Q10, D-Q1


### Q&A 類別 C: 實作應用類（10題）

C-Q1: 如何用 C# 撰寫記憶體碎片化測試程式？
- A簡: 以大量配置/釋放 byte 陣列製造碎片，分三階段量測可分配總量並計算比值。
- A詳: 具體實作步驟：1) Phase1 持續配置 1MB 區塊直到失敗；2) Phase2 釋放部分區塊造成碎片；3) Phase3 再次配置計算總量。程式碼片段：var list=new List<byte[]>(); for(..){ list.Add(new byte[1024*1024]); } // 釋放偶數索引 list[i]=null; GC.Collect(); 注意事項：釋放後呼叫 GC.Collect() 與 GC.WaitForPendingFinalizers()；記錄失敗例外與累計量。最佳實踐：固定區塊大小、在相同流程與建置模式下重複測試。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q12, B-Q3, C-Q5

C-Q2: 在 Server Core 如何開啟工作管理員？
- A簡: 於命令列直接執行 taskmgr.exe，即可啟動圖形化工作管理員。
- A詳: 具體實作步驟：1) 登入 Server Core 的命令提示字元或 PowerShell；2) 輸入 taskmgr.exe 並執行；3) 切換至效能與處理程序分頁觀察記憶體。設定片段：cmd> taskmgr.exe。注意事項：需具備桌面互動權限；遠端可用 Task Manager 或 Performance Monitor 連線。最佳實踐：同時記錄 Get-Process 與工作管理員數據互相驗證。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q1, A-Q17

C-Q3: 2012R2 上如何執行本文的測試流程？
- A簡: 重啟→還原套件→編譯→連續執行兩次，取第二次結果並做紀錄。
- A詳: 具體步驟：1) 重啟 VM 清理環境；2) 還原相依套件（例如 dnu restore 或 dotnet restore）；3) 編譯（dnu build 或 dotnet build -c Release）；4) 執行兩次（dnx run 或 dotnet run），取第二次數據。命令片段：dotnet restore; dotnet build -c Release; dotnet run。注意事項：使用相同建置模式、避免其他背景程序干擾。最佳實踐：將測試腳本化，輸出 CSV 便於比對。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: B-Q1, A-Q11

C-Q4: 在 Windows 容器內如何建置並執行測試？
- A簡: 使用 docker run 進入容器，複製原始碼，還原、編譯並執行兩次取第二次。
- A詳: 具體步驟：1) 取得基底映像：docker pull mcr.microsoft.com/windows/servercore；2) 啟動互動殼：docker run --isolation=process -it <image> powershell；3) 將程式碼複製進容器：docker cp src <container>:/app；4) 進入 /app 還原與建置：dotnet restore/build；5) dotnet run 兩次取第二次。指令片段：docker run -it mcr.microsoft.com/windows/servercore powershell。注意事項：使用對應版本的 .NET Core；建議使用 Release。最佳實踐：以 docker logs 或自寫輸出紀錄數據。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q3, A-Q18, B-Q7

C-Q5: 如何計算本文的記憶體利用率指標？
- A簡: 將 Phase1 與 Phase3 的可分配量記錄下來，利用率=Phase3/Phase1。
- A詳: 具體步驟：1) 程式在每階段累加成功配置的 MB 數；2) 輸出 Phase1、Phase3；3) 利用率=Phase3/Phase1，轉為百分比。程式碼片段：var util = (double)phase3/phase1; Console.WriteLine($"{util:P2}"); 注意事項：單位一致（MB）；失敗例外要正確攔截。最佳實踐：多次重複後取中位數，降低偶發波動。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q9, A-Q16, B-Q2

C-Q6: 如何在 Server Core 設定分頁檔大小？
- A簡: 關閉自動管理，使用 wmic 或 PowerShell 建立/調整 pagefile 設定。
- A詳: 具體步驟：1) 關閉自動管理：wmic computersystem set AutomaticManagedPagefile=False；2) 建立或修改：wmic pagefileset create name="C:\\pagefile.sys"；wmic pagefileset where name="C:\\\\pagefile.sys" set InitialSize=4096,MaximumSize=4096；3) 重啟生效。注意事項：權限需求；大小需與測試計畫一致。最佳實踐：測試前固定分頁檔，確保不同平台可比性。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, B-Q10, D-Q2

C-Q7: 如何在宿主觀察容器內進程與記憶體？
- A簡: 直接用宿主工作管理員或 PowerShell Get-Process 觀察容器進程資源。
- A詳: 具體步驟：1) 在宿主開啟 Task Manager，切至 Processes/Performance；2) 或用 PowerShell：Get-Process -Name dotnet,dnx；3) 比對容器內輸出與宿主觀察。設定：Get-Process | Where-Object { $_.ProcessName -in @("dotnet","dnx") }。注意事項：Hyper-V 隔離看不到容器進程。最佳實踐：同時收集 docker stats 與宿主資料做交叉驗證。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q17, B-Q6, C-Q8

C-Q8: 如何以 Hyper-V 隔離模式啟動 Windows 容器？
- A簡: 於 docker run 指定 --isolation=hyperv，即以 Hyper-V 容器模式啟動。
- A詳: 具體步驟：1) 確認已啟用 Hyper-V 功能；2) 執行：docker run --isolation=hyperv -it mcr.microsoft.com/windows/servercore powershell；3) 在宿主 Task Manager 將看不到容器內進程。設定片段：--isolation=hyperv。注意事項：資源開銷較大、啟動較慢；僅支援 Windows 映像。最佳實踐：需強隔離或多租戶場景再啟用。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q4, A-Q5, B-Q5

C-Q9: 如何收集程序記憶體使用數據做比對？
- A簡: 使用 Get-Process、Performance Counters 與自訂輸出，形成結構化紀錄。
- A詳: 具體步驟：1) PowerShell：Get-Process dnx | Select Name,WS,PM,VM；2) perfmon 加入「Process」計數器（Working Set、Private Bytes、Virtual Bytes）；3) 程式輸出 Phase1/3 值；4) 匯出 CSV 比對。指令片段：Get-Counter "\Process(dnx)\Working Set - Private"。注意事項：單位換算與時間戳對齊。最佳實踐：將量測腳本化，隨測試提交。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q16, B-Q10

C-Q10: 如何改善互動模式的體驗與效能？
- A簡: 優先用非互動腳本與 docker exec；降低即時輸出；升級至較新版本。
- A詳: 具體步驟：1) 以 docker exec 執行批次腳本代替長時間互動；2) 減少主控台輸出以降低 I/O；3) 使用 Release 建置；4) 升級至較新 OS/Docker 版本。命令片段：docker exec <id> powershell -File run.ps1。注意事項：避免 TTY 長連線；確保資源限制足夠。最佳實踐：以 CI 執行自動化測試，收集日誌而非即時互動。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q18, B-Q12, D-Q1


### Q&A 類別 D: 問題解決類（10題）

D-Q1: 互動模式下指令回應很慢怎麼辦？
- A簡: 改用 docker exec 批次執行、降低 I/O、升級版本，避免長時間 TTY 互動。
- A詳: 症狀：輸入延遲、輸出卡頓。可能原因：TP4 效能未優化、TTY 管線開銷、容器資源不足。解決步驟：1) 使用 docker exec -File 執行腳本；2) 減少 console 輸出；3) 調整 CPU/記憶體；4) 升級至較新版本。預防：以非互動自動化流程替代手動互動，將觀測改為日誌與指標收集。
- 難度: 初級
- 學習階段: 核心
- 關聯概念: A-Q18, C-Q10, B-Q12

D-Q2: 測試時只能分配到很小的記憶體，怎麼排查？
- A簡: 檢查分頁檔大小、程序位數、容器限制與建置模式，逐一放寬與修正。
- A詳: 症狀：Phase1 極小。可能原因：pagefile 太小、32 位元程序、容器記憶體限制、Debug 模式開銷。解決步驟：1) 設定固定且足夠的 pagefile（C-Q6）；2) 確認 x64；3) 移除容器限制；4) 用 Release。預防：測試前統一環境設定與建置模式，寫入檢查腳本。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q13, C-Q6

D-Q3: 在 Server Core 無法開啟工作管理員？
- A簡: 以 taskmgr.exe 啟動，或改用遠端管理與 PowerShell 收集數據。
- A詳: 症狀：找不到 GUI 管理工具。可能原因：Server Core 無預設 GUI 捷徑。解決步驟：1) 在 cmd/PowerShell 執行 taskmgr.exe；2) 若受限，使用 Get-Process、Get-Counter；3) 也可遠端連線工作管理員。預防：預先準備 PowerShell 量測腳本，避免依賴 GUI。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q2, C-Q9

D-Q4: .NET Core 程式第一次執行很慢如何處理？
- A簡: 預先還原與暖機，取第二次數據；必要時使用 ReadyToRun 或交付已建置包。
- A詳: 症狀：首次啟動耗時、數據波動。可能原因：套件還原、JIT 編譯、快取初始化。解決步驟：1) 先執行一次暖機；2) 固定取第二次；3) 可用 Release 與 ReadyToRun。預防：在測試流程中加入 restore/build 步驟，將環境初始化與測試分離。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q11, B-Q11, C-Q3

D-Q5: 容器內嘗試拉 Linux 映像失敗怎麼辦？
- A簡: Windows 容器無法用 Linux 映像，改用 Windows 基底映像執行。
- A詳: 症狀：docker pull/ run Linux 映像失敗或無法啟動。可能原因：內核不相容。解決步驟：1) 使用 mcr.microsoft.com/windows/* 映像；2) 確認 Isolation 與主機版本相容；3) 依應用需求選 Server Core 或 Nano。預防：事前確認映像與宿主內核的對應關係。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q7, B-Q8, C-Q4

D-Q6: 宿主看不到容器內進程，如何診斷？
- A簡: 檢查是否為 Hyper-V 隔離、遠端工作階段限制，或工具過濾條件。
- A詳: 症狀：Task Manager 無相關進程。可能原因：--isolation=hyperv、遠端權限、過濾設定。解決步驟：1) docker inspect 查隔離模式；2) 確認在宿主本機查看；3) 用 PowerShell Get-Process 全列；4) 若為 Hyper-V，改用 VM 內工具觀測。預防：啟動前明確標記隔離模式。
- 難度: 中級
- 學習階段: 核心
- 關聯概念: A-Q17, C-Q8, B-Q5

D-Q7: 看到物理記憶體先滿後分頁檔暴增，正常嗎？
- A簡: 正常。Windows 以提交與工作集管理，超出 RAM 會換出至分頁檔。
- A詳: 症狀：RAM 快速滿載、pagefile 使用上升。可能原因：大規模配置超出工作集。解決步驟：1) 確認 pagefile 足夠；2) 觀察工作集與提交大小；3) 避免不必要的大配置。預防：合理設定 pagefile、以批次分段配置，減少瞬間峰值。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q13, B-Q10

D-Q8: 記憶體回收效果不佳如何改善？
- A簡: 降低 LOH 壓力、分塊配置、減少交錯釋放，或調整 GC 設定與模式。
- A詳: 症狀：碎片後可用量顯著下降。可能原因：LOH 碎片、交錯配置/釋放。解決步驟：1) 避免大陣列頻繁配置；2) 物件重用/池化；3) 調整 GCServer/GC 設定；4) 規劃資料結構以減少碎片。預防：壓測前做記憶體設計審視，監控 LOH 與 GC 指標。
- 難度: 中級
- 學習階段: 進階
- 關聯概念: A-Q20, B-Q3

D-Q9: 記憶體利用率計算結果異常（>100%）怎麼辦？
- A簡: 檢查數據單位、取值時機、是否取第一次數據或重複計算錯誤。
- A詳: 症狀：比值超過 100% 或負值。可能原因：單位不一致（MB/Bytes）、取錯階段、溢位、第一次執行被納入。解決步驟：1) 統一單位；2) 僅取第二次；3) 使用安全型別（long/double）；4) 加上防呆檢查。預防：將計算封裝並寫入單元測試。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: C-Q5, B-Q2

D-Q10: 在 2016 TP4 上 Docker 命令整體偏慢，如何處理？
- A簡: 先接受預覽版限制，減少 I/O、升級至較新版本，或改以批次腳本執行。
- A詳: 症狀：docker pull/run/exec 反應慢。可能原因：TP4 效能未優化、映像下載頻寬、儲存層效能。解決步驟：1) 使用本地快取/私有 registry；2) 精簡映像；3) 非互動批次執行；4) 升級至正式版或較新 TP。預防：預先拉取映像與建置，降低測試當下開銷。
- 難度: 初級
- 學習階段: 基礎
- 關聯概念: A-Q18, C-Q4, C-Q10


### 學習路徑索引
- 初學者：建議先學習哪 15 題
    - A-Q1: 什麼是 Windows Server 2012 R2 Server Core？
    - A-Q2: 什麼是 Windows Server 2016 Nano (Tech Preview 4)？
    - A-Q3: 什麼是 Windows Container？
    - A-Q6: Windows Container 與傳統 VM 有何差異？
    - A-Q7: 為何 Windows 容器不能直接使用 Linux 映像？
    - A-Q8: 什麼是 .NET Core 的 dnx.exe？
    - A-Q9: 什麼是本文的「記憶體利用率」指標？
    - A-Q10: 為什麼要做記憶體管理大考驗？
    - A-Q11: 為何測試需連續執行兩次取第二次數據？
    - A-Q12: 什麼是記憶體碎片化（在本文脈絡）？
    - A-Q13: 什麼是分頁檔（pagefile），在測試中扮演何種角色？
    - A-Q17: 宿主工作管理員可見容器內進程代表什麼？
    - C-Q2: 在 Server Core 如何開啟工作管理員？
    - C-Q3: 2012R2 上如何執行本文的測試流程？
    - D-Q4: .NET Core 程式第一次執行很慢如何處理？

- 中級者：建議學習哪 20 題
    - A-Q14: 為何選擇 Server Core 作為對照組？
    - A-Q15: Windows Container 的效能是否接近原生？
    - A-Q16: 本文兩平台的測試數據與差異？
    - A-Q18: 什麼是互動模式？本文遇到何種現象？
    - A-Q19: 為何選擇以原始碼就地編譯測試？
    - A-Q20: 「記憶體回收不算特別突出」意味著什麼？
    - B-Q1: 本文記憶體測試流程如何運作？
    - B-Q2: 記憶體利用率指標的計算機制是什麼？
    - B-Q3: 記憶體碎片如何影響 .NET Core 的配置？
    - B-Q4: Windows 容器的架構如何運作？
    - B-Q6: 為何宿主可見容器內進程？
    - B-Q7: Windows 上的 Docker 工具如何管理容器？
    - B-Q10: 分頁檔與 RAM 如何共同影響程序記憶體？
    - B-Q11: 第二次執行為何更能代表穩態？
    - C-Q1: 如何用 C# 撰寫記憶體碎片化測試程式？
    - C-Q4: 在 Windows 容器內如何建置並執行測試？
    - C-Q5: 如何計算本文的記憶體利用率指標？
    - C-Q7: 如何在宿主觀察容器內進程與記憶體？
    - D-Q2: 測試時只能分配到很小的記憶體，怎麼排查？
    - D-Q7: 看到物理記憶體先滿後分頁檔暴增，正常嗎？

- 高級者：建議關注哪 15 題
    - A-Q4: 什麼是 Hyper-V Container？
    - A-Q5: Windows Container 與 Hyper-V Container 有何差異？
    - B-Q5: Hyper-V 容器的機制是什麼？
    - B-Q8: Windows 與 Linux 容器架構通用與差異？
    - B-Q9: 2012R2 與 2016 Nano 的資源特徵差異原理？
    - B-Q12: 為何互動模式較慢？
    - C-Q6: 如何在 Server Core 設定分頁檔大小？
    - C-Q8: 如何以 Hyper-V 隔離模式啟動 Windows 容器？
    - C-Q9: 如何收集程序記憶體使用數據做比對？
    - C-Q10: 如何改善互動模式的體驗與效能？
    - D-Q1: 互動模式下指令回應很慢怎麼辦？
    - D-Q5: 容器內嘗試拉 Linux 映像失敗怎麼辦？
    - D-Q6: 宿主看不到容器內進程，如何診斷？
    - D-Q8: 記憶體回收效果不佳如何改善？
    - D-Q10: 在 2016 TP4 上 Docker 命令整體偏慢，如何處理？