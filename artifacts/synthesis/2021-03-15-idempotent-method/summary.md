# [分散式系統 #1] Idempotency Key 的原理與實作 - 能安全 Retry 的 API 設計

## 摘要提示
- 分散式系統坑: 微服務落地難不在切分服務，而在網路不可靠、流程跨邊界導致的複雜度與錯誤處理。
- 網路不可靠: 連線中斷與回應丟失很常見，導致「結果未知」與重複執行風險。
- Retry抉擇: 沒收到回應時是否重試是核心難題，避免造成重複扣款或重複下單。
- 冪等定義: Idempotent 指同一請求重複執行，系統狀態與回應保持一致，不產生額外副作用。
- API原生冪等: 從業務流程與資料模型設計讓操作天然冪等，降低重試風險。
- Idempotency Key: 以唯一鍵標識請求，服務端檢測與去重，確保多次呼叫只生效一次。
- 安全扣款範例: 金流/扣款等有副作用操作最需冪等，避免網路抖動導致多扣。
- 結果重放: 服務端可基於 Key 緩存與重放結果，讓重試拿到相同回應。
- 客端與伺服器協作: 客戶端生成請求鍵、設置重試策略；服務端落盤/快取請求紀錄。
- 落地重點: 定義幂等邊界、鍵的作用域與期限、儲存與一致性策略、錯誤碼與觀測性。

## 全文重點
本文聚焦分散式系統中最常見的實務難題：在不可靠網路下，如何讓遠端 API 維持正確性且可安全重試。作者以「扣款 100 元」的情境說明：當呼叫回應在途中丟失、呼叫端無法確認成功與否時，若盲目重試可能造成重複扣款；若不重試，則可能遺漏必要操作。這種典型「結果未知」情境要求 API 設計具備冪等性（Idempotency）。

冪等的核心是：針對同一個業務意圖，重複執行不會改變系統最終狀態，且回應一致。要達到此目標，有兩條路徑：一是讓操作本身天然冪等，例如以資源的「最終狀態設定」取代「累加式變更」，或使用「去重的業務唯一鍵」控制副作用只發生一次；二是在非天然冪等的操作上引入 Idempotency Key 機制，將每個意圖以唯一鍵標記，服務端檢查是否已處理過，若是則重放既有結果，若否才執行並記錄結果。

Retry 策略上，客戶端需能在超時或連線中斷時安全重試，前提是請求攜帶穩定的 Idempotency Key，並避免在不同嘗試中變更語意（例如同一訂單使用同一鍵）；服務端需建立可靠的去重存儲（快取或資料庫），定義鍵的有效期、粒度（按使用者、資源或全域）、幂等邊界（例如單次扣款意圖），並確保在部分失敗時仍能一致地記錄與回覆。對於金流、下單等高風險場景，還需要結果重放、操作狀態可查詢、清楚的錯誤碼與觀測性（日誌/指標/追蹤）作為輔助。

總結來說，本文強調：微服務的難點在分散式系統的現實條件，安全 Retry 的關鍵在冪等性設計；透過原生冪等的業務建模與 Idempotency Key 的工程機制配合，才能在不可靠網路下確保正確性、使用者體驗與系統穩定性。

## 段落重點
### 前言: 分散式系統的常見難題
作者從實務經驗出發，指出微服務導入之所以「到處是坑」，多半不是因為服務切分本身，而是因為一旦跨進程與跨網路，原本在單體或資料庫層面「兩三下就能搞定」的工作，會被延遲、故障、部分失敗、訊息丟失等問題放大。系統需面對不可預期的連線中斷、超時與回應丟失，導致「我到底該不該重試」的抉擇困境。本文因此要回答：如何在不可靠的網路上，保證遠端 API 的正確執行，並且讓呼叫端能放心地進行重試，而不會造成重複操作或資料污染。這個主題本質上屬於分散式系統範疇，是微服務落地的基礎工程能力。

### Retry? 我應該要重新呼叫 API 嗎?
以「扣款 100 元」為例：當呼叫回應未達、連線瞬斷且恢復後，呼叫端面臨結果未知。如果再呼叫一次，可能重複扣款；若不呼叫，可能漏扣。這類情境普遍存在於金流、下單、資源建立等具副作用的操作。解法不是單靠直覺調整超時或盲目多次嘗試，而是要讓「重試」變成安全操作：相同意圖的重複呼叫不會改變最終狀態。這要求請求具有能被辨識的穩定身份（例如請求鍵），以及服務端能辨識與去重；同時，錯誤碼需能區分「已受理但結果未知」與「未受理」等狀態，讓客戶端可採取查詢狀態或重放請求的正確行為。

### 關鍵字: Idempotent 的定義與原理
冪等（Idempotent）的核心定義是：對同一資源或業務意圖，多次執行結果與一次執行一致，無額外副作用。HTTP 規範中 GET、PUT、DELETE 理念上是冪等，而 POST 通常不是，但在業務建模得當與引入請求唯一鍵時，POST 也能達成冪等效果。原理上常見手法包括：以「設定最終狀態」取代「相對變更」（例如設定餘額為 X 而不是加減）；對命令類操作引入「業務唯一鍵」使同一意圖只生效一次；在服務端維護請求處理記錄並重放結果。重點在於界定幂等的「邊界」：以什麼維度判定同一意圖、哪些欄位參與語意、以及在部分失敗或競態下如何保持一致。

### 設計原生支援 Idempotent Safe 的 API
若能在業務層級讓操作天然冪等，會比事後補救更穩健。設計要點包括：資源導向的介面設計（以 PUT/DELETE 管控最終狀態）、使用可對齊業務語意的唯一鍵（如訂單號、交易意圖 ID），以及將「建立或覆寫」模式取代「累加式變更」。對需要副作用的操作（例如扣款、扣庫存），可將流程拆解為「預留/鎖定」與「確認/提交」兩階段，使每一步都可冪等重試並可恢復。此外，明確定義錯誤與回應語意：已處理過的重複請求回傳相同結果或特定狀態碼，讓客戶端能安全地重試、去重或查詢，不再依賴隱性的網路行為。

### 額外附加的 Idempotency Key 保護機制
當操作無法純以資源建模達成冪等時，引入 Idempotency Key 成為關鍵機制。流程為：客戶端為每個「意圖」生成唯一鍵，隨請求送至服務端；服務端在持久化或快取層查驗此鍵，若未處理則執行並記錄結果與狀態；若已處理則直接重放之前的結果。設計要點含：鍵的作用域（按使用者、商戶、業務資源）、有效期限與清理策略、結果存放與一致性、在多節點下的去重與併發控制，以及對部分失敗的恢復策略。客戶端應保證相同意圖使用同一鍵，並搭配退避與上限的重試策略；服務端需輸出可觀測性（日志/指標/追蹤）與明確錯誤碼，支援狀態查詢，確保在不可靠網路下，重試能真正做到「只生效一次且回應一致」。

## 資訊整理

### 知識架構圖
1. 前置知識：
   - 分散式系統的基本特性：網路不可靠、節點故障、重試與重入風險
   - HTTP/REST 基本概念：方法語義（GET/POST/PUT/DELETE）、狀態碼、冪等性
   - 基本資料一致性觀念：事務、重試策略、至少一次 vs 正好一次語義
   - 持久化與唯一性約束：資料庫唯一鍵、去重邏輯、快取
2. 核心概念：
   - 冪等性（Idempotent）：重複執行同一請求不改變系統狀態
   - Retry 安全：在不確定結果時可安心重試而不造成重複副作用
   - Idempotency Key：用戶端生成的唯一請求識別，伺服端用於去重與結果重放
   - 原生冪等 API 設計：以資源語義與唯一鍵設計讓操作天然冪等（如 PUT/upsert）
   - 伺服端去重與結果記憶：透過唯一約束、請求記錄、輸出緩存實現
   彼此關係：為了在不可靠網路中實現安全重試，需以冪等為目標設計 API；當資源語義不足以天然冪等時，以 Idempotency Key 與伺服端去重記錄補強，配合正確的重試與錯誤處理策略。
3. 技術依賴：
   - HTTP 方法語義與狀態碼設計 → 引導冪等行為
   - 資料庫唯一鍵/索引、事務與隔離等級 → 實作去重與一致性
   - 儲存層或快取（如 Redis）→ 儲存 Idempotency Key、結果快取、TTL 控制
   - 日誌與可觀測性（trace ID、request ID）→ 排錯與追蹤
4. 應用場景：
   - 金流扣款、退款、訂單建立與去重
   - 庫存扣減、積分發放、票券核銷
   - Webhook/事件處理的去重（第三方重送）
   - 批次或非同步任務提交、工作隊列的至少一次投遞

### 學習路徑建議
1. 入門者路徑：
   - 理解 HTTP 方法的冪等語義與常見狀態碼
   - 認識分散式環境的失敗模式（超時、網路抖動、部分成功）
   - 以簡單案例練習：用 PUT 設計資源 upsert，確保重試不造成重複資料
2. 進階者路徑：
   - 在 POST 場景導入 Idempotency Key：設計 key 生成、伺服端唯一性校驗與結果重放
   - 規劃資料庫唯一鍵與跨層事務；處理競爭條件與一致性
   - 設計重試策略（退避、上限、可重試錯誤分類）與回應行為（相同 key 回傳相同結果）
3. 實戰路徑：
   - 為金流/訂單 API 增加 Idempotency Key 支援：定義 header、key 範圍、TTL、結果快取
   - 落地監控與告警：記錄請求 ID、關聯日誌、指標（重試率、去重命中率）
   - 在事件/隊列中實作去重表與處理冪等 handler；壓測與故障演練（網路斷線、重放）

### 關鍵要點清單
- 冪等性（Idempotent）的定義: 相同請求重複執行，系統狀態與回應應一致，避免副作用累加 (優先級: 高)
- Retry 安全: 在結果不確定時允許重試，且不導致重複扣款或重複建立資源 (優先級: 高)
- 原生冪等 API 設計: 優先用資源導向與 PUT/upsert 模式實現天然冪等，而非事後補救 (優先級: 高)
- Idempotency Key 概念: 客戶端生成唯一 key，伺服端以其去重並重放一致回應 (優先級: 高)
- Key 範圍與粒度: 定義 key 與資源/動作/租戶的綁定關係，避免跨語義誤用 (優先級: 中)
- 伺服端去重存儲: 使用資料庫唯一索引或 Redis set 記錄已處理 key，確保並發下仍唯一 (優先級: 高)
- 結果重放策略: 伺服端保存首次成功的響應負載與狀態碼，後續相同 key 回放一致結果 (優先級: 高)
- TTL 與資料保留: 為 Idempotency Key 設置合理有效期與清理策略，控制儲存成本 (優先級: 中)
- 請求內容綁定: 將 key 與重要請求摘要（哈希）綁定，防止同 key 不同 payload 被誤認相同 (優先級: 高)
- 錯誤分類與重試策略: 僅對超時、5xx、可重試錯誤進行指數退避重試；4xx 多為不重試 (優先級: 高)
- 一致性與事務: 在同一事務內寫入業務變更與去重記錄，避免「寫業務但未記去重」或反之 (優先級: 高)
- 競爭條件處理: 在高併發下用唯一索引/悲觀鎖/原子操作確保單一成功，其餘讀取已存在結果 (優先級: 高)
- 回應語義與狀態碼: 首次成功可回 200/201；同 key 重放回相同狀態碼與 body；衝突回 409；驗證錯誤回 422 (優先級: 中)
- 安全性與熵: Idempotency Key 應高熵、不可猜測，避免被濫用或撞 key (優先級: 中)
- 可觀測性: 在日誌/追蹤中關聯 request-id、idempotency-key，便於排查與審計 (優先級: 中)